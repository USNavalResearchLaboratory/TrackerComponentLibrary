/*

-Procedure  mice (MATLAB to CSPICE interfaces),

-Abstract

   The file contains the coded gateways between CSPICE and MATLAB.

-Disclaimer

   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.

   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.

   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.

-Required_Reading

   MICE.REQ

-Keywords

   MATLAB

*/


/*
   Recall the mexopts.sh file contains any user defined include path
   declarations ( -I...path... ) required for the build.
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "mex.h"
#include "SpiceUsr.h"
#include "SpiceZmc.h"
#include "SpiceZfc.h"
#include "mice.h"
#include "zzmice.h"
#include "zzerror.h"
#include "zzalloc.h"
#include "cspice_params.h"


/*
   ifdefs appropriate for compile against octave.
*/
#ifndef OCTAVE

#include "matrix.h"

#endif


#ifdef OCTAVE

#define true  1

#define false 0

#endif


/*

-Brief_I/O

   None.

-Detailed_Input

   None.

-Detailed_Output

   None.

-Parameters

   Also see mice.h, zzmice.h, cspice_params.h
*/

#define  Nx3           ConstSpiceDouble(*)[3]
#define  Nx4           ConstSpiceDouble(*)[4]
#define  Nx6           ConstSpiceDouble(*)[6]
#define  HASHSIZE      1999
#define  STR_LEN       255


/*
-Exceptions

-Files

   None.

-Particulars

   PLEASE DO NOT EDIT THIS FILE.

   If you have any questions about this package, feature request, or
   find any problems, please contact:

      Ed Wright, ed.wright@jpl.nasa.gov

   1. The first input variable passes from MATLAB in prhs[1], not prhs[0].
   plhs[0] contains the name of the interface to execute. The first output
   variable returns to MATLAB in plhs[0].

   Mice functionality depends on a number of routines provided with MATLAB by
   Mathworks. These routines (descriptions quoted from mathworks.com):

      -mxCreateNumericArray returns:

      A pointer to the created mxArray, if successful. If unsuccessful in a
      stand-alone (non MEX-file) application, mxCreateNumericArray returns NULL.
      If unsuccessful in a MEX-file, the MEX-file terminates and control returns
      to the MATLAB prompt. mxCreateNumericArray is unsuccessful when there is
      not enough free heap space to create the mxArray.

      -mxCreateString returns:

      A pointer to the created string mxArray if successful, and NULL
      otherwise. The most likely cause of failure is insufficient free
      heap space.

      -mxCreateDoubleMatrix returns:

      A pointer to the created mxArray, if successful. If unsuccessful in a
      stand-alone (non MEX-file) application, mxCreateDoubleMatrix returns
      NULL. If unsuccessful in a MEX-file, the MEX-file terminates and control
      returns to the MATLAB prompt. mxCreateDoubleMatrix is unsuccessful when
      there is not enough free heap space to create the mxArray.

      -mxCreateCharMatrixFromStrings returns:

      A pointer to the created string mxArray, if successful. If unsuccessful
      in a stand-alone (non MEX-file) application,
      mxCreateCharMatrixFromStrings returns NULL. If unsuccessful in a
      MEX-file, the MEX-file terminates and control returns to the MATLAB
      prompt. Insufficient free heap space is the primary reason for
      mxCreateCharArray to be unsuccessful. Another possible reason for
      failure is that str contains fewer than m strings.

      -mxCreateDoubleScalar returns:

      A pointer to the created mxArray, if successful. mxCreateDoubleScalar is
      unsuccessful if there is not enough free heap space to create the
      mxArray. If mxCreateDoubleScalar is unsuccessful in a MEX-file, the
      MEX-file prints an "Out of Memory" message, terminates, and control
      returns to the MATLAB prompt. If mxCreateDoubleScalar is unsuccessful
      in a stand-alone (non MEX-file) application, mxCreateDoubleScalar returns
      NULL in C (0 in Fortran).

   2. The mice_dtpool interface returns the number of values "n" associated with
   the kernel pool variable "name" as a double precision rather than an integer.
   This implementation removes the need to recast the integer field "n" to
   double in a wrapper.

   3. The 4xN and 3xN arguments passed the CK writers do not require an
   array transpose operation since the required form for these arrays in MATLAB
   notation resolves to the correct form for passing to the CSPICE call, i.e.
   Nx4 and Nx3.

   4. Several interfaces use mxMalloc for dynamic memory allocation as this
   function returns to top level on error without the need to check for a failed
   condition.

-Examples

   None.

-Restrictions

   Equo ne credite.

-Literature_References

   Mathworks External Interfaces Reference:

      http://www.mathworks.com/access/helpdesk/help/techdoc/matlab.html

-Author_and_Institution

   E.D. Wright        (JPL)
   G. Chinn           (JPL)
   S. C. Krening      (JPL)

-Version

*/

#define VERSION  "Mice 1.4.0 31-OCT-2012 (EDW)(SCK)"

/*

      Added interfaces:

         cspice_cidfrm (mice_cidfrm)
         cspice_cnmfrm (mice_cnmfrm)
         cspice_dafac
         cspice_dafbbs
         cspice_dafbfs
         cspice_dafcls
         cspice_dafcs
         cspice_dafdc
         cspice_dafec
         cspice_daffna
         cspice_daffpa
         cspice_dafgda
         cspice_dafgn
         cspice_dafgs
         cspice_dafopr
         cspice_dafopw
         cspice_dafus
         cspice_dcyldr
         cspice_dgeodr
         cspice_dlatdr
         cspice_dpgrdr
         cspice_drdcyl
         cspice_drdgeo
         cspice_drdlat
         cspice_drdpgr
         cspice_drdsph
         cspice_dsphdr
         cspice_dvpool
         cspice_edlimb (mice_edlimb)
         cspice_edterm
         cspice_fovray
         cspice_fovtrg
         cspice_frame
         cspice_frinfo (mice_frinfo)
         cspice_frmnam
         cspice_gfilum
         cspice_gfpa
         cspice_gfstol
         cspice_inedpl
         cspice_inelpl
         cspice_inrypl
         cspice_invort
         cspice_namfrm
         cspice_npedln (mice_npedln)
         cspice_npelpt (mice_npelpt)
         cspice_nplnpt (mice_nplnpt)
         cspice_occult
         cspice_phaseq
         cspice_pjelpl (mice_pjelpl)
         cspice_pl2nvc
         cspice_pl2nvp
         cspice_pl2psv
         cspice_psv2pl
         cspice_pxfrm2
         cspice_spkcls
         cspice_spkcpo (mice_spkcpo)
         cspice_spkcpt (mice_spkcpt)
         cspice_spkcvo (mice_spkcvo)
         cspice_spkcvt (mice_spkcvt)
         cspice_spkopn
         cspice_spkpvn
         cspice_spksfs
         cspice_spkw08
         cspice_surfpt (mice_surfpt)
         cspice_timdef_get
         cspice_timdef_set
         cspice_vprjp
         cspice_vprjpi
         cspice_vproj
         cspice_xfmsta

      Structure MiceBodID renamed MiceNameID.

      Structure MiceSurf renamed MiceNear.

      Many, many code and comment cleanups.

      Recoded cspice_gdpool, cspice_gipool, cspice_getfov to use mxAlloc
      instead of mxCreateNumericArray, reducing memory usage and eliminating
      possible memory leak.

      Input boolean arguments pass from the Matlab layer as integers.
      Those interface routines with boolean inputs had argcheck structs
      tagging the arguments as MiceBoolean instead of MiceInt. Corrected.

      Several memcpy calls replaced with the MOVED macro.

   -Mice 1.3.0 12-JUL-2010 (EDW)

      Added an mxDestroyArray call prior to each mxSetField call. This
      eliminates a memory leak caused when returning scalar values in
      structure members (dumb bug caused by designer who should be beaten
      with a sack of soggy rutabagas).

      Corrected dimension declaration of "ptarg[6]" to "ptarg[3]"
      for spkpos_c interface.

   -Mice 1.2.0 28-APR-2010 (EDW)

      Added interfaces:

         cspice_bodc2s (mice_bodc2s)
         cspice_ducrss
         cspice_dvcrss
         cspice_dvdot
         cspice_dvhat
         cspice_dvnorm
         cspice_dvsep
         cspice_ekfind
         cspice_ekgc
         cspice_ekgd
         cspice_ekgi
         cspice_eknelt
         cspice_gfrr
         cspice_vnorm
         cspice_vperp
         cspice_unitim

      Replaced use of *mxGetLogicals for logical arguments returned
      in structure fields with the

         mxSetField( ..., mxCreateLogicalScalar(...), ... )

      construct.

      Added ifdef block to eliminate use of "matrix.h" for octave builds.
      Need to eliminate "matrix.h" during octave builds first described by
      Peter Wolff.

      Corrected failure to release allocated memory in cspice_sce2s and
      cspice_scdecd after corresponding CSPICE call failures.

      Hash size increased to 1999.

      Corrected ArgCheck structure entry for boddef_c. Input variables
      were incorrectly marked as vectorized.

   -Mice 1.1.0 23-FEB-2009 (EDW)

      Altered function of the 'size' argument' in cspice_spkcov and
      cspice_ckcov to represent the number of intervals for the workspace
      window rather than the number of values in the window.

      All interfaces that add a scalar double precision value to a structure
      use a mxSetField call.

      Added interfaces:

         cspice_el2cgv
         cspice_gfdist
         cspice_gfposc
         cspice_gfrfov
         cspice_gfsep
         cspice_gfsntc
         cspice_gfsubc
         cspice_gftfov
         cspice_lmpool
         cspice_nvc2pl
         cspice_nvp2pl
         cspice_saelgv
         cspice_vrotv
         cspice_wncard
         cspice_wnsumd (mice_wnsumd)
         cspice_wnvald

      Corrected spelling error "carfinality."

   -Mice 1.0.0 14-FEB-2008 (EDW)

-Index_Entries

   MATLAB

-&
*/


/*

Calculate/assign common values, size of the default string length.
Note, find the DEFAULT_STR_LENGTH definitions in mice.h.

*/
SpiceInt default_str_size = DEFAULT_STR_LENGTH * sizeof(SpiceChar);


/*
No need to calculate this value multiple times.
*/
SpiceInt m2 = HASHSIZE;



/*
The hashtable routines implemented by Gilbert Chinn.
*/

struct bucket
   {
   char           * key;
   void           (*binding)(int, mxArray*[], int, const mxArray*[]);
   struct bucket  * next;
   };

static struct bucket *table[HASHSIZE];


/*
-Procedure  hashtable_destroy
*/
void hashtable_destroy()
   {
   int              i;
   struct bucket  * b;

   for (i=0;i<HASHSIZE;++i)
      {
      while ( (b = table[i]) )
         {
         table[i] = table[i]->next;
         free(b);
         }
      table[i] = NULL;
      }

   }




/*
-Procedure  hashtable_lookup
*/
void ( *hashtable_lookup(char *key) )(int, mxArray*[], int, const mxArray*[])
   {
   int index =  zzhash2_(key, &m2, strlen(key));
   struct bucket  * b;

   for (b=table[index]; b; b=b->next)
      {
      if (0==strcmp(b->key,key))
         {
         return b->binding;
         }
      }

   return NULL;
   }




/*
-Procedure Bucket
*/
struct bucket *Bucket( char *key,
                       void (*binding)(int, mxArray*[], int, const mxArray*[]),
                       struct bucket *next )
   {
   struct bucket *b = malloc(sizeof(struct bucket));

   if ( b == NULL )
      {
      mexErrMsgTxt( "MICE(MALLOCFAILED): malloc failed in struct bucket. "
                    "This is a fatal error. Please contact NAIF.");
      }

   b->key      = key;
   b->binding  = binding;
   b->next     = next;
   return b;
   }




/*
-Procedure hashtable_insert
*/
void hashtable_insert(char *key,
                      void (*binding)(int, mxArray*[], int, const mxArray*[]))
   {
   int index    = zzhash2_(key, &m2, strlen(key));
   table[index] = Bucket(key, binding, table[index]);
   }




/*
Block of wrapper function calls. All calls have the same form:

   cspice_name(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);

      or

   mice_name(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]);

*/

void cspice_mice(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];
   SpiceChar            value [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",  MiceChar, 0, {0}, 0},
      { "value", MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   /*
   Decide what to return based on the value of 'item.'

      __DATE__, a compiler directive, the date string of the compilation
      of the interface.

      __TIME__, a compiler directive, the time string of the compilation
      of the interface.

      VERSION, the string describing the version of Mice

   */
   if ( eqstr_c( "DATE", item ) )
      {
      strcpy( value, __DATE__ );
      }
   else if ( eqstr_c( "TIME", item ) )
      {
      strcpy( value, __TIME__ );
      }
   else if ( eqstr_c( "VERSION", item ) )
      {
      strcpy( value,  VERSION );
      }
   else
      {
      strcpy( value, "UNKNOWN" );
      }

   plhs[0] = mxCreateString( value );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_mice" );
      }

   }





/*

   void              axisar_c( ConstSpiceDouble     axis   [3],
                               SpiceDouble          angle,
                               SpiceDouble          r      [3][3]  );

*/
void cspice_axisar(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * axis;
   SpiceDouble    angle;
   SpiceDouble  * r;
   SpiceDouble    xr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "axis",  MiceDouble, 1, {3},    0},
      { "angle", MiceDouble, 0, {0},    0},
      { "r",     MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   axis   = A_DBL_ARGV(1);
   angle  = S_DBL_ARGV(2);
   r      = A_DBL_RET_ARGV(0);

   axisar_c( axis, angle, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])r );
   }




/*
   SpiceDouble              b1900_c( void )
*/
void cspice_b1900(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( b1900_c() );
   }




/*
   SpiceDouble              b1950_c( void )
*/
void cspice_b1950(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( b1950_c() );
   }




/*
   void              bodc2n_c ( SpiceInt             code,
                                SpiceInt             namelen,
                                SpiceChar          * name,
                                SpiceBoolean       * found   );
*/
void mice_bodc2n(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;
   SpiceInt           * vec_code;
   SpiceBoolean         found;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code", MiceInt,    0, {0}, 1},
      { "name", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( name, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);
   code     = *vec_code;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         code = *(vec_code  + i*extra->offset[0]);

         bodc2n_c( code, DEFAULT_STR_LENGTH, name, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name)   );
             }
          else
             {
             mxSetField(plhs[0], i, "name", mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i, "code" ) );
          mxSetField( plhs[0], i, "code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                            mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      bodc2n_c( code, DEFAULT_STR_LENGTH, name, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(name)   );
         }
      else
         {
         mxSetField(plhs[0], 0, "name", mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code)  );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              bodc2s_c ( SpiceInt        code,
                                SpiceInt        lenout,
                                SpiceChar     * name )

*/
void mice_bodc2s(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;
   SpiceInt           * vec_code;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "code", MiceInt,   0, {0}, 1},
      { "name", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( name, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         code = *(vec_code  + i*extra->offset[0]);

         bodc2s_c( code, DEFAULT_STR_LENGTH, name );
         CHECK_CALL_FAILURE(i);

         mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
         mxSetField( plhs[0], i, "name", mxCreateString(name) );

         mxDestroyArray( mxGetField( plhs[0], i, "code" ) );
         mxSetField( plhs[0], i, "code", zzmice_CreateIntScalar(code) );

         /*
         In this case, found should always return true.
         */
         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found", mxCreateLogicalScalar(true) );
         }

      }
   else
      {

      code = *vec_code;

      bodc2s_c( code, DEFAULT_STR_LENGTH, name );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      mxSetField( plhs[0], 0, "name", mxCreateString(name) );

      mxDestroyArray( mxGetField( plhs[0], 0, "code" ) );
      mxSetField( plhs[0], 0, "code", zzmice_CreateIntScalar(code) );

      /*
      In this case, found should always return true.
      */
      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found", mxCreateLogicalScalar(true) );
      }

   }




/*
   void              boddef_c ( ConstSpiceChar     * name,
                                SpiceInt             code );

*/
void cspice_boddef(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];
   SpiceInt             code;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar, 0, {0}, 0},
      { "code", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);
   code = S_INT_ARGV(2);

   boddef_c(name,code);
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              bodn2c_c ( ConstSpiceChar     * name,
                                SpiceInt           * code,
                                SpiceBoolean       * found );
*/
void mice_bodn2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_name;
   SpiceInt             code;
   SpiceBoolean         found;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar,  0, {0}, 1},
      { "code", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         bodn2c_c( name, &code, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name") );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name) );
             }
          else
             {
             mxSetField(plhs[0], i, "name",  mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i, "code") );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found") );
          mxSetField( plhs[0], i, "found",
                      mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      bodn2c_c( name, &code, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name") );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name",  mxCreateString(name)   );
         }
      else
         {
         mxSetField(plhs[0], 0, "name",  mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "code") );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found") );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              bods2c_c( ConstSpiceChar     * name,
                                SpiceInt           * code,
                                SpiceBoolean       * found );
*/
void mice_bods2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_name;
   SpiceInt             code;
   SpiceBoolean         found;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar,  0, {0}, 1},
      { "code", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         bods2c_c( name, &code, &found );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "name" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(name)   );
             }
          else
             {
             mxSetField( plhs[0], i, "name", mxCreateString("\0") );
             code = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(code) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                      mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      bods2c_c( name, &code, &found );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(name)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         code = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(code));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }





/*
 void              bodvcd_c ( SpiceInt           bodyid,
                              ConstSpiceChar     * item,
                              SpiceInt             maxn,
                              SpiceInt           * dim,
                              SpiceDouble        * values );


*/
void cspice_bodvcd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             bodyid;
   SpiceChar            item       [DEFAULT_STR_LENGTH+1];
   SpiceInt             maxn;
   SpiceInt             dim;
   SpiceDouble        * values;
   SpiceDouble          ret_values [MAXVAL];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "bodyid", MiceInt,    0, {0}, 0},
      { "item",   MiceChar,   0, {0}, 0},
      { "maxn",   MiceInt,    0, {0}, 0},
      { "values", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   bodyid = S_INT_ARGV(1);
   mxGetString( prhs[2], item, DEFAULT_STR_LENGTH );

   maxn = S_INT_ARGV(3);

   bodvcd_c( bodyid, item, maxn, &dim, ret_values);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return a vector of size 'dim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( dim, 1, mxREAL );
   values   = A_DBL_RET_ARGV(0);

   MOVED( ret_values, dim, values );

   }





/*
 void              bodvrd_c ( ConstSpiceChar     * body,
                              ConstSpiceChar     * item,
                              SpiceInt             maxn,
                              SpiceInt           * dim,
                              SpiceDouble        * values );

*/
void cspice_bodvrd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item       [DEFAULT_STR_LENGTH+1];
   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceInt             maxn;
   SpiceInt             dim;
   SpiceDouble        * values;
   SpiceDouble          ret_values [MAXVAL];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "item",   MiceChar,   0, {0}, 0},
      { "maxn",   MiceInt,    0, {0}, 0},
      { "values", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );
   mxGetString( prhs[2], item, DEFAULT_STR_LENGTH );

   maxn = S_INT_ARGV(3);

   bodvrd_c(body, item, maxn, &dim, ret_values);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Allocate the needed memory to return a vector of size 'dim'
   to MATLAB.
   */
   plhs[0]  = mxCreateDoubleMatrix( dim, 1, mxREAL );
   values   = A_DBL_RET_ARGV(0);

   MOVED( ret_values, dim, values );

   }




/*
   void              cgv2el_c ( ConstSpiceDouble    center[3],
                                ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceEllipse      * ellipse   );

*/
void cspice_cgv2el(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * center;
   SpiceDouble        * vec1;
   SpiceDouble        * vec2;
   SpiceEllipse         ellipse;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "center",  MiceDouble,  1, {3}, 0},
      { "vec1",    MiceDouble,  1, {3}, 0},
      { "vec2",    MiceDouble,  1, {3}, 0},
      { "ellipse", MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   center = A_DBL_ARGV(1);
   vec1   = A_DBL_ARGV(2);
   vec2   = A_DBL_ARGV(3);

   cgv2el_c ( center, vec1, vec2,  &ellipse );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           ellipse.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           ellipse.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           ellipse.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              cidfrm_c ( SpiceInt            cent,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found  );
*/
void mice_cidfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             cent;
   SpiceInt           * vec_cent;
   SpiceChar            frname[DEFAULT_STR_LENGTH+1];
   SpiceInt             frcode;
   SpiceBoolean         found;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cent",   MiceInt,    0, {0}, 1},
      { "cnmfrm", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_cent = A_INT_ARGV(1);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {

         cent = *(vec_cent  + i*extra->offset[0]);

         cidfrm_c ( cent,
                    DEFAULT_STR_LENGTH,
                    &frcode,
                    frname,
                    &found   );
         CHECK_CALL_FAILURE(i);

         mxDestroyArray( mxGetField( plhs[0], i, "frname" ) );
         if ( found )
            {
            mxSetField( plhs[0], i, "name", mxCreateString(frname) );
            }
         else
            {
            mxSetField( plhs[0], i, "name", mxCreateString("\0") );
            frcode = 0;
            }

         mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
         mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(frcode) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                          mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      cent = *vec_cent;

      cidfrm_c ( cent,
                 DEFAULT_STR_LENGTH,
                 &frcode,
                 frname,
                 &found   );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(frname)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         frcode = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(frcode));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              ckcls_c  ( SpiceInt            handle )
*/
void cspice_ckcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   ckcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              ckcov_c ( ConstSpiceChar    * ck,
                               SpiceInt            idcode,
                               SpiceBoolean        needav,
                               ConstSpiceChar    * level,
                               SpiceDouble         tol,
                               ConstSpiceChar    * timsys,
                               SpiceCell         * cover   )

*/
void cspice_ckcov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           ck    [DEFAULT_STR_LENGTH+1];
   SpiceChar           level [DEFAULT_STR_LENGTH+1];
   SpiceChar           timsys[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_ck;

   SpiceInt            i;
   SpiceInt            j;
   int                 sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            idcode;

   SpiceDouble       * cover_f;
   SpiceDouble       * cover;
   SpiceDouble         tol;

   SpiceBoolean        needav;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "ck",     MiceChar,    0, {0}, 1},
      { "idcode", MiceInt,     0, {0}, 0},
      { "needav", MiceInt, 0, {0}, 0},
      { "level",  MiceChar,    0, {0}, 0},
      { "tol",    MiceDouble,  0, {0}, 0},
      { "timsys", MiceChar,    0, {0}, 0},
      { "size",   MiceInt,     0, {0}, 0},
      { "cover",  MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   idcode = S_INT_ARGV(2);
   needav = *(SpiceBoolean*)mxGetData(prhs[3]);

   mxGetString(prhs[4], level, DEFAULT_STR_LENGTH);

   tol = S_DBL_ARGV(5);

   mxGetString(prhs[6], timsys, DEFAULT_STR_LENGTH);

   /*
   'size' defines the number of intervals for the workspace window,
   so double the value of size since an interval consists of
   two double precision values.
   */
   size = S_INT_ARGV(7) * 2;

   cover = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) cover );
   scardd_( ( integer * ) &card, ( double * ) cover );

   if (extra->count>1)
      {

      mx_ck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            ck[j] = (char)mx_ck[i + (extra->count*j)];
            }

         ck[extra->offset[0]] = '\0';

         ckcov_(  ( char       * ) ck,
                  ( integer    * ) &idcode,
                  ( logical    * ) &needav,
                  ( char       * ) level,
                  ( doublereal * ) &tol,
                  ( char       * ) timsys,
                  ( doublereal * ) (cover),
                  ( ftnlen       ) strlen(ck),
                  ( ftnlen       ) strlen(level),
                  ( ftnlen       ) strlen(timsys)  );

         /*
         Check for a failure signal. Free the memory assigned to 'cover'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( cover );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], ck, DEFAULT_STR_LENGTH);

      ckcov_(  ( char       * ) ck,
               ( integer    * ) &idcode,
               ( logical    * ) &needav,
               ( char       * ) level,
               ( doublereal * ) &tol,
               ( char       * ) timsys,
               ( doublereal * ) (cover),
               ( ftnlen       ) strlen(ck),
               ( ftnlen       ) strlen(level),
               ( ftnlen       ) strlen(timsys)  );

      /*
      Check for a failure signal. Free the memory assigned to 'cover'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( cover );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = cover[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   cover_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( cover + SPICE_CELL_CTRLSZ, cover[5], cover_f );
   mxFree( cover );
   }




/*
   void              ckgp_c( SpiceInt            inst,
                              SpiceDouble         sclkdp,
                              SpiceDouble         tol,
                              ConstSpiceChar    * ref,
                              SpiceDouble         cmat[3][3],
                              SpiceDouble       * clkout,
                              SpiceBoolean      * found      )
*/
void cspice_ckgp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * vec_cmat;
   SpiceDouble        * vec_clkout;
   SpiceBoolean       * vec_found;
   SpiceInt             inst;
   SpiceDouble          sclkdp;
   SpiceDouble          tol;
   SpiceChar            ref[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * cmat;
   SpiceDouble        * clkout;
   SpiceBoolean       * found;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",   MiceInt,     0, {0},    0},
      { "sclkdp", MiceDouble,  0, {0},    1},
      { "tol",    MiceDouble,  0, {0},    0},
      { "ref",    MiceChar,    0, {0},    0},
      { "cmat",   MiceDouble,  2, {3, 3}, 1},
      { "clkout", MiceDouble,  0, {0},    1},
      { "found",  MiceBoolean, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 3);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_sclkdp = A_DBL_ARGV(2);
   inst       = S_INT_ARGV(1);
   sclkdp     = *(vec_sclkdp);
   tol        = S_DBL_ARGV(3);

   mxGetString(prhs[4], ref, DEFAULT_STR_LENGTH);

   vec_cmat   = A_DBL_RET_ARGV(0);
   vec_clkout = A_DBL_RET_ARGV(1);
   vec_found  = A_BOOL_RET_ARGV(2);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {
         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         cmat   =  (vec_cmat   + i*extra->offset[4]);
         clkout =  (vec_clkout + i*extra->offset[5]);
         found  =  (vec_found  + i*extra->offset[6]);

         ckgp_c(inst, sclkdp, tol, ref,
                (SpiceDouble(*)[3])xr, clkout, found);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])cmat);

         }

      }
   else
      {
      cmat   = vec_cmat;
      clkout = vec_clkout;
      found  = vec_found;

      ckgp_c(inst, sclkdp, tol, ref, (SpiceDouble(*)[3])xr, clkout, found);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])cmat);

      }

   }




/*
   void              ckgpav_c( SpiceInt            inst,
                                SpiceDouble         sclkdp,
                                SpiceDouble         tol,
                                ConstSpiceChar    * ref,
                                SpiceDouble         cmat[3][3],
                                SpiceDouble         av[3],
                                SpiceDouble       * clkout,
                                SpiceBoolean      * found      )
*/
void cspice_ckgpav(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * vec_cmat;
   SpiceDouble        * vec_av;
   SpiceDouble        * vec_clkout;
   SpiceBoolean       * vec_found;
   SpiceInt             inst;
   SpiceDouble          sclkdp;
   SpiceDouble          tol;
   SpiceChar            ref[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * cmat;
   SpiceDouble        * av;
   SpiceDouble        * clkout;
   SpiceBoolean       * found;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",   MiceInt,     0, {0},    0},
      { "sclkdp", MiceDouble,  0, {0},    1},
      { "tol",    MiceDouble,  0, {0},    0},
      { "ref",    MiceChar,    0, {0},    0},
      { "cmat",   MiceDouble,  2, {3, 3}, 1},
      { "av",     MiceDouble,  1, {3},    1},
      { "clkout", MiceDouble,  0, {0},    1},
      { "found",  MiceBoolean, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 4);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   inst       = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);
   tol        = S_DBL_ARGV(3);
   mxGetString(prhs[4], ref, DEFAULT_STR_LENGTH);

   vec_cmat   = A_DBL_RET_ARGV(0);
   vec_av     = A_DBL_RET_ARGV(1);
   vec_clkout = A_DBL_RET_ARGV(2);
   vec_found  = A_BOOL_RET_ARGV(3);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         cmat   =  (vec_cmat   + i*extra->offset[4]);
         av     =  (vec_av     + i*extra->offset[5]);
         clkout =  (vec_clkout + i*extra->offset[6]);
         found  =  (vec_found  + i*extra->offset[7]);

         ckgpav_c(inst, sclkdp, tol, ref,
                  (SpiceDouble(*)[3])xr, av, clkout, found);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])cmat);
         }

      }
   else
      {

      sclkdp = *(vec_sclkdp);

      cmat   = vec_cmat;
      av     = vec_av;
      clkout = vec_clkout;
      found  = vec_found;

      ckgpav_c(inst,
               sclkdp,
               tol,
               ref,
               (SpiceDouble(*)[3])xr,
               av,
               clkout,
               found);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])cmat);
      }

   }




/*
   void              ckobj_c ( ConstSpiceChar    * ck,
                               SpiceCell         * ids );

*/
void cspice_ckobj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           ck[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_ck;

   SpiceInt            i;
   SpiceInt            j;
   int                 sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "ck",   MiceChar,   0, {0}, 1},
      { "size", MiceInt,    0, {0}, 0},
      { "ids",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_ck = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            ck[j] = (char)mx_ck[i + (extra->count*j)];
            }

         ck[extra->offset[0]] = '\0';

         ckobj_(  ( char        * ) ck,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(ck)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], ck, DEFAULT_STR_LENGTH);

      ckobj_(  ( char        * ) ck,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(ck)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );
   }




/*
   void              ckopn_c  ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  )
*/
void cspice_ckopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname[DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "ifname", MiceChar, 0, {0}, 0},
      { "ncomch", MiceInt,  0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ifname, DEFAULT_STR_LENGTH);

   ncomch = S_INT_ARGV(3);
   handle = A_INT_RET_ARGV(0);

   ckopn_c( fname, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              ckw01_c  ( SpiceInt            handle,
                                SpiceDouble         begtime,
                                SpiceDouble         endtime,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3]  );

*/
void cspice_ckw01(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtime;
   SpiceDouble          endtime;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         avflag;
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             sclkdp_size;

   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtime", MiceDouble,  0, { 0 },    0},
      { "endtime", MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "avflag",  MiceInt, 0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "sclkdp",  MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      };

   check_arg_num( nrhs, nlhs, 10, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sclkdp_size = mxGetNumberOfElements( prhs[8] );

   if( 4*sclkdp_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   if( 3*sclkdp_size != (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `aavs` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   handle  = S_INT_ARGV(1);
   begtime = S_DBL_ARGV(2);
   endtime = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref, DEFAULT_STR_LENGTH);

   avflag  = *(SpiceBoolean*)mxGetData(prhs[6]);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   sclkdp  = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);

   ckw01_c( handle,
            begtime,
            endtime,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
            (Nx4)quats,
            (Nx3)avvs);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              ckw02_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    start  [],
                                ConstSpiceDouble    stop   [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                ConstSpiceDouble    rates  []    )
*/
void cspice_ckw02(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtime;
   SpiceDouble          endtime;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             start_size;

   ConstSpiceDouble   * start;
   ConstSpiceDouble   * stop;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   ConstSpiceDouble   * rates;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtime", MiceDouble,  0, { 0 },    0},
      { "endtime", MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "start",   MiceDouble,  1, { 0 },    0},
      { "stop",    MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      { "rates",   MiceDouble,  1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   start_size = mxGetNumberOfElements( prhs[7] );

   if( start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[8] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `stop` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( 4*start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( 3*start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `aavs` must have the same "
                            "measure of vectorization as `start`" );
      }

   if( start_size !=  (SpiceInt)mxGetNumberOfElements( prhs[11] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Array `rates` must have the same "
                            "measure of vectorization as `start`" );
      }

   handle  = S_INT_ARGV(1);
   begtime = S_DBL_ARGV(2);
   endtime = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], segid, DEFAULT_STR_LENGTH);

   start   = (ConstSpiceDouble*)mxGetData(prhs[7]);
   stop    = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);
   rates   = (ConstSpiceDouble*)mxGetData(prhs[11]);

   ckw02_c( handle,
            begtime,
            endtime,
            inst,
            ref,
            segid,
            start_size,
            start,
            stop,
            (Nx4)quats,
            (Nx3)avvs,
            rates);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              ckw03_c  ( SpiceInt            handle,
                                SpiceDouble         begtim,
                                SpiceDouble         endtim,
                                SpiceInt            inst,
                                ConstSpiceChar    * ref,
                                SpiceBoolean        avflag,
                                ConstSpiceChar    * segid,
                                SpiceInt            nrec,
                                ConstSpiceDouble    sclkdp [],
                                ConstSpiceDouble    quats  [][4],
                                ConstSpiceDouble    avvs   [][3],
                                SpiceInt            nints,
                                ConstSpiceDouble    starts []     );
*/
void cspice_ckw03(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceDouble          begtime;
   SpiceDouble          endtime;
   SpiceInt             inst;
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceBoolean         avflag;
   SpiceChar            segid [DEFAULT_STR_LENGTH+1];
   SpiceInt             sclkdp_size;
   SpiceInt             nints;

   ConstSpiceDouble   * sclkdp;
   ConstSpiceDouble   * quats;
   ConstSpiceDouble   * avvs;
   ConstSpiceDouble   * starts;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,     0, { 0 },    0},
      { "begtime", MiceDouble,  0, { 0 },    0},
      { "endtime", MiceDouble,  0, { 0 },    0},
      { "inst",    MiceInt,     0, { 0 },    0},
      { "ref",     MiceChar,    0, { 0 },    0},
      { "avflag",  MiceInt, 0, { 0 },    0},
      { "segid",   MiceChar,    0, { 0 },    0},
      { "sclkdp",  MiceDouble,  1, { 0 },    0},
      { "quats",   MiceDouble,  2, { 4, 0 }, 0},
      { "avvs",    MiceDouble,  2, { 3, 0 }, 0},
      { "starts",  MiceDouble,  1, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sclkdp_size = mxGetNumberOfElements( prhs[8] );
   nints       = mxGetNumberOfElements( prhs[11]);

   if( 4*sclkdp_size !=  (SpiceInt)mxGetNumberOfElements( prhs[9] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `quats` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }

   if( 3*sclkdp_size != (SpiceInt)mxGetNumberOfElements( prhs[10] ) )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Matrix `aavs` must have the same "
                            "measure of vectorization as `sclkdp`" );
      }


   handle  = S_INT_ARGV(1);
   begtime = S_DBL_ARGV(2);
   endtime = S_DBL_ARGV(3);
   inst    = S_INT_ARGV(4);

   mxGetString(prhs[5], ref, DEFAULT_STR_LENGTH);

   avflag  = *(SpiceBoolean*)mxGetData(prhs[6]);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   sclkdp  = (ConstSpiceDouble*)mxGetData(prhs[8]);
   quats   = (ConstSpiceDouble*)mxGetData(prhs[9]);
   avvs    = (ConstSpiceDouble*)mxGetData(prhs[10]);
   starts  = (ConstSpiceDouble*)mxGetData(prhs[11]);

   ckw03_c( handle,
            begtime,
            endtime,
            inst,
            ref,
            avflag,
            segid,
            sclkdp_size,
            sclkdp,
            (Nx4)quats,
            (Nx3)avvs,
            nints,
            starts);

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   SpiceDouble              clight_c( void )
*/
void cspice_clight(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( clight_c() );
   }




/*
   void              clpool_c( void )
*/
void cspice_clpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 0 );

   /*
   Not much to do, make the call.
   */
   clpool_c();
   }




/*
   void              cnmfrm_c ( ConstSpiceChar    * cname,
                                SpiceInt            lenout,
                                SpiceInt          * frcode,
                                SpiceChar         * frname,
                                SpiceBoolean      * found   );
*/
void mice_cnmfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            cname[DEFAULT_STR_LENGTH+1];
   SpiceChar            frname[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_cname;
   SpiceInt             frcode;
   SpiceBoolean         found;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "cname",  MiceChar,   0, {0}, 1},
      { "cnmfrm", MiceNameID, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {
      mx_cname = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            cname[j] = (SpiceChar)mx_cname[i + (extra->count*j)];
            }

         cname[extra->offset[0]] = '\0';

         cnmfrm_c ( cname,
                    DEFAULT_STR_LENGTH,
                    &frcode,
                    frname,
                    &found   );
         CHECK_CALL_FAILURE(i);

          mxDestroyArray( mxGetField( plhs[0], i, "frname" ) );
          if ( found )
             {
             mxSetField( plhs[0], i, "name", mxCreateString(frname) );
             }
          else
             {
             mxSetField( plhs[0], i, "name", mxCreateString("\0") );
             frcode = 0;
             }

          mxDestroyArray( mxGetField( plhs[0], i,"code" ) );
          mxSetField( plhs[0], i,"code", zzmice_CreateIntScalar(frcode) );

          mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
          mxSetField( plhs[0], i, "found",
                          mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], cname, DEFAULT_STR_LENGTH);

      cnmfrm_c ( cname,
                 DEFAULT_STR_LENGTH,
                 &frcode,
                 frname,
                 &found   );
      CHECK_CALL_FAILURE(SCALAR);

      mxDestroyArray( mxGetField( plhs[0], 0, "name" ) );
      if ( found )
         {
         mxSetField(plhs[0], 0, "name", mxCreateString(frname)   );
         }
      else
         {
         mxSetField( plhs[0], 0, "name",  mxCreateString("\0") );
         frcode = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0,"code" ) );
      mxSetField( plhs[0], 0,"code", zzmice_CreateIntScalar(frcode));

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              conics_c( ConstSpiceDouble  elts[8],
                                SpiceDouble       et,
                                SpiceDouble       state[6] )
*/
void cspice_conics(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_elts;
   SpiceDouble        * vec_et;
   SpiceDouble        * vec_state;
   SpiceDouble        * elts;
   SpiceDouble          et;
   SpiceDouble        * state;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "elts",  MiceDouble, 1, {8}, 1},
      { "et",    MiceDouble, 0, {0}, 1},
      { "state", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_elts  = A_DBL_ARGV(1);
   vec_et    = A_DBL_ARGV(2);
   vec_state = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         elts  =  (vec_elts  + i*extra->offset[0]);
         et    = *(vec_et    + i*extra->offset[1]);
         state =  (vec_state + i*extra->offset[2]);

         conics_c(elts, et, state);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      elts  =  vec_elts;
      et    = *vec_et;
      state =  vec_state;

      conics_c(elts, et, state);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              convrt_c ( SpiceDouble         x,
                                ConstSpiceChar    * in,
                                ConstSpiceChar    * out,
                                SpiceDouble       * y    );
*/
void cspice_convrt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           in[DEFAULT_STR_LENGTH+1];
   SpiceChar           out[DEFAULT_STR_LENGTH+1];
   SpiceDouble         x;
   SpiceDouble       * vec_x;
   SpiceDouble       * y;
   SpiceDouble       * vec_y;

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "x",   MiceDouble, 0, {0}, 1},
      { "in",  MiceChar,   0, {0}, 0},
      { "out", MiceChar,   0, {0}, 0},
      { "y",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x = A_DBL_ARGV(1);

   mxGetString(prhs[2], in,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], out, DEFAULT_STR_LENGTH);

   vec_y = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         x = *(vec_x + i*extra->offset[0]);
         y =  (vec_y + i*extra->offset[3]);

         convrt_c( x, in, out, y);
         CHECK_CALL_FAILURE(i);
         }


      }
   else
      {
      x = *vec_x;
      y =  vec_y;

      convrt_c( x, in, out, y);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              cyllat_c( SpiceDouble    r,
                                SpiceDouble    lonc,
                                SpiceDouble    z,
                                SpiceDouble *  radius,
                                SpiceDouble *  lon,
                                SpiceDouble *  lat )
*/
void cspice_cyllat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lonc;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble          r;
   SpiceDouble          lonc;
   SpiceDouble          z;
   SpiceDouble        * radius;
   SpiceDouble        * lon;
   SpiceDouble        * lat;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "lonc",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lonc   = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_lat    = A_DBL_RET_ARGV(2);
   r          = *vec_r;
   lonc       = *vec_lonc;
   z          = *vec_z;
   radius     =  vec_radius;
   lon        =  vec_lon;
   lat        =  vec_lat;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         lonc   = *(vec_lonc   + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);

         cyllat_c(r, lonc, z, radius, lon, lat);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cyllat_c(r, lonc, z, radius, lon, lat);
      CHECK_CALL_FAILURE(SCALAR); ;
      }

   }




/*
   void              cylrec_c( SpiceDouble r,
                               SpiceDouble lon,
                               SpiceDouble z,
                               SpiceDouble rectan[3] )
*/
void cspice_cylrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_rectan;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          z;
   SpiceDouble        * rectan;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   r          = *(vec_r);
   lon        = *(vec_lon);
   z          = *(vec_z);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         lon    = *(vec_lon    + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         cylrec_c(r, lon, z, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cylrec_c(r, lon, z, rectan);
      CHECK_CALL_FAILURE(SCALAR); ;
      }

   }




/*
   void              cylsph_c( SpiceDouble    r,
                               SpiceDouble    lonc,
                               SpiceDouble    z,
                               SpiceDouble *  radius,
                               SpiceDouble *  colat,
                               SpiceDouble *  lon )
*/
void cspice_cylsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lonc;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_lon;
   SpiceDouble          r;
   SpiceDouble          lonc;
   SpiceDouble          z;
   SpiceDouble        * radius;
   SpiceDouble        * colat;
   SpiceDouble        * lon;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "lonc",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lonc   = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_colat  = A_DBL_RET_ARGV(1);
   vec_lon    = A_DBL_RET_ARGV(2);
   r          = *vec_r;
   lonc       = *vec_lonc;
   z          = *vec_z;
   radius     = vec_radius;
   colat      = vec_colat;
   lon        = vec_lon;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r      = *(vec_r      + i*extra->offset[0]);
         lonc   = *(vec_lonc   + i*extra->offset[1]);
         z      = *(vec_z      + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         colat  =  (vec_colat  + i*extra->offset[4]);
         lon    =  (vec_lon    + i*extra->offset[5]);

         cylsph_c(r, lonc, z, radius, colat, lon);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      cylsph_c(r, lonc, z, radius, colat, lon);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dafac_c  ( SpiceInt            handle,
                                SpiceInt            n,
                                SpiceInt            lenvals,
                                const void        * buffer  );
*/
void cspice_dafac(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceChar          * str;
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   SpiceInt             i;
   SpiceInt             j;
   SpiceInt             count;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,  0, {0}, 0},
      { "buffer", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   mx_str = (mxChar *)mxGetChars(prhs[2]);

   /*
   The following logic differs slightly from other string input arguments.
   A dafac_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (Is this a bug or design failure? EDW)

   Equivalent to mxGetM(prhs[2]).
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   cvals_len  = extra->offset[1] + 1;
   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );
   CHECK_CALL_FAILURE( SCALAR );

   str = mxCalloc(cvals_len, sizeof(char));

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   dafac_c ( handle, cvals_size, cvals_len, * cvals );
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;

   }





/*
   void              dafbbs_c ( SpiceInt            handle )
*/
void cspice_dafbbs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafbbs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafbfs_c ( SpiceInt            handle )
*/
void cspice_dafbfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafbfs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafcls_c ( SpiceInt            handle )
*/
void cspice_dafcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafcs_c  ( SpiceInt            handle )
*/
void cspice_dafcs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafcs_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafdc_c  ( SpiceInt            handle )
*/
void cspice_dafdc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   dafdc_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafec_c  ( SpiceInt            handle,
                                SpiceInt            bufsiz,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * buffer,
                                SpiceBoolean      * done    );
*/
void cspice_dafec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             bufsiz;
   SpiceInt             lenout;
   SpiceInt             n = 0;
   SpiceChar         ** cvals;
   SpiceChar         ** array;
   SpiceBoolean         done = SPICETRUE;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,    0, {0}, 0},
      { "bufsiz", MiceInt,    0, {0}, 0},
      { "lenout", MiceInt,    0, {0}, 0},
      { "buffer", MiceIgnore, 0, {0}, 0},
      { "done",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   bufsiz = S_INT_ARGV(2);
   lenout = S_INT_ARGV(3);

   cvals  = (SpiceChar**)alloc_SpiceString_C_array( lenout, bufsiz );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(bufsiz);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   dafec_c ( handle, bufsiz, lenout, &n, * cvals, &done );
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   if ( n > 0 )
      {
      for (i=0;i<n;i++)
         {

         /*
         Copy the ith string pointer to the array of pointers for input
         to the mx call.
         */
         array[i] = *cvals + i*lenout;
         }

      /*
      I think this functions as a copy, creating needed memory to 'plhs'.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   plhs[1] = zzmice_CreateIntScalar(done);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              daffna_c ( SpiceBoolean      * found )
*/
void cspice_daffna(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean       found;

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value.
   */
   daffna_c ( &found );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateDoubleScalar( found );

   }




/*
   void              daffpa_c ( SpiceBoolean      * found )
*/
void cspice_daffpa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceBoolean       found;

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value.
   */
   daffpa_c ( &found );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateDoubleScalar( found );

   }




/*
   void              dafgda_c ( SpiceInt            handle,
                                SpiceInt            begin,
                                SpiceInt            end,
                                SpiceDouble       * data );
*/
void cspice_dafgda(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             begin;
   SpiceInt             end;
   SpiceDouble        * data;

   SpiceInt             size;
   SpiceDouble        * dvals_ret;
   int                  sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,     0, {0}, 0},
      { "begin",  MiceInt,     0, {0}, 0},
      { "end",    MiceInt,     0, {0}, 0},
      { "data",   MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   begin  = S_INT_ARGV(2);
   end    = S_INT_ARGV(3);
   size   = end - begin + 1;

   data = (SpiceDouble*)mxMalloc(size * sizeof(SpiceDouble) );
   memset( data, 0, size * sizeof(SpiceDouble) );

   dafgda_c( handle, begin, end, data);

   /*
   Check for a failure signal. Free the memory assigned to 'data'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( data );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Define the size and shape of the Matlab return argument.
   */
   sizearray[0] = 1;
   sizearray[1] = size;

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( data, size, dvals_ret );
   mxFree( data );

   }




/*
   void              dafgn_c  ( SpiceInt            lenout,
                                SpiceChar         * name   )
*/
void cspice_dafgn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [DEFAULT_STR_LENGTH+1];

   /*
   Very simple interface. No need to allocate memory. Use
   the default string length as 'lenout'.
   */
   check_arg_num( nrhs, nlhs, 0, 1 );

   dafgn_c ( DEFAULT_STR_LENGTH, name);

   plhs[0] = mxCreateString( name );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_dafgn" );
      }

   }




/*
   void              dafgs_c  ( SpiceDouble         sum[] )

   void              dafus_c  ( ConstSpiceDouble    sum [],
                                SpiceInt            nd,
                                SpiceInt            ni,
                                SpiceDouble         dc  [],
                                SpiceInt            ic  []  )
*/
void cspice_dafgs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          sum [MAXSUM];
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble          dc  [MAXNDC];
   SpiceInt             ic  [MAXNIC];

   SpiceDouble        * dvals_ret;
   SpiceInt           * ivals_ret;
   int                  sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "nd", MiceInt,     0, {0}, 0},
      { "ni", MiceInt,     0, {0}, 0},
      { "dc", MiceIgnore,  0, {0}, 0},
      { "ic", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   nd   = S_INT_ARGV(1);
   ni   = S_INT_ARGV(2);

   /*
   Let's not do anything fancy. Make the calls using explicitly
   sized args.
   */
   dafgs_c( sum );
   dafus_c( sum, nd, ni, dc, ic );

   CHECK_CALL_FAILURE(SCALAR);

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNDC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( nd < MAXNDC ? nd: MAXNDC);

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( dc, nd, dvals_ret );

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNIC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( ni < MAXNIC ? ni: MAXNIC);

   plhs[1]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(1);

   MOVEI( ic, ni, ivals_ret );

   }




/*
   void              dafopr_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
void cspice_dafopr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(0);

   dafopr_c( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafopw_c ( ConstSpiceChar    * fname,
                                SpiceInt          * handle  )
*/
void cspice_dafopw(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(0);

   dafopw_c( fname, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              dafus_c  ( ConstSpiceDouble    sum [],
                                SpiceInt            nd,
                                SpiceInt            ni,
                                SpiceDouble         dc  [],
                                SpiceInt            ic  []  )
*/
void cspice_dafus(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * sum;
   SpiceInt             nd;
   SpiceInt             ni;
   SpiceDouble          dc  [MAXNDC];
   SpiceInt             ic  [MAXNIC];

   SpiceDouble        * dvals_ret;
   SpiceInt           * ivals_ret;
   SpiceInt             sum_size;
   int                  sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sum", MiceDouble, 1, {0}, 0},
      { "nd",  MiceInt,    0, {0}, 0},
      { "ni",  MiceInt,    0, {0}, 0},
      { "dc",  MiceIgnore, 0, {0}, 0},
      { "ic",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sum      = (SpiceDouble*)mxGetData(prhs[1]);
   sum_size = mxGetNumberOfElements( prhs[1] );

   /* Check dimensions of input arrays */
   if ( sum_size > MAXSUM )
      {
      mexErrMsgTxt( "MICE(INVALIDSIZE): Size of summary array "
                    "`sum` exceeds MAXSUM.");
      }

   nd   = S_INT_ARGV(2);
   ni   = S_INT_ARGV(3);

   /*
   Let's not do anything fancy. Make the calls using explicitly
   sized args.
   */
   dafus_c( sum, nd, ni, dc, ic );

   CHECK_CALL_FAILURE(SCALAR);

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNDC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( nd < MAXNDC ? nd: MAXNDC);

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   MOVED( dc, nd, dvals_ret );

   /*
   Define the size and shape of the Matlab return argument. The
   number of elements should not exceed MAXNIC. Enforce with the
   conditional operator.
   */
   sizearray[0] = 1;
   sizearray[1] = ( ni < MAXNIC ? ni: MAXNIC);

   plhs[1]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(1);

   MOVEI( ic, ni, ivals_ret );

   }

   
   
   
/*
   void              dcyldr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dcyldr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x   = *(vec_x + i*extra->offset[0]);
         y   = *(vec_y + i*extra->offset[1]);
         z   = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dcyldr_c(x, y, z, (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dcyldr_c(x, y, z, (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              deltet_c( SpiceDouble      epoch,
                               ConstSpiceChar * eptype,
                               SpiceDouble    * delta )
*/
void cspice_deltet(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_epoch;
   SpiceDouble          epoch;
   SpiceChar            eptype[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_delta;
   SpiceDouble        * delta;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "epoch",  MiceDouble, 0, {0}, 1},
      { "eptype", MiceChar,   0, {0}, 0},
      { "delta",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], eptype, DEFAULT_STR_LENGTH);

   vec_epoch = A_DBL_ARGV(1);
   vec_delta = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         epoch = *(vec_epoch+i*extra->offset[0]);
         delta = vec_delta + i*extra->offset[2];

         deltet_c( epoch, eptype, delta );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      epoch = *vec_epoch;
      delta = vec_delta;

      deltet_c( epoch, eptype, delta );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dgeodr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dgeodr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x    = A_DBL_ARGV(1);
   vec_y    = A_DBL_ARGV(2);
   vec_z    = A_DBL_ARGV(3);
   x        = *(vec_x);
   y        = *(vec_y);
   z        = *(vec_z);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x      = *(vec_x     + i*extra->offset[0]);
         y      = *(vec_y     + i*extra->offset[1]);
         z      = *(vec_z     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[5]);

         dgeodr_c(x, y, z, re, f, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dgeodr_c(x, y, z, re, f, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dlatdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] );
*/
void cspice_dlatdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x      = *(vec_x + i*extra->offset[0]);
         y      = *(vec_y + i*extra->offset[1]);
         z      = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dlatdr_c(x, y, z, (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dlatdr_c(x, y, z, (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dpgrdr_c ( ConstSpiceChar    * body,
                                SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_dpgrdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0},    0},
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );

   vec_x      = A_DBL_ARGV(2);
   vec_y      = A_DBL_ARGV(3);
   vec_z      = A_DBL_ARGV(4);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_jacobi = A_DBL_RET_ARGV(0);

   x          = *(vec_x);
   y          = *(vec_y);
   z          = *(vec_z);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x    = *(vec_x     + i*extra->offset[1]);
         y    = *(vec_y     + i*extra->offset[2]);
         z    = *(vec_z     + i*extra->offset[3]);
         jacobi = (vec_jacobi + i*extra->offset[6]);

         dpgrdr_c( body, x, y, z, re, f, (SpiceDouble (*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dpgrdr_c( body, x, y, z, re, f, (SpiceDouble (*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   SpiceDouble              dpr_c( void )
*/
void cspice_dpr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( dpr_c() );
   }




/*
   void              drdcyl_c ( SpiceDouble    r,
                                SpiceDouble    lon,
                                SpiceDouble    z,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "lon",    MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r   = A_DBL_ARGV(1);
   vec_lon = A_DBL_ARGV(2);
   vec_z   = A_DBL_ARGV(3);
   r       = *vec_r;
   lon     = *vec_lon;
   z       = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r     + i*extra->offset[0]);
         lon    = *(vec_lon   + i*extra->offset[1]);
         z      = *(vec_z     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdcyl_c(r, lon, z, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdcyl_c(r, lon, z, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdgeo_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_drdgeo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "alt",    MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_lon    = A_DBL_ARGV(1);
   vec_lat    = A_DBL_ARGV(2);
   vec_alt    = A_DBL_ARGV(3);
   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         lon    = *(vec_lon     + i*extra->offset[0]);
         lat    = *(vec_lat     + i*extra->offset[1]);
         alt    = *(vec_alt     + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[5]);

         drdgeo_c(lon, lat, alt, re, f, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdgeo_c(lon, lat, alt, re, f, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdlat_c ( SpiceDouble    r,
                                SpiceDouble    lon,
                                SpiceDouble    lat,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdlat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   r          = *vec_r;
   lon        = *vec_lon;
   lat        = *vec_lat;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r     = *(vec_r + i*extra->offset[0]);
         lon   = *(vec_lon + i*extra->offset[1]);
         lat   = *(vec_lat + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdlat_c(r, lon, lat, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdlat_c(r, lon, lat, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdpgr_c ( ConstSpiceChar    * body,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         jacobi[3][3] )
*/
void cspice_drdpgr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0},    0},
      { "lon",    MiceDouble, 0, {0},    1},
      { "lat",    MiceDouble, 0, {0},    1},
      { "alt",    MiceDouble, 0, {0},    1},
      { "re",     MiceDouble, 0, {0},    0},
      { "f",      MiceDouble, 0, {0},    0},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );

   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_alt    = A_DBL_ARGV(4);
   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         lon    = *(vec_lon     + i*extra->offset[1]);
         lat    = *(vec_lat     + i*extra->offset[2]);
         alt    = *(vec_alt     + i*extra->offset[3]);
         jacobi = (vec_jacobi + i*extra->offset[6]);

         drdpgr_c( body, lon, lat, alt, re, f, (SpiceDouble (*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdpgr_c( body, lon, lat, alt, re, f, (SpiceDouble (*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              drdsph_c ( SpiceDouble    r,
                                SpiceDouble    colat,
                                SpiceDouble    lon,
                                SpiceDouble    jacobi[3][3] )
*/
void cspice_drdsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          r;
   SpiceDouble          colat;
   SpiceDouble          lon;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0},    1},
      { "colat",  MiceDouble, 0, {0},    1},
      { "lon",    MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_lon    = A_DBL_ARGV(3);
   r          = *vec_r;
   colat      = *vec_colat;
   lon        = *vec_lon;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r     + i*extra->offset[0]);
         colat  = *(vec_colat + i*extra->offset[1]);
         lon    = *(vec_lon   + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         drdsph_c(r, colat, lon, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      drdsph_c(r, colat, lon, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dsphdr_c ( SpiceDouble         x,
                                SpiceDouble         y,
                                SpiceDouble         z,
                                SpiceDouble         jacobi[3][3] );
*/
void cspice_dsphdr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_x;
   SpiceDouble        * vec_y;
   SpiceDouble        * vec_z;
   SpiceDouble        * vec_jacobi;
   SpiceDouble          x;
   SpiceDouble          y;
   SpiceDouble          z;
   SpiceDouble        * jacobi;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "x",      MiceDouble, 0, {0},    1},
      { "y",      MiceDouble, 0, {0},    1},
      { "z",      MiceDouble, 0, {0},    1},
      { "jacobi", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_x      = A_DBL_ARGV(1);
   vec_y      = A_DBL_ARGV(2);
   vec_z      = A_DBL_ARGV(3);
   x          = *vec_x;
   y          = *vec_y;
   z          = *vec_z;
   vec_jacobi = A_DBL_RET_ARGV(0);
   jacobi     = vec_jacobi;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         x   = *(vec_x + i*extra->offset[0]);
         y   = *(vec_y + i*extra->offset[1]);
         z   = *(vec_z + i*extra->offset[2]);
         jacobi = (vec_jacobi + i*extra->offset[3]);

         dsphdr_c(x, y, z, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])jacobi );
         }

      }
   else
      {
      dsphdr_c(x, y, z, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])jacobi );
      }

   }




/*
   void              dtpool_c ( ConstSpiceChar      * name,
                                SpiceBoolean        * found,
                                SpiceInt            * n,
                                SpiceChar             type [1] )
*/
void mice_dtpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar               name[DEFAULT_STR_LENGTH+1];
   mxChar                * mx_name;
   SpiceBoolean            found;
   SpiceInt                n;
   SpiceDouble             xn;
   SpiceChar               type;
   SpiceChar               type_buf[2];

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, { 0 }, 1},
      { "value", MicePool, 0, { 0 }, 1},
      };

   /* Check the input contains the correct number of arguments. */
   check_arg_num( nrhs, nlhs, 1, 1 );

   /*
   Perform the input argument type checks, allocate any needed
   memory for output args, copy the argument vector to a work copy.
   */
   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {
      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_name array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (SpiceChar)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         dtpool_c( name, &found, &n, &type);
         CHECK_CALL_FAILURE(i);

         /* We return a string to MATLAB, so copy the char to a string. */
         type_buf[0] = type;
         type_buf[1] = '\0';

         /*
         Cast the number of found items to a double value.
         */
         xn = (SpiceDouble) n;

         mxDestroyArray( mxGetField( plhs[0], i, "type" ) );
         mxSetField( plhs[0], i, "type", mxCreateString(type_buf)  );

         mxDestroyArray( mxGetField( plhs[0], i, "n" ) );
         mxSetField( plhs[0], i, "n", mxCreateDoubleScalar(xn) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      dtpool_c( name, &found, &n, &type);
      CHECK_CALL_FAILURE( SCALAR );

      /* We return a string to MATLAB, so copy the char to a string. */
      type_buf[0] = type;
      type_buf[1] = '\0';

      /*
      Cast the number of found items to a double value.
      */
      xn = (SpiceDouble) n;

      mxDestroyArray( mxGetField( plhs[0], 0, "type" ) );
      mxSetField( plhs[0], 0, "type", mxCreateString(type_buf) );

      mxDestroyArray( mxGetField( plhs[0], 0, "n" ) );
      mxSetField( plhs[0], 0, "n", mxCreateDoubleScalar(xn) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              ducrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
void cspice_ducrss(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",     MiceDouble, 1, {6}, 1},
      { "s2",     MiceDouble, 1, {6}, 1},
      { "ducrss", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         ducrss_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      ducrss_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvcrss_c ( ConstSpiceDouble s1  [6],
                                ConstSpiceDouble s2  [6],
                                SpiceDouble      sout[6] )
*/
void cspice_dvcrss(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",     MiceDouble, 1, {6}, 1},
      { "s2",     MiceDouble, 1, {6}, 1},
      { "dvcrss", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         dvcrss_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      dvcrss_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       dvdot_c  ( ConstSpiceDouble      s1[6],
                                ConstSpiceDouble      s2[6] )
*/
void cspice_dvdot(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",    MiceDouble, 1, {6}, 1},
      { "s2",    MiceDouble, 1, {6}, 1},
      { "dvdot", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_s2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         s2     = (vec_s2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = dvdot_c(s1, s2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      s2     = vec_s2;
      retval = vec_retval;

      *retval = dvdot_c(s1, s2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvhat_c  ( ConstSpiceDouble      s1  [6],
                                SpiceDouble           sout[6] )
*/
void cspice_dvhat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "s1",   MiceDouble, 1, {6}, 1},
      { "vout", MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         s1   =  (vec_s1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);

         dvhat_c(s1, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      s1   =  vec_s1;
      vout =  vec_vout;

      dvhat_c( s1, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       dvnorm_c ( ConstSpiceDouble     state[6] )
*/
void cspice_dvnorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * s1;
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",     MiceDouble, 1, {6}, 1},
      { "dvnorm", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         retval = (vec_retval + i*extra->offset[1]);

         *retval = dvnorm_c( s1 );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      retval = vec_retval;

      *retval = dvnorm_c( s1 );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              dvpool_c ( ConstSpiceChar      * name );
*/
void cspice_dvpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           name[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_name;

   SpiceInt            i;
   SpiceInt            j;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "name", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {

      mx_name = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The 'mx_name' array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            name[j] = (char)mx_name[i + (extra->count*j)];
            }

         name[extra->offset[0]] = '\0';

         dvpool_c(name);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      mxGetString(prhs[1], name, DEFAULT_STR_LENGTH);

      dvpool_c(name);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble      dvsep_c   ( ConstSpiceDouble    s1[6],
                                ConstSpiceDouble    s2[6] )
*/
void cspice_dvsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "s1",    MiceDouble, 1, {6}, 1},
      { "s2",    MiceDouble, 1, {6}, 1},
      { "dvsep", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1     = A_DBL_ARGV(1);
   vec_s2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1     = (vec_s1     + i*extra->offset[0]);
         s2     = (vec_s2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = dvsep_c(s1, s2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1     = vec_s1;
      s2     = vec_s2;
      retval = vec_retval;

      *retval = dvsep_c(s1, s2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              edlimb_c ( SpiceDouble           a,
                                SpiceDouble           b,
                                SpiceDouble           c,
                                ConstSpiceDouble      viewpt[3],
                                SpiceEllipse        * limb      );
*/
void mice_edlimb(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * viewpt;
   SpiceEllipse         limb;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble,  0, {0}, 0},
      { "b",      MiceDouble,  0, {0}, 0},
      { "c",      MiceDouble,  0, {0}, 0},
      { "viewpt", MiceDouble,  1, {3}, 0},
      { "limb",   MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a      = S_DBL_ARGV(1);
   b      = S_DBL_ARGV(2);
   c      = S_DBL_ARGV(3);
   viewpt = A_DBL_ARGV(4);

   edlimb_c ( a, b, c, viewpt, &limb );
   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           limb.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           limb.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           limb.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              edterm_c ( ConstSpiceChar      * trmtyp,
                                ConstSpiceChar      * source,
                                ConstSpiceChar      * target,
                                SpiceDouble           et,
                                ConstSpiceChar      * fixfrm,
                                ConstSpiceChar      * abcorr,
                                ConstSpiceChar      * obsrvr,
                                SpiceInt              npts,
                                SpiceDouble         * trgepc,
                                SpiceDouble           obspos  [3],
                                SpiceDouble           termpts [ ][3] );
*/
void cspice_edterm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             trmtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar             source[DEFAULT_STR_LENGTH+1];
   SpiceChar             target[DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             fixfrm[DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceInt              npts;
   SpiceDouble           trgepc;
   SpiceDouble         * obspos;
   SpiceDouble         * termpts;

   int                  sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trmtyp",  MiceChar,   0, {0}, 0},
      { "source",  MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "et",      MiceDouble, 0, {0}, 0},
      { "fixfrm",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "npts",    MiceInt,    0, {0}, 0},
      { "trgepc",  MiceIgnore, 0, {0}, 0},
      { "obspos",  MiceDouble, 1, {3}, 0},
      { "termpts", MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 8, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], trmtyp,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], source,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target,  DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(4);

   mxGetString(prhs[5], fixfrm,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr,  DEFAULT_STR_LENGTH);

   npts    = S_INT_ARGV(8);

   obspos  = A_DBL_RET_ARGV(1);

   /*
   Allocate the memory for the output argument 'termpts'. Zero-out
   'termpts'.
   */
   sizearray[0] = 3;
   sizearray[1] = npts;

   plhs[2] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   termpts = A_DBL_RET_ARGV(2);

   memset( termpts,  0, npts * 3 * sizeof(SpiceDouble) );

   /*
   Call the C wrapper.
   */
   edterm_c ( trmtyp,
              source,
              target,
              et,
              fixfrm,
              abcorr,
              obsrvr,
              npts,
              &trgepc,
              obspos,
              (SpiceDouble (*)[3])termpts);

   plhs[0] = mxCreateDoubleScalar( trgepc );

   }




/*
   void              ekfind_c ( ConstSpiceChar    * query,
                                SpiceInt            lenout,
                                SpiceInt          * nmrows,
                                SpiceBoolean      * error,
                                SpiceChar         * errmsg )
*/
void cspice_ekfind(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           query  [DEFAULT_STR_LENGTH+1];
   SpiceInt            nmrows;
   SpiceBoolean        error;
   SpiceChar           errmsg [DEFAULT_STR_LENGTH+1];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "query",  MiceChar,    0, {0}, 0},
      { "nmrows", MiceInt,     0, {0}, 0},
      { "error",  MiceBoolean, 0, {0}, 0},
      { "errmsg", MiceChar,    0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   memset( errmsg, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], query, DEFAULT_STR_LENGTH);

   ekfind_c( query,
             DEFAULT_STR_LENGTH,
             &nmrows,
             &error,
             errmsg);

   CHECK_CALL_FAILURE(SCALAR);

   plhs[1] = zzmice_CreateIntScalar(error);

   if ( error )
      {
      plhs[0] = zzmice_CreateIntScalar(0);
      plhs[2] = mxCreateString( errmsg );
      }
   else
      {
      plhs[0] = zzmice_CreateIntScalar(nmrows);
      plhs[2] = mxCreateString( "\0" );
      }

   if ( plhs[2] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_ekfind" );
      }

   }




/*
   void              ekgc_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt            lenout,
                                SpiceChar         * cdata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              lenout;
   SpiceChar             cdata [DEFAULT_STR_LENGTH+1];
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "lenout", MiceInt,    0, { 0 },    0},
      { "cdata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;
   lenout = S_INT_ARGV(4);

   ekgc_c( selidx, row, elment, lenout, cdata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Return 'cdata' if 'found' returns as SPICETRUE, otherwise return
   a null string.
   */
   if ( found )
      {
      plhs[0] = mxCreateString( cdata );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_ekgc" );
      }

   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   void              ekgd_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceDouble       * ddata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceDouble           ddata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "ddata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;

   ekgd_c( selidx, row, elment, &ddata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateDoubleScalar(ddata);
   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   void              ekgi_c   ( SpiceInt            selidx,
                                SpiceInt            row,
                                SpiceInt            elment,
                                SpiceInt          * idata,
                                SpiceBoolean      * null,
                                SpiceBoolean      * found  )
*/
void cspice_ekgi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              selidx;
   SpiceInt              row;
   SpiceInt              elment;
   SpiceInt              idata;
   SpiceBoolean          null;
   SpiceBoolean          found;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, { 0 },    0},
      { "row",    MiceInt,    0, { 0 },    0},
      { "elment", MiceInt,    0, { 0 },    0},
      { "idata",  MiceIgnore, 0, { 0 },    0},
      { "null",   MiceIgnore, 0, { 0 },    0},
      { "found",  MiceIgnore, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Retrieve the values of the input arguments. MATLAB uses a base 1 array
   index convention, as is proper, C does not, which is weird. Subtract one
   off the 'selidx', 'row', and 'elment' indices.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;
   elment = S_INT_ARGV(3) - 1;

   ekgi_c( selidx, row, elment, &idata, &null, &found);
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar(idata);
   plhs[1] = zzmice_CreateIntScalar(null);
   plhs[2] = zzmice_CreateIntScalar(found);

   }




/*
   SpiceInt          eknelt_c ( SpiceInt            selidx,
                                SpiceInt            row     );
*/
void cspice_eknelt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            selidx;
   SpiceInt            row;
   SpiceInt            nelt;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "selidx", MiceInt,    0, {0}, 0},
      { "row",    MiceInt,    0, {0}, 0},
      { "nelt",   MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off 'selidx' and 'row'.
   */
   selidx = S_INT_ARGV(1) - 1;
   row    = S_INT_ARGV(2) - 1;

   nelt = eknelt_c ( selidx, row );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = zzmice_CreateIntScalar(nelt);
   }




/*
   void              el2cgv_c ( ConstSpiceEllipse * ellipse,
                                SpiceDouble         center[3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  );
*/
void cspice_el2cgv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse         ellipse;
   SpiceDouble        * center;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ellipse", MiceEllipse, 0, {0}, 0},
      { "center",  MiceDouble,  1, {3}, 0},
      { "smajor",  MiceDouble,  1, {3}, 0},
      { "sminor",  MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   center = A_DBL_RET_ARGV(0);
   smajor = A_DBL_RET_ARGV(1);
   sminor = A_DBL_RET_ARGV(2);

   memcpy( ellipse.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellipse.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellipse.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );

   el2cgv_c ( &ellipse, center, smajor, sminor );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              etcal_c  ( SpiceDouble         et,
                                SpiceInt            lenout,
                                SpiceChar         * string  );
*/
void cspice_etcal(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           string[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceDouble         et;
   SpiceDouble       * vec_et;

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "string", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( string, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         etcal_c( et, DEFAULT_STR_LENGTH, array[i] );
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {
      et = *(vec_et);

      etcal_c( et, DEFAULT_STR_LENGTH, string  );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( string );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_etcal" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }





/*
   void              et2lst_c ( SpiceDouble         et,
                                SpiceInt            body,
                                SpiceDouble         lon,
                                ConstSpiceChar    * type,
                                SpiceInt            timlen,
                                SpiceInt            ampmlen,
                                SpiceInt          * hr,
                                SpiceInt          * mn,
                                SpiceInt          * sc,
                                SpiceChar         * time,
                                SpiceChar         * ampm    );

*/
void cspice_et2lst(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceInt             body;
   SpiceDouble          lon;
   SpiceChar            type [DEFAULT_STR_LENGTH+1];
   SpiceInt           * hr;
   SpiceInt           * vec_hr;
   SpiceInt           * min;
   SpiceInt           * vec_min;
   SpiceInt           * sec;
   SpiceInt           * vec_sec;
   SpiceChar            time [DEFAULT_STR_LENGTH+1];
   SpiceChar            ampm [DEFAULT_STR_LENGTH+1];
   SpiceChar         ** time_cval;
   SpiceChar         ** time_array;
   SpiceChar         ** ampm_cval;
   SpiceChar         ** ampm_array;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",   MiceDouble, 0, {0}, 1},
      { "body", MiceInt,    0, {0}, 0},
      { "lon",  MiceDouble, 0, {0}, 0},
      { "type", MiceChar,   0, {0}, 0},
      { "hr",   MiceInt,    0, {0}, 1},
      { "min",  MiceInt,    0, {0}, 1},
      { "sec",  MiceInt,    0, {0}, 1},
      { "time", MiceChar,   0, {0}, 1},
      { "ampm", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 5 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);
   body   = S_INT_ARGV(2);
   lon    = S_DBL_ARGV(3);

   vec_hr  = A_INT_RET_ARGV(0);
   vec_min = A_INT_RET_ARGV(1);
   vec_sec = A_INT_RET_ARGV(2);


   mxGetString(prhs[4], type, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      time_cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                          extra->count );
      time_array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, time_cval, time_array);

      ampm_cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                          extra->count );
      ampm_array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, ampm_cval, ampm_array);

      for ( i=0; i<extra->count; i++)
         {
         et  = *(vec_et  + i*extra->offset[0]);

         hr  =  (vec_hr  + i*extra->offset[4]);
         min =  (vec_min + i*extra->offset[5]);
         sec =  (vec_sec + i*extra->offset[6]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         time_array[i] = *time_cval + i*default_str_size;
         ampm_array[i] = *ampm_cval + i*default_str_size;

         et2lst_c( et,
                  body,
                  lon,
                  type,
                  DEFAULT_STR_LENGTH,
                  DEFAULT_STR_LENGTH,
                  hr,
                  min,
                  sec,
                  time_array[i],
                  ampm_array[i] );


         /*
         Check for a failure signal. Free the memory assigned to 'time_cval',
         'ampm_cval', 'time_array', and 'ampm_array'.
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            free_SpiceString_C_array( 1, time_cval );
            free_SpiceString_C_array( 1, ampm_cval );

            free_SpiceMemory( time_array );
            free_SpiceMemory( ampm_array );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[3] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)time_array);
      plhs[4] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)ampm_array);

      free_SpiceString_C_array ( 1, time_cval );
      free_SpiceString_C_array ( 1, ampm_cval );
      free_SpiceMemory( time_array );
      free_SpiceMemory( ampm_array );
      }
   else
      {
      et  = *vec_et;
      hr  = vec_hr;
      min = vec_min;
      sec = vec_sec;

      et2lst_c( et,
               body,
               lon,
               type,
               DEFAULT_STR_LENGTH,
               DEFAULT_STR_LENGTH,
               hr,
               min,
               sec,
               time,
               ampm );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[3] = mxCreateString( time);
      if ( plhs[3] == NULL )
         {
         mexErrMsgTxt(
            "MICE(BUG): mxCreateString 'time' failed in cspice_et2lst" );
         }

      plhs[4] = mxCreateString( ampm );
      if ( plhs[4] == NULL )
         {
         mexErrMsgTxt(
            "MICE(BUG): mxCreateString 'ampm' failed in cspice_et2lst" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              et2utc_c(  SpiceDouble       et,
                                ConstSpiceChar  * format,
                                SpiceInt          prec,
                                SpiceInt          lenout,
                                SpiceChar       * utcstr   )
*/
void cspice_et2utc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           format[DEFAULT_STR_LENGTH+1];
   SpiceChar           utcstr[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceInt            prec;

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "format", MiceChar,   0, {0}, 0},
      { "prec",   MiceInt,    0, {0}, 0},
      { "utcstr", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   memset( utcstr, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], format, DEFAULT_STR_LENGTH);

   prec = S_INT_ARGV(3);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         et2utc_c(et, format, prec, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);

         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {
      et = *(vec_et);

      et2utc_c(et, format, prec, DEFAULT_STR_LENGTH, utcstr);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( utcstr );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_et2utc" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              eul2m_c( SpiceDouble  angle3,
                              SpiceDouble  angle2,
                              SpiceDouble  angle1,
                              SpiceInt     axis3,
                              SpiceInt     axis2,
                              SpiceInt     axis1,
                              SpiceDouble  r [3][3] )
*/
void cspice_eul2m(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_angle3;
   SpiceDouble        * vec_angle2;
   SpiceDouble        * vec_angle1;
   SpiceDouble        * vec_r;
   SpiceDouble          angle3;
   SpiceDouble          angle2;
   SpiceDouble          angle1;
   SpiceInt             axis3;
   SpiceInt             axis2;
   SpiceInt             axis1;
   SpiceDouble        * r;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "angle3", MiceDouble, 0, {0},    1},
      { "angle2", MiceDouble, 0, {0},    1},
      { "angle1", MiceDouble, 0, {0},    1},
      { "axis3",  MiceInt,    0, {0},    0},
      { "axis2",  MiceInt,    0, {0},    0},
      { "axis1",  MiceInt,    0, {0},    0},
      { "r",      MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_angle3 = A_DBL_ARGV(1);
   vec_angle2 = A_DBL_ARGV(2);
   vec_angle1 = A_DBL_ARGV(3);
   angle3     = *vec_angle3;
   angle2     = *vec_angle2;
   angle1     = *vec_angle1;
   axis3      = S_INT_ARGV(4);
   axis2      = S_INT_ARGV(5);
   axis1      = S_INT_ARGV(6);
   vec_r      = A_DBL_RET_ARGV(0);
   r          = vec_r;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         angle3 = *(vec_angle3 + i*extra->offset[0]);
         angle2 = *(vec_angle2 + i*extra->offset[1]);
         angle1 = *(vec_angle1 + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[6]);

         eul2m_c( angle3,
                  angle2,
                  angle1,
                  axis3,
                  axis2,
                  axis1,
                  (SpiceDouble(*)[3])xr);

         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])r );
         }

      }
   else
      {
      eul2m_c( angle3,
               angle2,
               angle1,
               axis3,
               axis2,
               axis1,
               (SpiceDouble(*)[3])xr);

      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])r );
      }

   }




/*
   void              eul2xf_c ( ConstSpiceDouble    eulang[6],
                                SpiceInt            axisa,
                                SpiceInt            axisb,
                                SpiceInt            axisc,
                                SpiceDouble         xform [6][6] );

*/
void cspice_eul2xf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_eulang;
   SpiceDouble        * vec_xform;
   SpiceInt             axisa;
   SpiceInt             axisb;
   SpiceInt             axisc;
   SpiceDouble        * eulang;
   SpiceDouble        * xform;
   SpiceDouble          xr[6][6];

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "eulang", MiceDouble, 1, {6},    1},
      { "axisa",  MiceInt,    0, {0},    0},
      { "axisb",  MiceInt,    0, {0},    0},
      { "axisc",  MiceInt,    0, {0},    0},
      { "xform",  MiceDouble, 2, {6, 6}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_eulang = A_DBL_ARGV(1);
   axisa      = S_INT_ARGV(2);
   axisb      = S_INT_ARGV(3);
   axisc      = S_INT_ARGV(4);
   vec_xform  = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         eulang = (vec_eulang + i*extra->offset[0]);
         xform  = (vec_xform  + i*extra->offset[4]);

         eul2xf_c ( eulang, axisa, axisb, axisc, (SpiceDouble(*)[6])xr);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xr, (SpiceDouble(*)[6])xform  );
         }

      }
   else
      {

      eulang = vec_eulang;
      xform  = vec_xform;

      eul2xf_c( eulang, axisa, axisb, axisc, (SpiceDouble(*)[6])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xr, (SpiceDouble(*)[6])xform  );
      }

   }




/*
   void fovray_c ( ConstSpiceChar   * inst,
                   ConstSpiceDouble   raydir [3],
                   ConstSpiceChar   * rframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * observer,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
void cspice_fovray(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {


   SpiceChar        instrument   [DEFAULT_STR_LENGTH+1];
   SpiceChar        ray_frame    [DEFAULT_STR_LENGTH+1];
   SpiceChar        abcorr       [DEFAULT_STR_LENGTH+1];
   SpiceChar        observer     [DEFAULT_STR_LENGTH+1];

   SpiceDouble    * raydir;
   SpiceDouble    * et;
   SpiceDouble    * vec_et;
   SpiceBoolean   * visible;
   SpiceBoolean   * vec_visible;

   SpiceInt         i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "instrument",   MiceChar,    0, {0}, 0},
      { "raydir",       MiceDouble,  1, {3}, 0},
      { "ray_frame",    MiceChar,    0, {0}, 0},
      { "abcorr",       MiceChar,    0, {0}, 0},
      { "observer",     MiceChar,    0, {0}, 0},
      { "et",           MiceDouble,  0, {0}, 1},
      { "visible",      MiceBoolean, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], instrument, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], ray_frame,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,     DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], observer,   DEFAULT_STR_LENGTH);

   raydir      = A_DBL_ARGV(2);
   vec_et      = A_DBL_ARGV(6);
   vec_visible = A_BOOL_RET_ARGV(0);

   et      = (vec_et);
   visible = (vec_visible);

   /*
   Check for vectorized arguments.
   */

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et      = (vec_et      + i*extra->offset[5]);
         visible = (vec_visible + i*extra->offset[6]);

         fovray_c ( instrument, raydir, ray_frame,
                    abcorr, observer, et, visible );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      fovray_c ( instrument, raydir, ray_frame,
                 abcorr, observer, et, visible );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void fovtrg_c ( ConstSpiceChar   * inst,
                   ConstSpiceChar   * target,
                   ConstSpiceChar   * tshape,
                   ConstSpiceChar   * tframe,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * obsrvr,
                   SpiceDouble      * et,
                   SpiceBoolean     * visible  )
*/
void cspice_fovtrg(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {


   SpiceChar        instrument   [DEFAULT_STR_LENGTH+1];
   SpiceChar        target       [DEFAULT_STR_LENGTH+1];
   SpiceChar        target_shape [DEFAULT_STR_LENGTH+1];
   SpiceChar        target_frame [DEFAULT_STR_LENGTH+1];
   SpiceChar        abcorr       [DEFAULT_STR_LENGTH+1];
   SpiceChar        observer     [DEFAULT_STR_LENGTH+1];
   SpiceDouble    * et;
   SpiceDouble    * vec_et;
   SpiceBoolean   * visible;
   SpiceBoolean   * vec_visible;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "instrument",   MiceChar,    0, {0}, 0},
      { "target",       MiceChar,    0, {0}, 0},
      { "target_shape", MiceChar,    0, {0}, 0},
      { "target_frame", MiceChar,    0, {0}, 0},
      { "abcorr",       MiceChar,    0, {0}, 0},
      { "observer",     MiceChar,    0, {0}, 0},
      { "et",           MiceDouble,  0, {0}, 1},
      { "visible",      MiceBoolean, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], instrument,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target,       DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target_shape, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], target_frame, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr,       DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], observer,     DEFAULT_STR_LENGTH);

   vec_et      = A_DBL_ARGV(7);
   vec_visible = A_BOOL_RET_ARGV(0);

   et      = (vec_et);
   visible = (vec_visible);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et      = (vec_et      + i*extra->offset[6]);
         visible = (vec_visible + i*extra->offset[7]);

         fovtrg_c ( instrument, target, target_shape, target_frame,
                    abcorr, observer, et, visible );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      fovtrg_c ( instrument, target, target_shape, target_frame,
                 abcorr, observer, et, visible );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              frame_c  ( SpiceDouble         x[3],
                                SpiceDouble         y[3],
                                SpiceDouble         z[3] );
*/
void cspice_frame(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

    /*
    Note, the 'x' argument is a mutator. Mutators are a pain.
    */

   SpiceDouble        * vec;
   SpiceDouble        * x;
   SpiceDouble        * y;
   SpiceDouble        * z;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vec", MiceDouble, 1, {3}, 0},
      { "x",   MiceDouble, 1, {3}, 0},
      { "y",   MiceDouble, 1, {3}, 0},
      { "z",   MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec  = A_DBL_ARGV(1);
   x    = A_DBL_RET_ARGV(0);
   y    = A_DBL_RET_ARGV(1);
   z    = A_DBL_RET_ARGV(2);

   /*
   Copy the input 'x' (vec) to the mutatable 'x'.
   */
   MOVED( vec, 3, x );

   frame_c  ( x, y, z );
   CHECK_CALL_FAILURE( SCALAR );

   }




void mice_frinfo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             frcode;
   SpiceInt           * vec_frcode;
   SpiceInt             cent;
   SpiceInt             clss;
   SpiceInt             clssid;
   SpiceBoolean         found;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frcode", MiceInt,    0, {0}, 1},
      { "frinfo", MiceFrinfo, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_frcode = A_INT_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         frcode = *(vec_frcode  + i*extra->offset[0]);

         frinfo_c ( frcode,
                    &cent,
                    &clss,
                    &clssid,
                    &found );
         CHECK_CALL_FAILURE(i);

         if ( !found )
            {
            cent    = 0;
            clss    = 0;
            clssid  = 0;
            }

         mxDestroyArray( mxGetField( plhs[0], i, "center" ) );
         mxSetField(plhs[0], i, "center",   zzmice_CreateIntScalar(cent) );

         mxDestroyArray( mxGetField( plhs[0], i, "class" ) );
         mxSetField(plhs[0], i, "class",    zzmice_CreateIntScalar(clss) );

         mxDestroyArray( mxGetField( plhs[0], i, "class_ID" ) );
         mxSetField(plhs[0], i, "class_ID", zzmice_CreateIntScalar(clssid) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      frcode     = *vec_frcode;

      frinfo_c ( frcode,
                 &cent,
                 &clss,
                 &clssid,
                 &found );
      CHECK_CALL_FAILURE(SCALAR);

      if ( !found )
         {
         cent    = 0;
         clss    = 0;
         clssid  = 0;
         }

      mxDestroyArray( mxGetField( plhs[0], 0, "center" ) );
      mxSetField(plhs[0], 0, "center",   zzmice_CreateIntScalar(cent) );

      mxDestroyArray( mxGetField( plhs[0], 0, "class" ) );
      mxSetField(plhs[0], 0, "class",    zzmice_CreateIntScalar(clss) );

      mxDestroyArray( mxGetField( plhs[0], 0, "class_ID" ) );
      mxSetField(plhs[0], 0, "class_ID", zzmice_CreateIntScalar(clssid) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }




/*
   void              frmnam_c ( SpiceInt            frcode,
                                SpiceInt            lenout,
                                SpiceChar         * frname  )
*/
void cspice_frmnam(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            frname [DEFAULT_STR_LENGTH+1];
   SpiceInt             frcode;
   SpiceInt           * vec_code;
   SpiceInt             i;

   SpiceChar        ** cval;
   SpiceChar        ** array;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frcode", MiceInt,  0, {0}, 1},
      { "frname", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   memset( frname, 0, default_str_size );

   extra    = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_code = A_INT_ARGV(1);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                           extra->count);
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         frcode = *(vec_code  + i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         frmnam_c(frcode, DEFAULT_STR_LENGTH, array[i] );
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed
      memory for plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );

      }
   else
      {

      frcode   = *vec_code;

      frmnam_c(frcode, DEFAULT_STR_LENGTH, frname );
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( frname );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_fmrnam" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              furnsh_c ( ConstSpiceChar    * file );
*/
void cspice_furnsh(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           file[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_file;

   SpiceInt            i;
   SpiceInt            j;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "file", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   if (extra->count>1)
      {

      mx_file = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            file[j] = (char)mx_file[i + (extra->count*j)];
            }

         file[extra->offset[0]] = '\0';

         furnsh_c(file);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      mxGetString(prhs[1], file, DEFAULT_STR_LENGTH);

      furnsh_c(file);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              gcpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * cvals,
                                SpiceBoolean      * found );
*/
void cspice_gcpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             lenout;
   SpiceInt             n = 0;
   SpiceChar         ** cvals;
   SpiceChar         ** array;
   SpiceBoolean         found;

   SpiceInt              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",   MiceChar,   0, {0}, 0},
      { "start",  MiceInt,    0, {0}, 0},
      { "room",   MiceInt,    0, {0}, 0},
      { "cvals",  MiceIgnore, 0, {0}, 0},
      { "found",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);
   lenout = MAXCHR;

   cvals  = (SpiceChar**)alloc_SpiceString_C_array ( lenout, room );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(room);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   gcpool_c(name, start, room, lenout, &n, *cvals, &found);
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cvals, array);

   if ( found )
      {
      for (i=0;i<n;i++)
         {

         /*
         Copy the ith string pointer to the array of pointers for input
         to the mx call.
         */
         array[i] = *cvals + i*lenout;
         }

      /*
      I think this functions as a copy, creating needed memory to 'plhs'.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   plhs[1] = zzmice_CreateIntScalar(found);

   free_SpiceString_C_array( 1, cvals );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              gdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceDouble       * values,
                                SpiceBoolean      * found );
*/
void cspice_gdpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n = 0;
   SpiceDouble        * dvals;
   SpiceDouble        * dvals_ret;
   SpiceBoolean         found;

   int                  sizearray[2];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar,    0, {0}, 0},
      { "start", MiceInt,     0, {0}, 0},
      { "room",  MiceInt,     0, {0}, 0},
      { "dvals", MiceIgnore,  0, {0}, 0},
      { "found", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);

   dvals  = (SpiceDouble*)mxMalloc(room * sizeof(SpiceDouble) );
   memset( dvals,  0, room * sizeof(SpiceDouble) );

   gdpool_c(name, start, room, &n, dvals, &found);

   /*
   Check for a failure signal. Free the memory assigned to 'dvals'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( dvals );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if( found )
      {
      sizearray[0] = n;
      sizearray[1] = 1;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   dvals_ret = A_DBL_RET_ARGV(0);

   plhs[1] = zzmice_CreateIntScalar(found);

   MOVED( dvals, n, dvals_ret );
   mxFree( dvals );

   }




/*
   void              georec_c ( SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         rectan[3] );
*/
void cspice_georec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_rectan;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * rectan;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_lon    = A_DBL_ARGV(1);
   vec_lat    = A_DBL_ARGV(2);
   vec_alt    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   re         = S_DBL_ARGV(4);
   f          = S_DBL_ARGV(5);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         lon    = *(vec_lon    + i*extra->offset[0]);
         lat    = *(vec_lat    + i*extra->offset[1]);
         alt    = *(vec_alt    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[5]);

         georec_c(lon, lat, alt, re, f, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      georec_c(lon, lat, alt, re, f, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              getfov_c ( SpiceInt            instid,
                                SpiceInt            room,
                                SpiceInt            shapelen,
                                SpiceInt            framelen,
                                SpiceChar         * shape,
                                SpiceChar         * frame,
                                SpiceDouble         bsight [3],
                                SpiceInt          * n,
                                SpiceDouble         bounds [][3] );
*/
void cspice_getfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             instid;
   SpiceInt             room;
   SpiceChar            shape[DEFAULT_STR_LENGTH+1];
   SpiceChar            frame[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * bsight;
   SpiceInt             n = 0;
   SpiceDouble        * bounds;
   SpiceDouble        * bounds_ret;

   int                  sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "instid",   MiceInt,    0, {0}, 0},
      { "room",     MiceInt,    0, {0}, 0},
      { "shape",    MiceChar,   0, {0}, 0},
      { "frame",    MiceChar,   0, {0}, 0},
      { "bsight",   MiceDouble, 1, {3}, 0},
      { "bounds",   MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   instid = S_INT_ARGV(1);
   room   = S_INT_ARGV(2);

   bsight = A_DBL_RET_ARGV(2);

   bounds = (SpiceDouble*)mxMalloc( 3 * room * sizeof(SpiceDouble) );
   memset( bounds,  0, 3 * room * sizeof(SpiceDouble) );

   getfov_c( instid,
             room,
             DEFAULT_STR_LENGTH,
             DEFAULT_STR_LENGTH,
             shape,
             frame,
             bsight,
             &n,
             (SpiceDouble(*)[3])bounds);

   /*
   Check for a failure signal. Free the memory assigned to 'bounds'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( bounds );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if ( n > 0 )
      {
      plhs[0] = mxCreateString( shape );
      plhs[1] = mxCreateString( frame );

      /*
      Set the size for the numeric array as 3XN
      */
      sizearray[0] = 3;
      sizearray[1] = n;
      }
   else
      {

      /*
      No variables found matching the template. Set 'frame' and 'shape' to
      nulls.
      */
      plhs[0] = mxCreateString( "\0" );
      plhs[1] = mxCreateString( "\0" );

      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   if ( (plhs[0] == NULL) || (plhs[1] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_getfov" );
      }

   plhs[3]    = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   bounds_ret = A_DBL_RET_ARGV(3);

   /*
   Move the contents of 'bounds' to the return matrix 'bounds_ret'. On return
   to MATLAB the matrix will have dimension 3xN.
   */
   MOVED( bounds, 3*n, bounds_ret );
   mxFree( bounds );

   }




/*
   void              gfdist_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )

*/
void cspice_gfdist(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(5);
   adjust  = S_DBL_ARGV(6);
   step    = S_DBL_ARGV(7);
   nintvls = S_INT_ARGV(8);

   cnfine = (SpiceDouble*)mxGetData(prhs[9]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[9] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfdist_c ( target,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfilum_c ( ConstSpiceChar     * method,
                                ConstSpiceChar     * angtyp,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * illum,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceDouble     spoint [3],
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result     )
*/
void cspice_gfilum(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            angtyp [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            illum  [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                  sizearray[2];

   SpiceInt             cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method",  MiceChar,   0, {0}, 0},
      { "angtyp",  MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "illum",   MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "spoint",  MiceDouble, 1, {3}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 14, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], angtyp, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], illum,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(8);

   mxGetString(prhs[9], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(10);
   adjust  = S_DBL_ARGV(11);
   step    = S_DBL_ARGV(12);
   nintvls = S_INT_ARGV(13);

   cnfine = (SpiceDouble*)mxGetData(prhs[14]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[14] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfilum_c ( method,
                     angtyp,
                     target,
                     illum,
                     fixref,
                     abcorr,
                     obsrvr,
                     spoint,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfoclt_c ( ConstSpiceChar   * occtyp,
                                ConstSpiceChar   * front,
                                ConstSpiceChar   * fshape,
                                ConstSpiceChar   * fframe,
                                ConstSpiceChar   * back,
                                ConstSpiceChar   * bshape,
                                ConstSpiceChar   * bframe,
                                ConstSpiceChar   * abcorr,
                                ConstSpiceChar   * obsrvr,
                                SpiceDouble        step,
                                SpiceCell        * cnfine,
                                SpiceCell        * result )

*/
void cspice_gfoclt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            occtyp [DEFAULT_STR_LENGTH+1];
   SpiceChar            front  [DEFAULT_STR_LENGTH+1];
   SpiceChar            fshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            fframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            back   [DEFAULT_STR_LENGTH+1];
   SpiceChar            bshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            bframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "occtyp",  MiceChar,   0, {0}, 0},
      { "front",   MiceChar,   0, {0}, 0},
      { "fshape",  MiceChar,   0, {0}, 0},
      { "fframe",  MiceChar,   0, {0}, 0},
      { "back",    MiceChar,   0, {0}, 0},
      { "bshape",  MiceChar,   0, {0}, 0},
      { "bframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "size",    MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 12, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], occtyp,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], front,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], fshape,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], fframe,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], back,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], bshape,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], bframe,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsrvr,  DEFAULT_STR_LENGTH);

   step = S_DBL_ARGV(10);

   cnfine = (SpiceDouble*)mxGetData(prhs[11]);

   size = S_INT_ARGV(12);

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[11] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfoclt_c ( occtyp,
                     front,
                     fshape,
                     fframe,
                     back,
                     bshape,
                     bframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfpa_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * illum,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result     )

*/
void cspice_gfpa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            illum  [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "illum",   MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 10, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], illum,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(6);
   adjust  = S_DBL_ARGV(7);
   step    = S_DBL_ARGV(8);
   nintvls = S_INT_ARGV(9);

   cnfine = (SpiceDouble*)mxGetData(prhs[10]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[10] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfpa_c ( target,
                   illum,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine_cell,
                   &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfposc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * frame,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );

*/
void cspice_gfposc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame  [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "frame",   MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 12, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], frame,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(8);
   adjust  = S_DBL_ARGV(9);
   step    = S_DBL_ARGV(10);
   nintvls = S_INT_ARGV(11);

   cnfine = (SpiceDouble*)mxGetData(prhs[12]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[12] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfposc_c ( target,
                     frame,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfrfov_c ( ConstSpiceChar    * inst,
                                ConstSpiceDouble    raydir [3],
                                ConstSpiceChar    * rframe,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         step,
                                SpiceCell         * cnfine,
                                SpiceCell         * result     );
*/
void cspice_gfrfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            inst   [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * raydir;
   SpiceChar            rframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,   0, {0}, 0},
      { "raydir",  MiceDouble, 1, {3}, 0},
      { "rframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "size",    MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], inst,   DEFAULT_STR_LENGTH);

   raydir = A_DBL_ARGV(2);

   mxGetString(prhs[3], rframe, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   step   = S_DBL_ARGV(6);

   cnfine = (SpiceDouble*)mxGetData(prhs[7]);

   size   = S_INT_ARGV(8);

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[7] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfrfov_c ( inst,
                     raydir,
                     rframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfrr_c ( ConstSpiceChar     * target,
                              ConstSpiceChar     * abcorr,
                              ConstSpiceChar     * obsrvr,
                              ConstSpiceChar     * relate,
                              SpiceDouble          refval,
                              SpiceDouble          adjust,
                              SpiceDouble          step,
                              SpiceInt             nintvls,
                              SpiceCell          * cnfine,
                              SpiceCell          * result  )

*/
void cspice_gfrr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(5);
   adjust  = S_DBL_ARGV(6);
   step    = S_DBL_ARGV(7);
   nintvls = S_INT_ARGV(8);

   cnfine = (SpiceDouble*)mxGetData(prhs[9]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[9] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfrr_c ( target,
                   abcorr,
                   obsrvr,
                   relate,
                   refval,
                   adjust,
                   step,
                   nintvls,
                   &cnfine_cell,
                   &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfsep_c (  ConstSpiceChar     * targ1,
                                ConstSpiceChar     * shape1,
                                ConstSpiceChar     * frame1,
                                ConstSpiceChar     * targ2,
                                ConstSpiceChar     * shape2,
                                ConstSpiceChar     * frame2,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )

*/
void cspice_gfsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            targ1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            targ2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ1",   MiceChar,   0, {0}, 0},
      { "shape1",  MiceChar,   0, {0}, 0},
      { "frame1",  MiceChar,   0, {0}, 0},
      { "targ2",   MiceChar,   0, {0}, 0},
      { "shape2",  MiceChar,   0, {0}, 0},
      { "frame2",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 14, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ1,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], shape1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], frame1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], targ2,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], shape2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], frame2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(10);
   adjust  = S_DBL_ARGV(11);
   step    = S_DBL_ARGV(12);
   nintvls = S_INT_ARGV(13);

   cnfine = (SpiceDouble*)mxGetData(prhs[14]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[14] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsep_c (  targ1,
                     shape1,
                     frame1,
                     targ2,
                     shape2,
                     frame2,
                     abcorr,
                     obsrvr,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfsntc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * method,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * dref,
                                ConstSpiceDouble     dvec   [3],
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );
*/
void cspice_gfsntc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            dref   [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * dvec;
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "method",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "dref",    MiceChar,   0, {0}, 0},
      { "dvec",    MiceDouble, 1, {3}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 15, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], fixref,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], method,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], dref,    DEFAULT_STR_LENGTH);

   dvec = A_DBL_ARGV(7);

   mxGetString(prhs[8],  crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[9],  coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[10], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(11);
   adjust  = S_DBL_ARGV(12);
   step    = S_DBL_ARGV(13);
   nintvls = S_INT_ARGV(14);

   cnfine = (SpiceDouble*)mxGetData(prhs[15]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[15] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsntc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     dref,
                     dvec,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gfstol_c ( SpiceDouble         value );
*/
void cspice_gfstol(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          value;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "value",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   value = S_DBL_ARGV(1);

   (void) gfstol_c ( value );
   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              gfsubc_c ( ConstSpiceChar     * target,
                                ConstSpiceChar     * fixref,
                                ConstSpiceChar     * method,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                ConstSpiceChar     * crdsys,
                                ConstSpiceChar     * coord,
                                ConstSpiceChar     * relate,
                                SpiceDouble          refval,
                                SpiceDouble          adjust,
                                SpiceDouble          step,
                                SpiceInt             nintvls,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  );
*/
void cspice_gfsubc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref [DEFAULT_STR_LENGTH+1];
   SpiceChar            method [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceChar            crdsys [DEFAULT_STR_LENGTH+1];
   SpiceChar            coord  [DEFAULT_STR_LENGTH+1];
   SpiceChar            relate [DEFAULT_STR_LENGTH+1];
   SpiceDouble          refval;
   SpiceDouble          adjust;
   SpiceDouble          step;
   SpiceInt             nintvls;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",  MiceChar,   0, {0}, 0},
      { "fixref",  MiceChar,   0, {0}, 0},
      { "method",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "crdsys",  MiceChar,   0, {0}, 0},
      { "coord",   MiceChar,   0, {0}, 0},
      { "relate",  MiceChar,   0, {0}, 0},
      { "refval",  MiceDouble, 0, {0}, 0},
      { "adjust",  MiceDouble, 0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "nintvls", MiceInt,    0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 13, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], fixref,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], method,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], crdsys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], coord,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], relate,  DEFAULT_STR_LENGTH);

   refval  = S_DBL_ARGV(9);
   adjust  = S_DBL_ARGV(10);
   step    = S_DBL_ARGV(11);
   nintvls = S_INT_ARGV(12);

   cnfine = (SpiceDouble*)mxGetData(prhs[13]);

   size = nintvls*2.;

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[13] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gfsubc_c ( target,
                     fixref,
                     method,
                     abcorr,
                     obsrvr,
                     crdsys,
                     coord,
                     relate,
                     refval,
                     adjust,
                     step,
                     nintvls,
                     &cnfine_cell,
                     &result_cell  );


   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }




/*
   void              gftfov_c ( ConstSpiceChar     * inst,
                                ConstSpiceChar     * target,
                                ConstSpiceChar     * tshape,
                                ConstSpiceChar     * tframe,
                                ConstSpiceChar     * abcorr,
                                ConstSpiceChar     * obsrvr,
                                SpiceDouble          step,
                                SpiceCell          * cnfine,
                                SpiceCell          * result  )
*/
void cspice_gftfov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            inst   [DEFAULT_STR_LENGTH+1];
   SpiceChar            target [DEFAULT_STR_LENGTH+1];
   SpiceChar            tshape [DEFAULT_STR_LENGTH+1];
   SpiceChar            tframe [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble          step;
   SpiceDouble        * cnfine;
   SpiceInt             size;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   int                 sizearray[2];

   SpiceInt            cnfine_size;

   /*
   Initialize the 'cnfine_cell' and 'result_cell' cells
   as double precision with zero size and zero cardinality.
   */
   SpiceCell           cnfine_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   SpiceCell           result_cell = { SPICE_DP,
                                       0,
                                       0,
                                       0,
                                       SPICETRUE,
                                       SPICEFALSE,
                                       SPICEFALSE,
                                       NULL,
                                       NULL };

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "inst",    MiceChar,   0, {0}, 0},
      { "target",  MiceChar,   0, {0}, 0},
      { "tshape",  MiceChar,   0, {0}, 0},
      { "tframe",  MiceChar,   0, {0}, 0},
      { "abcorr",  MiceChar,   0, {0}, 0},
      { "obsrvr",  MiceChar,   0, {0}, 0},
      { "step",    MiceDouble, 0, {0}, 0},
      { "cnfine",  MiceWin,    1, {0}, 0},
      { "size",    MiceInt,    0, {0}, 0},
      { "result",  MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 9, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], inst,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], tshape, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], tframe, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   step   = S_DBL_ARGV(7);

   cnfine = (SpiceDouble*)mxGetData(prhs[8]);

   size   = S_INT_ARGV(9);

   /*
   The size of array 'cnfine' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'cnfine' without the append size.
   */
   cnfine_size = mxGetNumberOfElements( prhs[8] ) - SPICE_CELL_CTRLSZ;

   /*
   Set the struct fields to fully describe the 'cnfine_cell' cell. A Mice
   window implementation has size equal to cardinality.
   */
   cnfine_cell.size = cnfine_size;
   cnfine_cell.card = cnfine_size;
   cnfine_cell.base = cnfine;
   cnfine_cell.data = &cnfine[SPICE_CELL_CTRLSZ];

   /*
   mxMalloc returns to top level on error.
   */
   result = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );


   /*
   Set the struct fields to initialize the 'result_cell' cell.
   The cardinality remains zero as this assignment occurs prior
   to use.
   */
   result_cell.size = size;
   result_cell.base = result;
   result_cell.data = &result[SPICE_CELL_CTRLSZ];

   (void) gftfov_c ( inst,
                     target,
                     tshape,
                     tframe,
                     abcorr,
                     obsrvr,
                     step,
                     &cnfine_cell,
                     &result_cell  );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );
      mice_fail(SCALAR);
      }

   /*
   Create an output array CARDx1.
   */
   sizearray[0] = card_c( &result_cell );
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'result' array index SPICE_CELL_CTRLSZ and contains 'sizearray[0]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, sizearray[0], result_f );

   mxFree( result );
   }





/*
   void              gipool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt          * n,
                                SpiceInt          * ivals,
                                SpiceBoolean      * found );
*/
void cspice_gipool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name[MAXLEN+1];
   SpiceInt             start;
   SpiceInt             room;
   SpiceInt             n           = 0;
   SpiceInt           * ivals;
   SpiceInt           * ivals_ret;
   SpiceBoolean         found;

   int                  sizearray[2];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar,   0, {0}, 0},
      { "start", MiceInt,    0, {0}, 0},
      { "room",  MiceInt,    0, {0}, 0},
      { "ivals", MiceIgnore, 0, {0}, 0},
      { "found", MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start = S_INT_ARGV(2) - 1;
   room  = S_INT_ARGV(3);

   ivals  = (SpiceInt*)mxMalloc(room * sizeof(SpiceInt) );
   memset( ivals,  0, room * sizeof(SpiceInt) );

   gipool_c(name, start, room, &n, ivals, &found);

   /*
   Check for a failure signal. Free the memory assigned to 'ivals'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( ivals );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   if( found )
      {
      sizearray[0] = n;
      sizearray[1] = 1;
      }
   else
      {
      sizearray[0] = 0;
      sizearray[1] = 0;
      }

   plhs[0]   = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ivals_ret = A_INT_RET_ARGV(0);

   plhs[1] = zzmice_CreateIntScalar(found);

   MOVEI( ivals, n, ivals_ret );
   mxFree( ivals );

   }




/*
   SpiceDouble halfpi_c( void )
*/
void cspice_halfpi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( halfpi_c() );
   }





/*
   void              gnpool_c ( ConstSpiceChar    * name,
                                SpiceInt            start,
                                SpiceInt            room,
                                SpiceInt            lenout,
                                SpiceInt          * n,
                                void              * kvars,
                                SpiceBoolean      * found  );
*/
void cspice_gnpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             name[MAXLEN+1];
   SpiceInt              start;
   SpiceInt              room;
   SpiceInt              lenout;
   SpiceInt              n        = 0;
   SpiceChar          ** kvars;
   SpiceChar          ** array;
   SpiceBoolean       * found;

   SpiceInt              i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",   MiceChar,    0, {0}, 0},
      { "start",  MiceInt,     0, {0}, 0},
      { "room",   MiceInt,     0, {0}, 0},
      { "kvars",  MiceChar,    0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN );

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'start' index.
   */
   start  = S_INT_ARGV(2) - 1;
   room   = S_INT_ARGV(3);
   found  = A_BOOL_RET_ARGV(1);

   lenout = MAXLEN;

   kvars  = (SpiceChar**)alloc_SpiceString_C_array ( lenout, room );
   array  = (SpiceChar**)alloc_SpiceString_Pointer_array(room);

   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, kvars, array);

   gnpool_c(name, start, room, lenout, &n, *kvars, found);
   CHECK_CALL_FAILURE_MEM1(SCALAR, 1, kvars, array);

   for (i=0;i<n;i++)
      {

      /*
      Copy the ith string pointer to the array of pointers for input
      to the mx call.
      */
      array[i] = *kvars + i*lenout;
      }

   /*
   I think this functions as a copy, creating needed memory to 'plhs'.
   */
   plhs[0] = mxCreateCharMatrixFromStrings( n, (const char **)array);

   free_SpiceString_C_array( 1, kvars );
   free_SpiceMemory( array );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              illum_c  ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     );
*/
void cspice_illum(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble        * phase;
   SpiceDouble        * solar;
   SpiceDouble        * emissn;
   SpiceDouble        * vec_spoint;
   SpiceDouble        * vec_phase;
   SpiceDouble        * vec_solar;
   SpiceDouble        * vec_emissn;
   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 1},
      { "phase",  MiceDouble, 0, {0}, 1},
      { "solar",  MiceDouble, 0, {0}, 1},
      { "emissn", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);

   mxGetString(prhs[3], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr, DEFAULT_STR_LENGTH);

   vec_spoint = A_DBL_ARGV(5);
   vec_phase  = A_DBL_RET_ARGV(0);
   vec_solar  = A_DBL_RET_ARGV(1);
   vec_emissn = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et     = *(vec_et     + i*extra->offset[1]);
         spoint =  (vec_spoint + i*extra->offset[4]);
         phase  =  (vec_phase  + i*extra->offset[5]);
         solar  =  (vec_solar  + i*extra->offset[6]);
         emissn =  (vec_emissn + i*extra->offset[7]);

         illum_c(target, et, abcorr, obsrvr, spoint, phase, solar, emissn);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      et     = *vec_et;
      spoint = vec_spoint;
      phase  = vec_phase;
      solar  = vec_solar;
      emissn = vec_emissn;

      illum_c(target, et, abcorr, obsrvr, spoint, phase, solar, emissn);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              ilumin_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceDouble    spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceDouble       * phase,
                                SpiceDouble       * solar,
                                SpiceDouble       * emissn     );
*/
void mice_ilumin(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * spoint;
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceDouble          phase;
   SpiceDouble          solar;
   SpiceDouble          emissn;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 0},
      { "ilum",   MiceIlum,   0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   spoint = A_DBL_ARGV(7);

   ilumin_c( method,
             target,
             et,
             fixref,
             abcorr,
             obsrvr,
             spoint,
             &trgepc,
             srfvec,
             &phase,
             &solar,
             &emissn );

   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc",  mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "phase" ) );
   mxSetField( plhs[0], 0, "phase", mxCreateDoubleScalar(phase) );

   mxDestroyArray( mxGetField( plhs[0], 0, "solar" ) );
   mxSetField( plhs[0], 0, "solar", mxCreateDoubleScalar(solar) );

   mxDestroyArray( mxGetField( plhs[0], 0, "emissn" ) );
   mxSetField( plhs[0], 0, "emissn", mxCreateDoubleScalar(emissn) );

   }




/*
   void              inedpl_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * ellipse,
                                SpiceBoolean      * found    );
*/
void cspice_inedpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpicePlane           plane;
   SpiceEllipse         ellipse;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",       MiceDouble,  0, {0}, 0},
      { "b",       MiceDouble,  0, {0}, 0},
      { "c",       MiceDouble,  0, {0}, 0},
      { "plane",   MicePlane,   0, {0}, 0},
      { "ellipse", MiceEllipse, 0, {0}, 0},
      { "found",   MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 4, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = S_DBL_ARGV(1);
   b = S_DBL_ARGV(2);
   c = S_DBL_ARGV(3);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[4], 0, "normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[4], 0,"constant") );

   found  = A_BOOL_RET_ARGV(1);

   inedpl_c ( a, b, c, &plane, &ellipse, found );
   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           ellipse.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           ellipse.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           ellipse.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              inelpl_c ( ConstSpiceEllipse * ellips,
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt1[3],
                                SpiceDouble         xpt2[3] );
*/
void cspice_inelpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse         ellips;
   SpicePlane           plane;
   SpiceInt           * nxpts;
   SpiceDouble        * xpt1;
   SpiceDouble        * xpt2;


   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "ellips", MiceEllipse, 0, {0}, 0},
      { "plane",  MicePlane,   0, {0}, 0},
      { "nxpts",  MiceInt,     0, {0}, 0},
      { "xpt1",   MiceDouble,  1, {3}, 0},
      { "xpt2",   MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble an ellipse structure from the input arguments.
   */
   memcpy( ellips.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellips.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );


   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   nxpts = A_INT_RET_ARGV(0);
   xpt1  = A_DBL_RET_ARGV(1);
   xpt2  = A_DBL_RET_ARGV(2);

   inelpl_c ( &ellips, &plane, nxpts, xpt1, xpt2 );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              inrypl_c ( ConstSpiceDouble    vertex [3],
                                ConstSpiceDouble    dir    [3],
                                ConstSpicePlane   * plane,
                                SpiceInt          * nxpts,
                                SpiceDouble         xpt    [3] );
*/
void cspice_inrypl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vertex;
   SpiceDouble        * dir;
   SpicePlane           plane;
   SpiceInt           * nxpts;
   SpiceDouble        * xpt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vertex", MiceDouble,  1, {3}, 0},
      { "dir",    MiceDouble,  1, {3}, 0},
      { "plane",  MicePlane,   0, {0}, 0},
      { "nxpts",  MiceInt,     0, {0}, 0},
      { "xpt1",   MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vertex = A_DBL_ARGV(1);
   dir    = A_DBL_ARGV(2);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[3], 0, "normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[3], 0,"constant") );

   nxpts = A_INT_RET_ARGV(0);
   xpt   = A_DBL_RET_ARGV(1);

   inrypl_c ( vertex, dir, &plane, nxpts, xpt );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              invort_c ( ConstSpiceDouble    m  [3][3],
                                SpiceDouble         mit[3][3] );
*/
void cspice_invort(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * m;
   SpiceDouble        * mit;
   SpiceDouble          xr[3][3];
   SpiceDouble          yr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "m",    MiceDouble, 2, {3, 3}, 0},
      { "mit",  MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   m    = A_DBL_ARGV(1);
   mit  = A_DBL_RET_ARGV(0);

   xpose_c( m, (SpiceDouble(*)[3])yr);

   invort_c( yr, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mit);

   }




/*
   SpiceDouble       j1900_c  ( void )
*/
void cspice_j1900(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j1900_c() );
   }




/*
   SpiceDouble       j1950_c  ( void )
*/
void cspice_j1950(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j1950_c() );
   }




/*
   SpiceDouble       j2000_c  ( void )
*/
void cspice_j2000(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j2000_c() );

   }




/*
   SpiceDouble       j2100_c  ( void )
*/
void cspice_j2100(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( j2100_c() );
   }




/*
   SpiceDouble       jyear_c  ( void )
*/
void cspice_jyear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( jyear_c() );
   }




/*
   void              kclear_c( void )
*/
void cspice_kclear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 0 );

   /*
   Not much to do, make the call.
   */
   kclear_c();

   }




/*
   void              kdata_c  ( SpiceInt          which,
                                ConstSpiceChar  * kind,
                                SpiceInt          fillen,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * file,
                                SpiceChar       * filtyp,
                                SpiceChar       * source,
                                SpiceInt        * handle,
                                SpiceBoolean    * found   );
*/
void cspice_kdata(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             which;
   SpiceChar            kind  [DEFAULT_STR_LENGTH+1];
   SpiceChar            file  [DEFAULT_STR_LENGTH+1];
   SpiceChar            filtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar            source[DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "which",  MiceInt,     0, {0}, 0},
      { "kind",   MiceChar,    0, {0}, 0},
      { "file",   MiceChar,    0, {0}, 0},
      { "filtyp", MiceChar,    0, {0}, 0},
      { "source", MiceChar,    0, {0}, 0},
      { "handle", MiceInt,     0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 5 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'which' index.
   */
   which = S_INT_ARGV(1) - 1;
   mxGetString(prhs[2], kind, DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(3);
   found  = A_BOOL_RET_ARGV(4);

   kdata_c( which,
            kind,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            file,
            filtyp,
            source,
            handle,
            found);

   if( *found )
      {
      plhs[0] = mxCreateString( file );
      plhs[1] = mxCreateString( filtyp );
      plhs[2] = mxCreateString( source );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      plhs[1] = mxCreateString( "\0" );
      plhs[2] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[0]" );
      }
   if ( plhs[1] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[1]" );
      }
   if ( plhs[2] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[2]" );
      }

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              kinfo_c  ( ConstSpiceChar  * file,
                                SpiceInt          typlen,
                                SpiceInt          srclen,
                                SpiceChar       * filtyp,
                                SpiceChar       * source,
                                SpiceInt        * handle,
                                SpiceBoolean    * found  )
*/
void cspice_kinfo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            file  [DEFAULT_STR_LENGTH+1];
   SpiceChar            filtyp[DEFAULT_STR_LENGTH+1];
   SpiceChar            source[DEFAULT_STR_LENGTH+1];
   SpiceInt           * handle;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "file",   MiceChar,    0, {0}, 0},
      { "filtyp", MiceChar,    0, {0}, 0},
      { "source", MiceChar,    0, {0}, 0},
      { "handle", MiceInt,     0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 4 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], file, DEFAULT_STR_LENGTH);

   handle = A_INT_RET_ARGV(2);
   found  = A_BOOL_RET_ARGV(3);

   kinfo_c( file,
            DEFAULT_STR_LENGTH,
            DEFAULT_STR_LENGTH,
            filtyp,
            source,
            handle,
            found);

   plhs[0] = mxCreateString( filtyp );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_kinfo" );
      }

   plhs[1] = mxCreateString( source );
   if ( plhs[1] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_kinfo" );
      }


   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              ktotal_c ( ConstSpiceChar   * kind,
                                SpiceInt         * count )
*/
void cspice_ktotal(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            kind[DEFAULT_STR_LENGTH+1];
   SpiceInt           * count;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "kind",  MiceChar, 0, {0}, 0},
      { "count", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   count = A_INT_RET_ARGV(0);

   mxGetString(prhs[1], kind, DEFAULT_STR_LENGTH);

   ktotal_c( kind, count);
   CHECK_CALL_FAILURE(SCALAR);

   }





/*
   void                latcyl_c( SpiceDouble    radius,
                                 SpiceDouble    lon,
                                 SpiceDouble    lat,
                                 SpiceDouble *  r,
                                 SpiceDouble *  lonc,
                                 SpiceDouble *  z )
*/
void cspice_latcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_r;
   SpiceDouble        * vec_lonc;
   SpiceDouble        * vec_z;
   SpiceDouble          radius;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * r;
   SpiceDouble        * lonc;
   SpiceDouble        * z;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "lonc",   MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(1);
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_lonc   = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[0]);
         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[3]);
         lonc   =  (vec_lonc   + i*extra->offset[4]);
         z      =  (vec_z      + i*extra->offset[5]);

         latcyl_c(radius, lon, lat, r, lonc, z);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      radius = *(vec_radius);
      lon    = *(vec_lon);
      lat    = *(vec_lat);
      r      =  (vec_r);
      lonc   =  (vec_lonc);
      z      =  (vec_z);

      latcyl_c(radius, lon, lat, r, lonc, z);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              latrec_c( SpiceDouble    radius,
                               SpiceDouble    longitude,
                               SpiceDouble    latitude,
                               SpiceDouble    rectan[3] )
*/
void cspice_latrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_longitude;
   SpiceDouble        * vec_latitude;
   SpiceDouble        * vec_rectan;
   SpiceDouble          radius;
   SpiceDouble          longitude;
   SpiceDouble          latitude;
   SpiceDouble        * rectan;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius",    MiceDouble, 0, {0}, 1},
      { "longitude", MiceDouble, 0, {0}, 1},
      { "latitude",  MiceDouble, 0, {0}, 1},
      { "rectan",    MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs, plhs, nrhs, prhs, ArgCheck);

   vec_radius    = A_DBL_ARGV(1);
   vec_longitude = A_DBL_ARGV(2);
   vec_latitude  = A_DBL_ARGV(3);
   vec_rectan    = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius    = *(vec_radius    + i*extra->offset[0]);
         longitude = *(vec_longitude + i*extra->offset[1]);
         latitude  = *(vec_latitude  + i*extra->offset[2]);
         rectan    =  (vec_rectan    + i*extra->offset[3]);

         latrec_c(radius, longitude, latitude, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      radius    = *(vec_radius);
      longitude = *(vec_longitude);
      latitude  = *(vec_latitude);
      rectan    =  (vec_rectan);

      latrec_c(radius, longitude, latitude, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              latsph_c( SpiceDouble    radius,
                               SpiceDouble    lon,
                               SpiceDouble    lat,
                               SpiceDouble *  rho,
                               SpiceDouble *  colat,
                               SpiceDouble *  lons )
*/
void cspice_latsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_rho;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_lons;
   SpiceDouble          radius;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble        * rho;
   SpiceDouble        * colat;
   SpiceDouble        * lons;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "rho",    MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "lons",   MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(ONE_IN  );
   vec_lon    = A_DBL_ARGV(TWO_IN  );
   vec_lat    = A_DBL_ARGV(THREE_IN);

   vec_rho    = A_DBL_RET_ARGV(ONE_OUT  );
   vec_colat  = A_DBL_RET_ARGV(TWO_OUT  );
   vec_lons   = A_DBL_RET_ARGV(THREE_OUT);

   radius     = *vec_radius;
   lon        = *vec_lon;
   lat        = *vec_lat;
   rho        =  vec_rho;
   colat      =  vec_colat;
   lons       =  vec_lons;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[ONE_OFF  ]);
         lon    = *(vec_lon    + i*extra->offset[TWO_OFF  ]);
         lat    = *(vec_lat    + i*extra->offset[THREE_OFF]);
         rho    =  (vec_rho    + i*extra->offset[FOUR_OFF ]);
         colat  =  (vec_colat  + i*extra->offset[FIVE_OFF ]);
         lons   =  (vec_lons   + i*extra->offset[SIX_OFF  ]);

         latsph_c(radius, lon, lat, rho, colat, lons);
         CHECK_CALL_FAILURE(i)
         }

      }
   else
      {

      latsph_c(radius, lon, lat, rho, colat, lons);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              lmpool_c ( const void        * cvals,
                                SpiceInt            lenvals,
                                SpiceInt            n       );


*/
void cspice_lmpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   MAXCHR and MAXLEN defined in cspice_params.h.
   */
   SpiceChar            str [LINLEN + 1];
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   SpiceInt             i;
   SpiceInt             j;
   SpiceInt             count;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "cvals", MiceChar, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   /*
   The following logic differs slightly from other string input arguments.
   A lmpool_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (As with pcpool_c, Is this a bug or design failure? EDW)
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   mx_str = (mxChar *)mxGetChars(prhs[ONE_IN]);


   /*
   A string lmpool_c input string has at most LINLEN characters
   so the maximum room needed is either extra->offset[0] +1 if that
   value less than LINLEN or LINLEN + 1 (for \n).
   */
   if( extra->offset[ONE_OFF] > LINLEN )
      {
      cvals_len  = LINLEN + 1;
      }
   else
      {
      cvals_len  = extra->offset[ONE_OFF] + 1;
      }


   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );

   CHECK_CALL_FAILURE( SCALAR );

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   lmpool_c(  *cvals, cvals_len, cvals_size);
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void                ltime_c( SpiceDouble        etobs,
                                SpiceInt           obs,
                                ConstSpiceChar   * dir,
                                SpiceInt           targ,
                                SpiceDouble      * ettarg,
                                SpiceDouble      * elapsd  )
*/
void cspice_ltime(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble      etobs;
   SpiceDouble    * vec_etobs;
   SpiceInt         obs;
   SpiceChar        dir[DEFAULT_STR_LENGTH+1];
   SpiceInt         targ;
   SpiceDouble    * ettarg;
   SpiceDouble    * vec_ettarg;
   SpiceDouble    * elapsd;
   SpiceDouble    * vec_elapsd;

   SpiceInt         i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "etobs",  MiceDouble, 0, {0}, 1},
      { "obs",    MiceInt,    0, {0}, 0},
      { "dir",    MiceChar,   0, {0}, 0},
      { "targ",   MiceInt,    0, {0}, 0},
      { "ettarg", MiceDouble, 0, {0}, 1},
      { "elapsd", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_etobs  = A_DBL_ARGV(1);
   vec_ettarg = A_DBL_RET_ARGV(0);
   vec_elapsd = A_DBL_RET_ARGV(1);

   obs       = S_INT_ARGV(2);
   mxGetString(prhs[3], dir, DEFAULT_STR_LENGTH);
   targ       = S_INT_ARGV(4);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         etobs  = *(vec_etobs+i*extra->offset[0]);
         ettarg = (vec_ettarg+i*extra->offset[4]);
         elapsd = (vec_elapsd+i*extra->offset[5]);

         ltime_c(etobs, obs, dir, targ, ettarg, elapsd);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      etobs  = *(vec_etobs);
      ettarg =  (vec_ettarg);
      elapsd =  (vec_elapsd);

      ltime_c(etobs, obs, dir, targ, ettarg, elapsd);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }





/*
   void              m2eul_c  ( ConstSpiceDouble    r[3][3],
                                SpiceInt            axis3,
                                SpiceInt            axis2,
                                SpiceInt            axis1,
                                SpiceDouble       * angle3,
                                SpiceDouble       * angle2,
                                SpiceDouble       * angle1  );
*/
void cspice_m2eul(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_angle3;
   SpiceDouble        * vec_angle2;
   SpiceDouble        * vec_angle1;
   SpiceDouble        * r;
   SpiceInt             axis3;
   SpiceInt             axis2;
   SpiceInt             axis1;
   SpiceDouble        * angle3;
   SpiceDouble        * angle2;
   SpiceDouble        * angle1;

   SpiceDouble       xr[3][3];

   SpiceInt       i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 2, {3, 3}, 1},
      { "axis3",  MiceInt,    0, {0},    0},
      { "axis2",  MiceInt,    0, {0},    0},
      { "axis1",  MiceInt,    0, {0},    0},
      { "angle3", MiceDouble, 0, {0},    1},
      { "angle2", MiceDouble, 0, {0},    1},
      { "angle1", MiceDouble, 0, {0},    1},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);

   vec_angle3 = A_DBL_RET_ARGV(0);
   vec_angle2 = A_DBL_RET_ARGV(1);
   vec_angle1 = A_DBL_RET_ARGV(2);

   axis3  = S_INT_ARGV(2);
   axis2  = S_INT_ARGV(3);
   axis1  = S_INT_ARGV(4);
   angle3 = (vec_angle3);
   angle2 = (vec_angle2);
   angle1 = (vec_angle1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r      = (vec_r      + i*extra->offset[0]);
         angle3 = (vec_angle3 + i*extra->offset[4]);
         angle2 = (vec_angle2 + i*extra->offset[5]);
         angle1 = (vec_angle1 + i*extra->offset[6]);

         xpose_c( r, (SpiceDouble(*)[3])xr );

         m2eul_c( xr, axis3, axis2, axis1, angle3, angle2, angle1);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      r = vec_r;

      xpose_c( r, (SpiceDouble(*)[3])xr );

      m2eul_c( xr, axis3, axis2, axis1, angle3, angle2, angle1);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              m2q_c    ( ConstSpiceDouble    r[3][3],
                                SpiceDouble         q[4]     )
*/
void cspice_m2q(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_q;
   SpiceDouble        * r;
   SpiceDouble        * q;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",  MiceDouble, 2, {3, 3}, 1},
      { "q",  MiceDouble, 1, {4},    1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r = A_DBL_ARGV(1);
   vec_q = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         r = (vec_r + i*extra->offset[0]);
         q = (vec_q + i*extra->offset[1]);

         xpose_c( r, (SpiceDouble(*)[3])xr );

         m2q_c( xr, q);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      r = (vec_r);
      q = (vec_q);

      xpose_c( r, (SpiceDouble(*)[3])xr );

      m2q_c( xr, q );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              namfrm_c ( ConstSpiceChar    * frname,
                                SpiceInt          * frcode );
*/
void cspice_namfrm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            str[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_str;
   SpiceInt           * frcode;
   SpiceInt           * vec_frcode;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "frname", MiceChar, 0, {0}, 1},
      { "frcode", MiceInt,  0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_frcode = A_INT_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_str = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            str[j] = (char)mx_str[i + (extra->count*j)];
            }

         str[extra->offset[0]] = '\0';
         frcode                = (vec_frcode+i*extra->offset[1]);

         namfrm_c(str, frcode);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], str, DEFAULT_STR_LENGTH);

      frcode = vec_frcode;

      namfrm_c(str, frcode);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              nearpt_c ( ConstSpiceDouble    positn[3],
                                SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                SpiceDouble         npoint[3],
                                SpiceDouble       * alt        );
*/
void mice_nearpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * vec_positn;
   SpiceDouble  * positn;
   SpiceDouble    a;
   SpiceDouble    b;
   SpiceDouble    c;
   SpiceDouble    npoint[3];
   SpiceDouble    alt;

   SpiceInt       i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "positn", MiceDouble, 1, {3}, 1},
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "npoint", MiceNear,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_positn = A_DBL_ARGV(1);

   a = S_DBL_ARGV(2);
   b = S_DBL_ARGV(3);
   c = S_DBL_ARGV(4);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         positn = (vec_positn + i*extra->offset[0]);

         nearpt_c(positn, a, b, c, npoint, &alt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and altitude values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos" ) ),
                 npoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "alt" ) );
         mxSetField( plhs[0], i, "alt", mxCreateDoubleScalar(alt) );

         }

      }
   else
      {

      positn = vec_positn;

      nearpt_c(positn, a, b, c, npoint, &alt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the position and altitude values into the 0 structure element.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
              npoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
      mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(alt) );

      }

   }




/*
   void              npedln_c ( SpiceDouble         a,
                                SpiceDouble         b,
                                SpiceDouble         c,
                                ConstSpiceDouble    linept[3],
                                ConstSpiceDouble    linedr[3],
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      );
*/
void mice_npedln(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    a;
   SpiceDouble    b;
   SpiceDouble    c;
   SpiceDouble  * linept;
   SpiceDouble  * linedr;
   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "linept", MiceDouble, 1, {3}, 0},
      { "linedr", MiceDouble, 1, {3}, 0},
      { "npoint", MiceNear,   0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = S_DBL_ARGV(1);
   b = S_DBL_ARGV(2);
   c = S_DBL_ARGV(3);

   linept = A_DBL_ARGV(4);
   linedr = A_DBL_ARGV(5);

   npedln_c ( a, b, c, linept, linedr, pnear, &dist );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void              npelpt_c ( ConstSpiceDouble    point[3],
                                ConstSpiceEllipse * ellips,
                                SpiceDouble         pnear[3],
                                SpiceDouble       * dist      );
*/
void mice_npelpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * point;
   SpiceEllipse   ellipse;

   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "point",   MiceDouble,  1, {3}, 0},
      { "ellipse", MiceEllipse, 0, {0}, 0},
      { "npoint",  MiceNear,    0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point = A_DBL_ARGV(1);

   memcpy( ellipse.center,
           mxGetPr( mxGetField( prhs[2], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellipse.semiMajor,
           mxGetPr( mxGetField( prhs[2], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( ellipse.semiMinor,
           mxGetPr( mxGetField( prhs[2], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );

   npelpt_c ( point, &ellipse, pnear, &dist);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0], 0,"pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void              nplnpt_c ( ConstSpiceDouble    linpt  [3],
                                ConstSpiceDouble    lindir [3],
                                ConstSpiceDouble    point  [3],
                                SpiceDouble         pnear  [3],
                                SpiceDouble       * dist       );
*/
void mice_nplnpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * linpt;
   SpiceDouble  * lindir;
   SpiceDouble  * point;
   SpiceDouble    pnear[3];
   SpiceDouble    dist;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "linpt",  MiceDouble, 1, {3}, 0},
      { "lindir", MiceDouble, 1, {3}, 0},
      { "point",  MiceDouble, 1, {3}, 0},
      { "npoint", MiceNear,   0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   linpt  = A_DBL_ARGV(1);
   lindir = A_DBL_ARGV(2);
   point  = A_DBL_ARGV(3);

   nplnpt_c ( linpt, lindir, point, pnear, &dist );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the position and altitude values into the 0 structure element.
   */
   memcpy( mxGetPr( mxGetField(plhs[0], 0, "pos" ) ),
           pnear,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
   mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(dist) );

   }




/*
   void              nvc2pl_c ( ConstSpiceDouble    normal[3],
                                SpiceDouble         constant,
                                SpicePlane        * plane     )

*/
void cspice_nvc2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * normal;
   SpiceDouble          constant;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "normal",   MiceDouble, 1, {3}, 0},
      { "constant", MiceDouble, 0, {0}, 0},
      { "plane",    MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   normal   = A_DBL_ARGV(1);
   constant = S_DBL_ARGV(2);

   nvc2pl_c ( normal, constant,  &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void              nvp2pl_c ( ConstSpiceDouble    normal[3],
                                ConstSpiceDouble    point[3],
                                SpicePlane        * plane     );

*/
void cspice_nvp2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * normal;
   SpiceDouble        * point;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "normal", MiceDouble, 1, {3}, 0},
      { "point",  MiceDouble, 1, {3}, 0},
      { "plane",  MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   normal = A_DBL_ARGV(1);
   point  = A_DBL_ARGV(2);

   nvp2pl_c ( normal, point,  &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void occult_c ( ConstSpiceChar   * target1,
                   ConstSpiceChar   * shape1,
                   ConstSpiceChar   * frame1,
                   ConstSpiceChar   * target2,
                   ConstSpiceChar   * shape2,
                   ConstSpiceChar   * frame2,
                   ConstSpiceChar   * abcorr,
                   ConstSpiceChar   * observer,
                   SpiceDouble        time,
                   SpiceInt         * occult_code )
*/
void cspice_occult(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            target1 [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame1  [DEFAULT_STR_LENGTH+1];
   SpiceChar            target2 [DEFAULT_STR_LENGTH+1];
   SpiceChar            shape2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            frame2  [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr  [DEFAULT_STR_LENGTH+1];
   SpiceChar            observer[DEFAULT_STR_LENGTH+1];

   SpiceDouble        * time;
   SpiceDouble        * vec_time;

   SpiceInt             i;
   SpiceInt           * occult_code;
   SpiceInt           * vec_occult_code;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target1",      MiceChar,   0, {0}, 0},
      { "shape1",       MiceChar,   0, {0}, 0},
      { "frame1",       MiceChar,   0, {0}, 0},
      { "target2",      MiceChar,   0, {0}, 0},
      { "shape2",       MiceChar,   0, {0}, 0},
      { "frame2",       MiceChar,   0, {0}, 0},
      { "abcorr",       MiceChar,   0, {0}, 0},
      { "observer",     MiceChar,   0, {0}, 0},
      { "time",         MiceDouble, 0, {0}, 1},
      { "occult_code",  MiceInt,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target1,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], shape1,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], frame1,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], target2,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], shape2,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], frame2,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr,   DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], observer, DEFAULT_STR_LENGTH);

   vec_time  = A_DBL_ARGV(9);
   vec_occult_code = A_INT_RET_ARGV(0);

   time        = (vec_time);
   occult_code = (vec_occult_code);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         time        = (vec_time         + i*extra->offset[8]);
         occult_code = (vec_occult_code  + i*extra->offset[9]);

         occult_c ( target1, shape1, frame1,
                    target2, shape2, frame2,
                    abcorr,  observer, *time, occult_code );

         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      occult_c ( target1, shape1, frame1,
                 target2, shape2, frame2,
                 abcorr,  observer, *time, occult_code );

      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              oscelt_c ( ConstSpiceDouble    state[6],
                                SpiceDouble         et,
                                SpiceDouble         mu,
                                SpiceDouble         elts[8]  );
*/
void cspice_oscelt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_state;
   SpiceDouble        * vec_et;
   SpiceDouble        * vec_elts;
   SpiceDouble        * state;
   SpiceDouble          et;
   SpiceDouble          mu;
   SpiceDouble        * elts;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "state", MiceDouble, 1, {6}, 1},
      { "et",    MiceDouble, 0, {0}, 1},
      { "mu",    MiceDouble, 0, {0}, 0},
      { "elts",  MiceDouble, 1, {8}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_state = A_DBL_ARGV(1);
   vec_et    = A_DBL_ARGV(2);
   mu        = S_DBL_ARGV(3);
   vec_elts  = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         state =  (vec_state + i*extra->offset[0]);
         et    = *(vec_et    + i*extra->offset[1]);
         elts  =  (vec_elts  + i*extra->offset[3]);

         oscelt_c(state, et, mu, elts);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      state =  (vec_state);
      et    = *(vec_et);
      elts  =  (vec_elts);

      oscelt_c(state, et, mu, elts);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              pcpool_c ( ConstSpiceChar   * name,
                                SpiceInt           n,
                                SpiceInt           lenvals,
                                const void        * cvals    );

*/
void cspice_pcpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   MAXCHR and MAXLEN defined in cspice_params.h.
   */
   SpiceChar            name[MAXLEN + 1];
   SpiceChar            str [MAXCHR + 1];
   SpiceChar         ** cvals = NULL;
   SpiceInt             cvals_len;
   SpiceInt             cvals_size;

   mxChar             * mx_str;

   SpiceInt             i;
   SpiceInt             j;
   SpiceInt             count;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, {0}, 0},
      { "cvals", MiceChar, 0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   /*
   The following logic differs slightly from other string input arguments.
   A pcpool_c input may consist of an array of strings, where the array
   defines either a single string or an array or strings.

   Recall, extra->count == 0 for scalar inputs. A scalar string requires
   count as 1 (Is this a bug or design failure? EDW)
   */
   if (extra->count>1)
      {
      count = extra->count;
      }
   else
      {
      count = 1;
      }

   mx_str = (mxChar *)mxGetChars(prhs[2]);

   /*
   A string pcpool_c input string has at most MAXCHR characters
   so the maximum room needed is either extra->offset[i] if that
   value less than MAXCHAR or MAXCHAR + 1 (for \n).
   */
   if( extra->offset[1] > MAXCHR )
      {
      cvals_len  = MAXCHR + 1;
      }
   else
      {
      cvals_len  = extra->offset[1] + 1;
      }

   cvals_size = count;
   cvals      = alloc_SpiceString_C_array( cvals_len, cvals_size );

   CHECK_CALL_FAILURE( SCALAR );

   for ( i=0; i<count; i++)
      {

      /*
      Extract the string data, character by character, into
      CSPICE strings. The mx_str array stores the data in a column
      major format, we need to extract the data by rows.
      */
      for ( j=0; j<cvals_len - 1; j++)
         {
         str[j] = (char)mx_str[i + (count*j)];
         }

      str[cvals_len - 1] = '\0';

      strncpy( *cvals + i*cvals_len,
               str,
               cvals_len);
      }

   pcpool_c(name,cvals_size,cvals_len,*cvals);
   CHECK_CALL_FAILURE_MEM( 1, cvals );

   /* Clean up temporary variables */
   free_SpiceString_C_array ( 1, cvals );

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              pdpool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceDouble  * dvals );
*/
void cspice_pdpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN + 1];
   SpiceDouble        * dvals;

   SpiceInt             dvals_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar,   0, {0}, 0},
      { "dvals", MiceDouble, 1, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   dvals      = (SpiceDouble*)mxGetData(prhs[2]);
   dvals_size = mxGetNumberOfElements( prhs[2] );

   pdpool_c( name, dvals_size, dvals );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              pgrrec_c ( ConstSpiceChar    * body,
                                SpiceDouble         lon,
                                SpiceDouble         lat,
                                SpiceDouble         alt,
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble         rectan[3] );
*/
void cspice_pgrrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * vec_rectan;
   SpiceDouble          lon;
   SpiceDouble          lat;
   SpiceDouble          alt;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * rectan;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );
   vec_lon    = A_DBL_ARGV(2);
   vec_lat    = A_DBL_ARGV(3);
   vec_alt    = A_DBL_ARGV(4);
   re         = S_DBL_ARGV(5);
   f          = S_DBL_ARGV(6);
   vec_rectan = A_DBL_RET_ARGV(0);

   lon        = *(vec_lon);
   lat        = *(vec_lat);
   alt        = *(vec_alt);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         lon    = *(vec_lon    + i*extra->offset[1]);
         lat    = *(vec_lat    + i*extra->offset[2]);
         alt    = *(vec_alt    + i*extra->offset[3]);
         rectan =  (vec_rectan + i*extra->offset[6]);

         pgrrec_c(body, lon, lat, alt, re, f, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      pgrrec_c(body, lon, lat, alt, re, f, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       phaseq_c ( SpiceDouble       et,
                                ConstSpiceChar  * target,
                                ConstSpiceChar  * illumn,
                                ConstSpiceChar  * obsrvr,
                                ConstSpiceChar  * abcorr );

*/
void cspice_phaseq(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          et;
   SpiceDouble        * vec_et;
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            illumn[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;
   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "target", MiceChar,   0, {0}, 0},
      { "illumn", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "phase",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], illumn, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et     + i*extra->offset[0]);
         retval =  (vec_retval + i*extra->offset[5]);

         *retval = phaseq_c ( et, target, illumn, obsrvr, abcorr );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      et     = *vec_et;
      retval = vec_retval;

      *retval =  phaseq_c ( et, target, illumn, obsrvr, abcorr );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              pipool_c ( ConstSpiceChar    * name,
                                SpiceInt            n,
                                ConstSpiceInt     * ivals );
*/
void cspice_pipool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            name [MAXLEN + 1];
   SpiceInt           * ivals;

   SpiceInt             ivals_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "name",  MiceChar, 0, {0}, 0},
      { "ivals", MiceInt,  1, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], name, MAXLEN);

   ivals      = (SpiceInt*)mxGetData(prhs[2]);
   ivals_size = mxGetNumberOfElements( prhs[2] );

   pipool_c( name, ivals_size, ivals );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble       pi_c( void )
*/
void cspice_pi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( pi_c() );
   }




/*
   void              pjelpl_c ( ConstSpiceEllipse * elin,
                                ConstSpicePlane   * plane,
                                SpiceEllipse      * elout  );
*/
void mice_pjelpl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceEllipse   elin;
   SpicePlane     plane;
   SpiceEllipse   elout;


   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "elin",  MiceEllipse, 0, {0}, 0},
      { "plane", MicePlane,   0, {0}, 0},
      { "elout", MiceEllipse, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   /*
   Assemble an ellipse structure from the input arguments.
   */
   memcpy( elin.center,
           mxGetPr( mxGetField( prhs[1], 0,"center") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( elin.semiMajor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMajor") ),
           3*sizeof(SpiceDouble)
         );

   memcpy( elin.semiMinor,
           mxGetPr( mxGetField( prhs[1], 0,"semiMinor") ),
           3*sizeof(SpiceDouble)
         );


   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );


   pjelpl_c ( &elin, &plane, &elout  );
   CHECK_CALL_FAILURE(SCALAR);


   memcpy( mxGetPr( mxGetField( plhs[0], 0,"center") ),
           elout.center,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMajor") ),
           elout.semiMajor,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"semiMinor") ),
           elout.semiMinor,
           3*sizeof(SpiceDouble)
         );

   }




/*
   void              pl2nvc_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble       * constant  );
*/
void cspice_pl2nvc(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * normal;
   SpiceDouble        * constant;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane",     MicePlane,  0, {0}, 0},
      { "normal",    MiceDouble, 1, {3}, 0},
      { "constant",  MiceDouble, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0,"constant") );

   normal   = A_DBL_RET_ARGV(0);
   constant = A_DBL_RET_ARGV(1);

   pl2nvc_c ( &plane, normal, constant );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              pl2nvp_c ( ConstSpicePlane   * plane,
                                SpiceDouble         normal[3],
                                SpiceDouble         point[3]  );
*/
void cspice_pl2nvp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * normal;
   SpiceDouble        * point;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane",     MicePlane,  0, {0}, 0},
      { "normal",    MiceDouble, 1, {3}, 0},
      { "point",     MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0,"constant") );

   normal = A_DBL_RET_ARGV(0);
   point  = A_DBL_RET_ARGV(1);

   pl2nvp_c ( &plane, normal, point );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              pl2psv_c ( ConstSpicePlane   * plane,
                                SpiceDouble         point[3],
                                SpiceDouble         span1[3],
                                SpiceDouble         span2[3]  );
*/
void cspice_pl2psv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpicePlane           plane;
   SpiceDouble        * point;
   SpiceDouble        * span1;
   SpiceDouble        * span2;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "plane", MicePlane,  0, {0}, 0},
      { "point", MiceDouble, 1, {3}, 0},
      { "span1", MiceDouble, 1, {3}, 0},
      { "span2", MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[1], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[1], 0,"constant") );

   point = A_DBL_RET_ARGV(0);
   span1 = A_DBL_RET_ARGV(1);
   span2 = A_DBL_RET_ARGV(2);

   pl2psv_c ( &plane, point, span1, span2 );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              psv2pl_c ( ConstSpiceDouble    point[3],
                                ConstSpiceDouble    span1[3],
                                ConstSpiceDouble    span2[3],
                                SpicePlane        * plane     );
*/
void cspice_psv2pl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * point;
   SpiceDouble        * span1;
   SpiceDouble        * span2;
   SpicePlane           plane;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "point", MiceDouble, 1, {3}, 0},
      { "span1", MiceDouble, 1, {3}, 0},
      { "span2", MiceDouble, 1, {3}, 0},
      { "plane", MicePlane,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point = A_DBL_ARGV(1);
   span1 = A_DBL_ARGV(2);
   span2 = A_DBL_ARGV(3);

   psv2pl_c ( point, span1, span2, &plane );
   CHECK_CALL_FAILURE( SCALAR );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"normal") ),
           plane.normal,
           3*sizeof(SpiceDouble)
         );

   memcpy( mxGetPr( mxGetField( plhs[0], 0,"constant") ),
           &(plane.constant),
           sizeof(SpiceDouble)
         );

   }




/*
   void              pxform_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         et,
                                SpiceDouble         rotate[3][3] );
 */
void cspice_pxform(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_rotate;
   SpiceChar            from  [DEFAULT_STR_LENGTH+1];
   SpiceChar            to    [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * rotate;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "from",   MiceChar,   0, {0},    0},
      { "to",     MiceChar,   0, {0},    0},
      { "et",     MiceDouble, 0, {0},    1},
      { "rotate", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

   vec_et     = A_DBL_ARGV(3);
   vec_rotate = A_DBL_RET_ARGV(0);
   et         = *(vec_et);
   rotate     =  (vec_rotate);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         et     = *(vec_et     + i*extra->offset[2]);
         rotate =  (vec_rotate + i*extra->offset[3]);

         pxform_c(from, to, et, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rotate );
         }

      }
   else
      {

      pxform_c(from, to, et, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rotate );
      }

   }




/*
   void              pxfrm2_c ( ConstSpiceChar    * from,
                                ConstSpiceChar    * to,
                                SpiceDouble         etfrom,
                                SpiceDouble         etto,
                                SpiceDouble         rotate[3][3] );
 */
void cspice_pxfrm2(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_etfrom;
   SpiceDouble        * vec_etto;
   SpiceDouble        * vec_rotate;
   SpiceChar            from  [DEFAULT_STR_LENGTH+1];
   SpiceChar            to    [DEFAULT_STR_LENGTH+1];
   SpiceDouble          etfrom;
   SpiceDouble          etto;
   SpiceDouble        * rotate;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
   /*                          dimension, shape, vectorized */
      {
      { "from",    MiceChar,   0, {0},    0},
      { "to",      MiceChar,   0, {0},    0},
      { "etfrom",  MiceDouble, 0, {0},    1},
      { "etto",    MiceDouble, 0, {0},    1},
      { "rotate",  MiceDouble, 2, {3, 3}, 1},
      };

   /* check_arg_num checks to see if the number of input and output
      arguments specified by the user are correct. */

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /* extra-> offset corresponds to argcheck table from[0]*/

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

    /* From function inputs.  Function is [0]*/
   vec_etfrom   = A_DBL_ARGV(3);
   vec_etto     = A_DBL_ARGV(4);
   vec_rotate   = A_DBL_RET_ARGV(0);
   etfrom       = *(vec_etfrom);
   etto         = *(vec_etto);
   rotate       =  (vec_rotate);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         etfrom = *(vec_etfrom + i*extra->offset[2]);
         etto   = *(vec_etto   + i*extra->offset[3]);
         rotate =  (vec_rotate + i*extra->offset[4]);

         pxfrm2_c(from, to, etfrom, etto, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rotate );
         }

      }
   else
      {

      pxfrm2_c(from, to, etfrom, etto, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rotate );
      }

   }




/*
   void        q2m_c( ConstSpiceDouble  q[4],
                      SpiceDouble       r[3][3] )
*/
void cspice_q2m(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_q;
   SpiceDouble        * vec_r;
   SpiceDouble        * q;
   SpiceDouble        * r;
   SpiceDouble          xr[3][3];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "q", MiceDouble, 1, {4},    1},
      { "r", MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_q = A_DBL_ARGV(1);
   vec_r = A_DBL_RET_ARGV(0);
   q     = vec_q;
   r     = vec_r;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         q =  (vec_q+i*extra->offset[0]);
         r =  (vec_r+i*extra->offset[1]);

         q2m_c(q, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])r );
         }

      }
   else
      {

      q2m_c(q, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])r );
      }

   }




/*
   void              rav2xf_c ( ConstSpiceDouble     rot   [3][3],
                                ConstSpiceDouble     av    [3],
                                SpiceDouble          xform [6][6]  );
*/
void cspice_rav2xf(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble  * vec_rot;
   SpiceDouble  * vec_av;
   SpiceDouble  * vec_xform;
   SpiceDouble  * rot;
   SpiceDouble  * av;
   SpiceDouble  * xform;
   SpiceDouble    xr[3][3];
   SpiceDouble    xf[6][6];

   SpiceInt       i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "rot",   MiceDouble, 2, {3,3}, 1},
      { "av",    MiceDouble, 1, {3},   1},
      { "xform", MiceDouble, 2, {6,6}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rot   = A_DBL_ARGV(1);
   vec_av    = A_DBL_ARGV(2);
   vec_xform = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rot   = (vec_rot    + i*extra->offset[0]);
         av    = (vec_av     + i*extra->offset[1]);
         xform = (vec_xform  + i*extra->offset[2]);

         xpose_c( rot, (SpiceDouble(*)[3])xr );

         rav2xf_c( xr, av, (SpiceDouble(*)[6])xf);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xf, (SpiceDouble(*)[6])xform  );
         }

      }
   else
      {

      rot   = (vec_rot);
      av    = (vec_av);
      xform = (vec_xform);

      xpose_c( rot, (SpiceDouble(*)[3])xr );

      rav2xf_c( xr, av, (SpiceDouble(*)[6])xf);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xf, (SpiceDouble(*)[6])xform  );
      }

   }




/*
   void              raxisa_c( ConstSpiceDouble     matrix[3][3],
                               SpiceDouble          axis  [3],
                               SpiceDouble        * angle       );

*/
void cspice_raxisa(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble  * matrix;
   SpiceDouble  * axis;
   SpiceDouble  * angle;
   SpiceDouble    xr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",     MiceDouble, 2, {3, 3}, 0},
      { "axis",  MiceDouble, 1, {3},    0},
      { "angle", MiceDouble, 0, {0},    0},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   matrix = A_DBL_ARGV(1);
   axis   = A_DBL_RET_ARGV(0);
   angle  = A_DBL_RET_ARGV(1);

   xpose_c( matrix, (SpiceDouble(*)[3])xr );
   raxisa_c( xr, axis, angle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              radrec_c ( SpiceDouble         range,
                                SpiceDouble         ra,
                                SpiceDouble         dec,
                                SpiceDouble         rectan[3] );
*/
void cspice_radrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_range;
   SpiceDouble        * vec_ra;
   SpiceDouble        * vec_dec;
   SpiceDouble        * vec_rectan;
   SpiceDouble          range;
   SpiceDouble          ra;
   SpiceDouble          dec;
   SpiceDouble        * rectan;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "range",   MiceDouble, 0, {0}, 1},
      { "ra",      MiceDouble, 0, {0}, 1},
      { "dec",     MiceDouble, 0, {0}, 1},
      { "rectan",  MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_range  = A_DBL_ARGV(1);
   vec_ra     = A_DBL_ARGV(2);
   vec_dec    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);
   range      = *(vec_range);
   ra         = *(vec_ra);
   dec        = *(vec_dec);
   rectan     =  (vec_rectan);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         range  = *(vec_range  + i*extra->offset[0]);
         ra     = *(vec_ra     + i*extra->offset[1]);
         dec    = *(vec_dec    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         radrec_c( range, ra, dec, rectan);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      radrec_c( range, ra, dec, rectan);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
   void              reccyl_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * lon,
                                SpiceDouble       * z         );
*/
void cspice_reccyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * vec_rectan;
   SpiceDouble       * vec_r;
   SpiceDouble       * vec_lon;
   SpiceDouble       * vec_z;
   SpiceDouble       * rectan;
   SpiceDouble       * r;
   SpiceDouble       * lon;
   SpiceDouble       * z;

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);
   rectan     = vec_rectan;
   r          = vec_r;
   lon        = vec_lon;
   z          = vec_z;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         r      =  (vec_r      + i*extra->offset[1]);
         lon    =  (vec_lon    + i*extra->offset[2]);
         z      =  (vec_z      + i*extra->offset[3]);

         reccyl_c(rectan, r, lon, z);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      reccyl_c(rectan, r, lon, z);
      CHECK_CALL_FAILURE(SCALAR); ;

      }

   }




/*
   void              recgeo_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat,
                                SpiceDouble       * alt );
*/
void cspice_recgeo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble   * vec_rectan;
   SpiceDouble   * vec_lon;
   SpiceDouble   * vec_lat;
   SpiceDouble   * vec_alt;
   SpiceDouble   * rectan;
   SpiceDouble     re;
   SpiceDouble     f;
   SpiceDouble   * lon;
   SpiceDouble   * lat;
   SpiceDouble   * alt;

   SpiceInt        i;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_lon    = A_DBL_RET_ARGV(0);
   vec_lat    = A_DBL_RET_ARGV(1);
   vec_alt    = A_DBL_RET_ARGV(2);
   re         = S_DBL_ARGV(2);
   f          = S_DBL_ARGV(3);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         lon    =  (vec_lon    + i*extra->offset[3]);
         lat    =  (vec_lat    + i*extra->offset[4]);
         alt    =  (vec_alt    + i*extra->offset[5]);

         recgeo_c(rectan, re, f, lon, lat, alt);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      rectan = vec_rectan;
      lon    = vec_lon;
      lat    = vec_lat;
      alt    = vec_alt;

      recgeo_c(rectan, re, f, lon, lat, alt);
      CHECK_CALL_FAILURE(SCALAR); ;

      }

   }




/*
   void              reclat_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * longitude,
                                SpiceDouble       * latitude  );
*/
void cspice_reclat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_longitude;
   SpiceDouble        * vec_latitude;
   SpiceDouble        * rectan;
   SpiceDouble        * radius;
   SpiceDouble        * longitude;
   SpiceDouble        * latitude;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan",    MiceDouble, 1, {3}, 1},
      { "radius",    MiceDouble, 0, {0}, 1},
      { "longitude", MiceDouble, 0, {0}, 1},
      { "latitude",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan    = A_DBL_ARGV(1);
   vec_radius    = A_DBL_RET_ARGV(0);
   vec_longitude = A_DBL_RET_ARGV(1);
   vec_latitude  = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan    =  (vec_rectan    + i*extra->offset[0]);
         radius    =  (vec_radius    + i*extra->offset[1]);
         longitude =  (vec_longitude + i*extra->offset[2]);
         latitude  =  (vec_latitude  + i*extra->offset[3]);

         reclat_c(rectan, radius, longitude, latitude);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      rectan    = vec_rectan;
      radius    = vec_radius;
      longitude = vec_longitude;
      latitude  = vec_latitude;

      reclat_c(rectan, radius, longitude, latitude);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              recpgr_c ( ConstSpiceChar    * body,
                                SpiceDouble         rectan[3],
                                SpiceDouble         re,
                                SpiceDouble         f,
                                SpiceDouble       * lon,
                                SpiceDouble       * lat,
                                SpiceDouble       * alt       );
*/
void cspice_recpgr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            body       [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble        * vec_alt;
   SpiceDouble        * rectan;
   SpiceDouble          re;
   SpiceDouble          f;
   SpiceDouble        * lon;
   SpiceDouble        * lat;
   SpiceDouble        * alt;

   SpiceInt             i;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceChar,   0, {0}, 0},
      { "rectan", MiceDouble, 1, {3}, 1},
      { "re",     MiceDouble, 0, {0}, 0},
      { "f",      MiceDouble, 0, {0}, 0},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      { "alt",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString( prhs[1], body, DEFAULT_STR_LENGTH );
   vec_rectan = A_DBL_ARGV(2);
   re         = S_DBL_ARGV(3);
   f          = S_DBL_ARGV(4);

   vec_lon    = A_DBL_RET_ARGV(0);
   vec_lat    = A_DBL_RET_ARGV(1);
   vec_alt    = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[1]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);
         alt    =  (vec_alt    + i*extra->offset[6]);

         recpgr_c(body, rectan, re, f, lon, lat, alt);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      rectan = vec_rectan;
      lon    = vec_lon;
      lat    = vec_lat;
      alt    = vec_alt;

      recpgr_c(body, rectan, re, f, lon, lat, alt);
      CHECK_CALL_FAILURE(SCALAR); ;

      }

   }





/*
   void              recrad_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * radius,
                                SpiceDouble       * ra,
                                SpiceDouble       * dec  );
*/
void cspice_recrad(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_range;
   SpiceDouble        * vec_ra;
   SpiceDouble        * vec_dec;
   SpiceDouble        * rectan;
   SpiceDouble        * range;
   SpiceDouble        * ra;
   SpiceDouble        * dec;

   SpiceInt             i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "range",  MiceDouble, 0, {0}, 1},
      { "ra",     MiceDouble, 0, {0}, 1},
      { "dec",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_range  =  A_DBL_RET_ARGV(0);
   vec_ra     =  A_DBL_RET_ARGV(1);
   vec_dec    =  A_DBL_RET_ARGV(2);
   rectan     =  vec_rectan;
   range      =  vec_range;
   ra         =  vec_ra;
   dec        =  vec_dec;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         rectan =  (vec_rectan + i*extra->offset[0]);
         range  =  (vec_range  + i*extra->offset[1]);
         ra     =  (vec_ra     + i*extra->offset[2]);
         dec    =  (vec_dec    + i*extra->offset[3]);

         recrad_c(rectan, range, ra, dec);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      recrad_c(rectan, range, ra, dec);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              recsph_c ( ConstSpiceDouble    rectan[3],
                                SpiceDouble       * r,
                                SpiceDouble       * colat,
                                SpiceDouble       * lon );
*/
void cspice_recsph(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_rectan;
   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_lon;
   SpiceDouble        * rectan;
   SpiceDouble        * r;
   SpiceDouble        * colat;
   SpiceDouble        * lon;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "rectan", MiceDouble, 1, {3}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_rectan = A_DBL_ARGV(1);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_colat  = A_DBL_RET_ARGV(1);
   vec_lon    = A_DBL_RET_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         rectan =  (vec_rectan + i*extra->offset[0]);
         r      =  (vec_r      + i*extra->offset[1]);
         colat  =  (vec_colat  + i*extra->offset[2]);
         lon    =  (vec_lon    + i*extra->offset[3]);

         recsph_c(rectan, r, colat, lon);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      rectan = vec_rectan;
      r      = vec_r;
      colat  = vec_colat;
      lon    = vec_lon;

      recsph_c(rectan, r, colat, lon);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble rpd_c( void )
*/
void cspice_rpd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( rpd_c() );
   }




/*
   void              rotate_c ( SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] );
*/
void cspice_rotate(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_angle;
   SpiceDouble        * vec_mout;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];

   SpiceInt       i;

   struct extra_dims *extra;

   struct argcheck ArgCheck[] =
      {
      { "angle", MiceDouble, 0, {0},    1},
      { "iaxis", MiceInt,    0, {0},    0},
      { "mout",  MiceDouble, 2, {3, 3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_angle = A_DBL_ARGV(1);
   vec_mout  = A_DBL_RET_ARGV(0);
   iaxis     =  S_INT_ARGV(2);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         angle = *(vec_angle + i*extra->offset[0]);
         mout  =  (vec_mout  + i*extra->offset[2]);

         rotate_c(angle, iaxis, (SpiceDouble(*)[3])xr);
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])mout);
         }

      }
   else
      {

      angle = *vec_angle;
      mout  = vec_mout;

      rotate_c(angle, iaxis, (SpiceDouble(*)[3])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])mout);
      }

   }




/*
   void              rotmat_c ( ConstSpiceDouble    m1[3][3],
                                SpiceDouble         angle,
                                SpiceInt            iaxis,
                                SpiceDouble         mout[3][3] );
*/
void cspice_rotmat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * m1;
   SpiceDouble          angle;
   SpiceInt             iaxis;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];
   SpiceDouble          yr[3][3];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "m1",    MiceDouble, 2, {3, 3}, 0},
      { "angle", MiceDouble, 0, {0},    0},
      { "iaxis", MiceInt,    0, {0},    0},
      { "mout",  MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   m1    = A_DBL_ARGV(1);
   angle = S_DBL_ARGV(2);
   iaxis = S_INT_ARGV(3);
   mout  = A_DBL_RET_ARGV(0);

   xpose_c( m1, (SpiceDouble(*)[3])yr);

   rotmat_c(yr, angle, iaxis, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mout);

   }




/*
   void              saelgv_c ( ConstSpiceDouble    vec1  [3],
                                ConstSpiceDouble    vec2  [3],
                                SpiceDouble         smajor[3],
                                SpiceDouble         sminor[3]  );
*/
void cspice_saelgv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec1;
   SpiceDouble        * vec2;
   SpiceDouble        * smajor;
   SpiceDouble        * sminor;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vec1",   MiceDouble,  1, {3}, 0},
      { "vec2",   MiceDouble,  1, {3}, 0},
      { "smajor", MiceDouble,  1, {3}, 0},
      { "sminor", MiceDouble,  1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec1   = A_DBL_ARGV(1);
   vec2   = A_DBL_ARGV(2);
   smajor = A_DBL_RET_ARGV(0);
   sminor = A_DBL_RET_ARGV(1);

   saelgv_c ( vec1, vec2, smajor, sminor );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              scdecd_c ( SpiceInt            sc,
                                SpiceDouble         sclkdp,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   );
*/
void cspice_scdecd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceInt            sc;
   SpiceDouble         sclkdp;
   SpiceDouble       * vec_sclkdp;
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceChar           sclkch[DEFAULT_STR_LENGTH+1];

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      { "sclkch", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         sclkdp = *(vec_sclkdp+i*extra->offset[1]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         scdecd_c(sc, sclkdp, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      sclkdp = *(vec_sclkdp);

      scdecd_c(sc, sclkdp, DEFAULT_STR_LENGTH, sclkch);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( sclkch );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_scdecd" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              sce2c_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceDouble       * sclkdp   );
*/
void cspice_sce2c(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            sc;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceDouble       * sclkdp;
   SpiceDouble       * vec_sclkdp;

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_et     = A_DBL_ARGV(2);
   vec_sclkdp = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et+i*extra->offset[1]);
         sclkdp =  (vec_sclkdp+i*extra->offset[2]);

         sce2c_c(sc, et, sclkdp);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      et     = *(vec_et);
      sclkdp =  (vec_sclkdp);

      sce2c_c(sc, et, sclkdp);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              sce2s_c  ( SpiceInt            sc,
                                SpiceDouble         et,
                                SpiceInt            sclklen,
                                SpiceChar         * sclkch   );
*/
void cspice_sce2s(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt            sc;
   SpiceDouble         et;
   SpiceDouble       * vec_et;
   SpiceChar        ** cval;
   SpiceChar        ** array;
   SpiceChar           sclkch[DEFAULT_STR_LENGTH+1];

   SpiceInt            i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "sclkch", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc     = S_INT_ARGV(1);
   vec_et = A_DBL_ARGV(2);

   if (extra->count>1)
      {

      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      /*
      Test for a SPICE error signal, if found, display an error message to
      the user then return to the MATLAB application.
      */
      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[1]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         sce2s_c(sc, et, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed memory to plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      et = *(vec_et);

      sce2s_c(sc, et, DEFAULT_STR_LENGTH, sclkch);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( sclkch );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_scdecd" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   void              scencd_c ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * sclkdp   );
*/
void cspice_scencd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            sclkch[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_sclkch;
   SpiceDouble        * sclkdp;
   SpiceDouble        * vec_sclkdp;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkch", MiceChar,   0, {0}, 1},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_sclkch = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            sclkch[j] = (char)mx_sclkch[i + (extra->count*j)];
            }

         sclkch[extra->offset[1]] = '\0';
         sclkdp                   = (vec_sclkdp+i*extra->offset[2]);

         scencd_c(sc, sclkch, sclkdp);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], sclkch, DEFAULT_STR_LENGTH);

      sclkdp = vec_sclkdp;

      scencd_c(sc, sclkch, sclkdp);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              scs2e_c  ( SpiceInt            sc,
                                ConstSpiceChar    * sclkch,
                                SpiceDouble       * et      );
*/
void cspice_scs2e(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            sclkch[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_sclkch;
   SpiceDouble        * vec_et;
   SpiceDouble        * et;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkch", MiceChar,   0, {0}, 1},
      { "et",     MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc     = S_INT_ARGV(1);
   vec_et = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_sclkch = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            sclkch[j] = (char)mx_sclkch[i + (extra->count*j)];
            }

         sclkch[extra->offset[1]] = '\0';
         et                       =  (vec_et+i*extra->offset[2]);

         scs2e_c(sc, sclkch, et);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], sclkch, DEFAULT_STR_LENGTH);

      et = (vec_et);

      scs2e_c(sc, sclkch, et);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void sct2e_c( SpiceInt       sc,
                  SpiceDouble    sclkdp,
                  SpiceDouble  * et     )
*/
void cspice_sct2e(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceDouble          sclkdp;
   SpiceDouble        * vec_sclkdp;
   SpiceDouble        * et;
   SpiceDouble        * vec_et;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,    0, {0}, 0},
      { "sclkdp", MiceDouble, 0, {0}, 1},
      { "et",     MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_sclkdp = A_DBL_ARGV(2);
   vec_et     = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         sclkdp = *(vec_sclkdp + i*extra->offset[1]);
         et     =  (vec_et     + i*extra->offset[2]);

         sct2e_c(sc, sclkdp, et);
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      sclkdp = *(vec_sclkdp);
      et     =  (vec_et);

      sct2e_c(sc, sclkdp, et);
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*

   void              sctiks_c ( SpiceInt            sc,
                                ConstSpiceChar    * clkstr,
                                SpiceDouble       * ticks   );
*/
void cspice_sctiks(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             sc;
   SpiceChar            clkstr[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_clkstr;
   SpiceDouble        * ticks;
   SpiceDouble        * vec_ticks;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sc",     MiceInt,   0, {0}, 0},
      { "clkstr", MiceChar,  0, {0}, 1},
      { "ticks", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sc         = S_INT_ARGV(1);
   vec_ticks = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_clkstr = (mxChar *)mxGetChars(prhs[2]);

      for (i=0;i<extra->count;i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for (j=0;j<extra->offset[1];j++)
            {
            clkstr[j] = (char)mx_clkstr[i + (extra->count*j)];
            }

         clkstr[extra->offset[1]] = '\0';
         ticks                   = (vec_ticks+i*extra->offset[2]);

         sctiks_c(sc, clkstr, ticks);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[2], clkstr, DEFAULT_STR_LENGTH);

      ticks = vec_ticks;

      sctiks_c(sc, clkstr, ticks);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble spd_c( void )
*/
void cspice_spd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( spd_c() );
   }




/*
   void sphcyl_c( SpiceDouble     radius,
                   SpiceDouble     colat,
                   SpiceDouble     slon,
                   SpiceDouble   * r,
                   SpiceDouble   * lon,
                   SpiceDouble   * z )
*/
void cspice_sphcyl(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * vec_radius;
   SpiceDouble         * vec_colat;
   SpiceDouble         * vec_slon;
   SpiceDouble         * vec_r;
   SpiceDouble         * vec_lon;
   SpiceDouble         * vec_z;
   SpiceDouble           radius;
   SpiceDouble           colat;
   SpiceDouble           slon;
   SpiceDouble         * r;
   SpiceDouble         * lon;
   SpiceDouble         * z;

   SpiceInt              i;

   struct extra_dims   * extra;
   struct argcheck ArgCheck[] =
      {
      { "radius", MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "slon",   MiceDouble, 0, {0}, 1},
      { "r",      MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "z",      MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_radius = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_slon   = A_DBL_ARGV(3);
   vec_r      = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_z      = A_DBL_RET_ARGV(2);
   radius     = *vec_radius;
   colat      = *vec_colat;
   slon       = *vec_slon;
   r          =  vec_r;
   lon        =  vec_lon;
   z          =  vec_z;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         radius = *(vec_radius + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         slon   = *(vec_slon   + i*extra->offset[2]);
         r      =  (vec_r      + i*extra->offset[3]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         z      =  (vec_z      + i*extra->offset[5]);

         sphcyl_c(radius, colat, slon, r, lon, z);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      sphcyl_c(radius, colat, slon, r, lon, z);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              sincpt_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * fixref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceChar    * dref,
                                ConstSpiceDouble    dvec   [3],
                                SpiceDouble         spoint [3],
                                SpiceDouble       * trgepc,
                                SpiceDouble         srfvec [3],
                                SpiceBoolean      * found         );
*/
void mice_sincpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            dref  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * dvec;
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,    0, {0}, 0},
      { "target", MiceChar,    0, {0}, 0},
      { "et",     MiceDouble,  0, {0}, 0},
      { "fixref", MiceChar,    0, {0}, 0},
      { "abcorr", MiceChar,    0, {0}, 0},
      { "obsrvr", MiceChar,    0, {0}, 0},
      { "dref",   MiceChar,    0, {0}, 0},
      { "dvec",   MiceDouble,  1, {3}, 0},
      { "sincpt", MiceSurf_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 8,1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], dref,   DEFAULT_STR_LENGTH);

   dvec   = A_DBL_ARGV(8);

   sincpt_c (  method,
               target,
               et,
               fixref,
               abcorr,
               obsrvr,
               dref,
               dvec,
               spoint,
               &trgepc,
               srfvec,
               &found );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc));

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
              srfvec,
              3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
   void  sphlat_c( SpiceDouble     r,
                   SpiceDouble     colat,
                   SpiceDouble     lons,
                   SpiceDouble   * radius,
                   SpiceDouble   * lon,
                   SpiceDouble   * lat )
*/
void cspice_sphlat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_r;
   SpiceDouble        * vec_colat;
   SpiceDouble        * vec_lons;
   SpiceDouble        * vec_radius;
   SpiceDouble        * vec_lon;
   SpiceDouble        * vec_lat;
   SpiceDouble          r;
   SpiceDouble          colat;
   SpiceDouble          lons;
   SpiceDouble        * radius;
   SpiceDouble        * lon;
   SpiceDouble        * lat;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "lons",   MiceDouble, 0, {0}, 1},
      { "radius", MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "lat",    MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 3 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_lons   = A_DBL_ARGV(3);
   vec_radius = A_DBL_RET_ARGV(0);
   vec_lon    = A_DBL_RET_ARGV(1);
   vec_lat    = A_DBL_RET_ARGV(2);
   r          = *(vec_r);
   colat      = *(vec_colat);
   lons       = *(vec_lons);
   radius     =  (vec_radius);
   lon        =  (vec_lon);
   lat        =  (vec_lat);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         lons   = *(vec_lons   + i*extra->offset[2]);
         radius =  (vec_radius + i*extra->offset[3]);
         lon    =  (vec_lon    + i*extra->offset[4]);
         lat    =  (vec_lat    + i*extra->offset[5]);

         sphlat_c(r, colat, lons, radius, lon, lat);
         CHECK_CALL_FAILURE(i);
         }
      }
   else
      {

      sphlat_c(r, colat, lons, radius, lon, lat);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void sphrec_c( SpiceDouble    r,
                   SpiceDouble    colat,
                   SpiceDouble    lon,
                   SpiceDouble    rectan[3] )
*/
void cspice_sphrec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    * vec_r;
   SpiceDouble    * vec_colat;
   SpiceDouble    * vec_lon;
   SpiceDouble    * vec_rectan;
   SpiceDouble      r;
   SpiceDouble      colat;
   SpiceDouble      lon;
   SpiceDouble    * rectan;

   SpiceInt         i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "r",      MiceDouble, 0, {0}, 1},
      { "colat",  MiceDouble, 0, {0}, 1},
      { "lon",    MiceDouble, 0, {0}, 1},
      { "rectan", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_r      = A_DBL_ARGV(1);
   vec_colat  = A_DBL_ARGV(2);
   vec_lon    = A_DBL_ARGV(3);
   vec_rectan = A_DBL_RET_ARGV(0);

   r          = *vec_r;
   colat      = *vec_colat;
   lon        = *vec_lon;
   rectan     =  vec_rectan;

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {
         r      = *(vec_r      + i*extra->offset[0]);
         colat  = *(vec_colat  + i*extra->offset[1]);
         lon    = *(vec_lon    + i*extra->offset[2]);
         rectan =  (vec_rectan + i*extra->offset[3]);

         sphrec_c(r, colat, lon, rectan);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      sphrec_c(r, colat, lon, rectan);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              spkcls_c ( SpiceInt            handle );
*/
void cspice_spkcls(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0);

   extra  = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);

   spkcls_c( handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkcov_c ( ConstSpiceChar    * spk,
                                SpiceInt            idcode,
                                SpiceCell         * cover   );

*/
void cspice_spkcov(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           spk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_spk;

   SpiceInt            i;
   SpiceInt            j;
   int                 sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt            idcode;
   SpiceDouble       * cover_f;
   SpiceDouble       * cover;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "spk",    MiceChar,   0, {0}, 1},
      { "idcode", MiceInt,    0, {0}, 0},
      { "size",   MiceInt,    0, {0}, 0},
      { "cover",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   idcode = S_INT_ARGV(2);

   /*
   'size' defines the number of intervals for the workspace window,
   so double the value of size since an interval consists of
   two double precision values.
   */
   size   = S_INT_ARGV(3) * 2;

   cover  = (SpiceDouble*)
            mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) cover );
   scardd_( ( integer * ) &card, ( double * ) cover );

   if (extra->count>1)
      {

      mx_spk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            spk[j] = (char)mx_spk[i + (extra->count*j)];
            }

         spk[extra->offset[0]] = '\0';

         spkcov_( ( char       * ) spk,
                  ( integer    * ) &idcode,
                  ( doublereal * ) (cover),
                  ( ftnlen       ) strlen(spk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'cover'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( cover );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], spk, DEFAULT_STR_LENGTH);

      spkcov_(  ( char       * ) spk,
                ( integer    * ) &idcode,
                ( doublereal * ) (cover),
                ( ftnlen       ) strlen(spk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'cover'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( cover );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = cover[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   cover_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( cover + SPICE_CELL_CTRLSZ, cover[5], cover_f );
   mxFree( cover );
   }




/*
   void              spkcpo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * refloc,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obspos [3],
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt          );
*/
void mice_spkcpo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             target [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             refloc [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble         * obspos;
   SpiceChar             obsctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "refloc",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obspos",   MiceDouble, 1, { 3 },    0},
      { "obsctr",   MiceChar,   0, { 0 },    0},
      { "obsref",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 8, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(2);

   mxGetString(prhs[3], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], refloc, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   obspos = A_DBL_ARGV( 6 );

   mxGetString(prhs[7], obsctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsref, DEFAULT_STR_LENGTH);

   (void) spkcpo_c ( target,
                     et,
                     outref,
                     refloc,
                     abcorr,
                     obspos,
                     obsctr,
                     obsref,
                     state,
                     &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );
   }




/*
   void              spkcpt_c ( ConstSpiceDouble       trgpos [3],
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * evlref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
void mice_spkcpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * trgpos;
   SpiceChar             trgctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             trgref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             evlref [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trgpos",   MiceDouble, 1, { 3 },    0},
      { "trgctr",   MiceChar,   0, { 0 },    0},
      { "trgref",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "evlref",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obsrvr",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 8, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   trgpos = A_DBL_ARGV( 1 );

   mxGetString(prhs[2], trgctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], trgref, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(4);

   mxGetString(prhs[5], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], evlref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], obsrvr, DEFAULT_STR_LENGTH);

   (void) spkcpt_c ( trgpos,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obsrvr,
                     state,
                     &lt );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );
   }




/*
   void              spkcvo_c ( ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * outref,
                                ConstSpiceChar    * evlref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceDouble    obssta [6],
                                SpiceDouble         obsepc,
                                ConstSpiceChar    * obsctr,
                                ConstSpiceChar    * obsref,
                                SpiceDouble         state  [6],
                                SpiceDouble       * lt         );
*/
void mice_spkcvo(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar             target [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             evlref [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceDouble         * obssta;
   SpiceDouble           obsepc;
   SpiceChar             obsctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "target",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "evlref",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obssta",   MiceDouble, 1, { 6 },    0},
      { "obsepc",   MiceDouble, 0, { 0 },    0},
      { "obsctr",   MiceChar,   0, { 0 },    0},
      { "obsref",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], target, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(2);

   mxGetString(prhs[3], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], evlref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);

   obssta = A_DBL_ARGV(6);
   obsepc = S_DBL_ARGV(7);

   mxGetString(prhs[8], obsctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsref, DEFAULT_STR_LENGTH);

   (void) spkcvo_c ( target,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obssta,
                     obsepc,
                     obsctr,
                     obsref,
                     state,
                     &lt);
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );
   }




/*
   void              spkcvt_c ( ConstSpiceDouble       trgsta [6],
                                SpiceDouble            trgepc,
                                ConstSpiceChar       * trgctr,
                                ConstSpiceChar       * trgref,
                                SpiceDouble            et,
                                ConstSpiceChar       * outref,
                                ConstSpiceChar       * evlref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble          * state,
                                SpiceDouble          * lt        )
*/
void mice_spkcvt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         * trgsta;
   SpiceDouble           trgepc;
   SpiceChar             trgctr [DEFAULT_STR_LENGTH+1];
   SpiceChar             trgref [DEFAULT_STR_LENGTH+1];
   SpiceDouble           et;
   SpiceChar             outref [DEFAULT_STR_LENGTH+1];
   SpiceChar             evlref [DEFAULT_STR_LENGTH+1];
   SpiceChar             abcorr [DEFAULT_STR_LENGTH+1];
   SpiceChar             obsrvr [DEFAULT_STR_LENGTH+1];
   SpiceDouble           state [6];
   SpiceDouble           lt;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "trgsta",   MiceDouble, 1, { 6 },    0},
      { "trgepc",   MiceDouble, 0, { 0 },    0},
      { "trgctr",   MiceChar,   0, { 0 },    0},
      { "trgref",   MiceChar,   0, { 0 },    0},
      { "et",       MiceDouble, 0, { 0 },    0},
      { "outref",   MiceChar,   0, { 0 },    0},
      { "evlref",   MiceChar,   0, { 0 },    0},
      { "abcorr",   MiceChar,   0, { 0 },    0},
      { "obsrvr",   MiceChar,   0, { 0 },    0},
      { "state",    MiceState,  0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 9, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   trgsta = A_DBL_ARGV(1);
   trgepc = S_DBL_ARGV(2);

   mxGetString(prhs[3], trgctr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], trgref, DEFAULT_STR_LENGTH);

   et     = S_DBL_ARGV(5);

   mxGetString(prhs[6], outref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[7], evlref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[8], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[9], obsrvr, DEFAULT_STR_LENGTH);

   (void) spkcvt_c ( trgsta,
                     trgepc,
                     trgctr,
                     trgref,
                     et,
                     outref,
                     evlref,
                     abcorr,
                     obsrvr,
                     state,
                     &lt  );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */
   memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
   mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );
   }




/*
   void spkezr_c(  ConstSpiceChar     *targ,
                   SpiceDouble         et,
                   ConstSpiceChar     *ref,
                   ConstSpiceChar     *abcorr,
                   ConstSpiceChar     *obs,
                   SpiceDouble         starg[6],
                   SpiceDouble        *lt        )
*/
void mice_spkezr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            targ  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obs   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          starg[6];
   SpiceDouble          lt;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",   MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "ref",    MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obs",    MiceChar,   0, {0}, 0},
      { "state",  MiceState,  0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);
   et     = *(vec_et);

   mxGetString(prhs[3], ref,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obs,    DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[1]);

         spkezr_c(targ, et, ref, abcorr, obs, starg, &lt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the state and light time values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"state") ),
                 starg,
                 6*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "lt" ) );
         mxSetField( plhs[0], i, "lt", mxCreateDoubleScalar(lt) );

         }

      }
   else
      {

      spkezr_c(targ, et, ref, abcorr, obs, starg, &lt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the state vector and the lighttime value into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"state") ),
              starg,
              6*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
      mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

      }

   }




/*
   void              spkobj_c ( ConstSpiceChar    * spk,
                                SpiceCell         * ids );

*/
void cspice_spkobj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceChar           spk[DEFAULT_STR_LENGTH+1];
   mxChar            * mx_spk;

   SpiceInt            i;
   SpiceInt            j;
   int                 sizearray[2];

   SpiceInt            card = 0;
   SpiceInt            size;
   SpiceInt          * ids_f;
   SpiceInt          * ids;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "spk",  MiceChar,   0, {0}, 1},
      { "size", MiceInt,    0, {0}, 0},
      { "ids",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   size = S_INT_ARGV(2);
   ids  = (SpiceInt*)mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceInt)  );

   ssizei_( ( integer * ) &size, ( integer * ) ids   );
   scardi_( ( integer * ) &card, ( integer * ) ids   );

   if (extra->count>1)
      {

      mx_spk = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            spk[j] = (char)mx_spk[i + (extra->count*j)];
            }

         spk[extra->offset[0]] = '\0';

         spkobj_(  ( char       * ) spk,
                   ( integer    * ) (ids),
                   ( ftnlen       ) strlen(spk)   );

         /*
         Check for a failure signal. Free the memory assigned to 'ids'
         before signaling a Matlab error.
         */
         if ( failed_c())
            {
            mxFree( ids );

            /*
            The mice_fail call creates the error string then returns control
            to the MATLAB interpreter.
            */
            mice_fail(i);
            }

         }

      }
   else
      {
      mxGetString(prhs[1], spk, DEFAULT_STR_LENGTH);

      spkobj_(  ( char       * ) spk,
                ( integer    * ) (ids),
                ( ftnlen       ) strlen(spk)   );

      /*
      Check for a failure signal. Free the memory assigned to 'ids'
      before signaling a Matlab error.
      */
      if ( failed_c())
         {
         mxFree( ids );

         /*
         The mice_fail call creates the error string then returns control
         to the MATLAB interpreter.
         */
         mice_fail(SCALAR);
         }

      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = ids[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxINT32_CLASS, mxREAL);
   ids_f   = A_INT_RET_ARGV(0);

   MOVEI( ids + SPICE_CELL_CTRLSZ, ids[5], ids_f );
   mxFree( ids );
   }




/*
   void              spkopn_c ( ConstSpiceChar    * name,
                                ConstSpiceChar    * ifname,
                                SpiceInt            ncomch,
                                SpiceInt          * handle  );
*/
void cspice_spkopn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            fname [DEFAULT_STR_LENGTH+1];
   SpiceChar            ifname[DEFAULT_STR_LENGTH+1];
   SpiceInt             ncomch;
   SpiceInt           * handle;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "fname",  MiceChar, 0, {0}, 0},
      { "ifname", MiceChar, 0, {0}, 0},
      { "ncomch", MiceInt,  0, {0}, 0},
      { "handle", MiceInt,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], fname,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], ifname, DEFAULT_STR_LENGTH);

   ncomch = S_INT_ARGV(3);
   handle = A_INT_RET_ARGV(0);

   spkopn_c( fname, ifname, ncomch, handle );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              spkpos_c ( ConstSpiceChar    * targ,
                                SpiceDouble         et,
                                ConstSpiceChar    * ref,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obs,
                                SpiceDouble         ptarg[3],
                                SpiceDouble       * lt        );
*/
void mice_spkpos(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            targ  [DEFAULT_STR_LENGTH+1];
   SpiceChar            ref   [DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obs   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          ptarg[3];
   SpiceDouble          lt;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "targ",   MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "ref",    MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obs",    MiceChar,   0, {0}, 0},
      { "ptarg",  MicePos,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], targ, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(2);
   et     = *(vec_et);

   mxGetString(prhs[3], ref,    DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obs,    DEFAULT_STR_LENGTH);

   /*
   Check for vectorized arguments.
   */
   if (extra->count>1)
      {

      /*
      Something input as a N-vector, extract the input values
      (vectorized or not) then execute the routine for each
      set of inputs.
      */
      for (i=0;i<extra->count;i++)
         {

         et    = *(vec_et + i*extra->offset[1]);

         /*
         Call the routine for this iteration.
         */
         spkpos_c(targ, et, ref, abcorr, obs, ptarg, &lt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and light time values into the ith structure
         element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos") ),
                 ptarg,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "lt" ) );
         mxSetField( plhs[0], i, "lt", mxCreateDoubleScalar(lt) );

         }

      }
   else
      {

      spkpos_c(targ, et, ref, abcorr, obs, ptarg, &lt);
      CHECK_CALL_FAILURE(SCALAR);

      /*
      Copy the position and the light time value into the return structure.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0, "pos") ),
              ptarg,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "lt" ) );
      mxSetField( plhs[0], 0, "lt", mxCreateDoubleScalar(lt) );

      }

   }




/*
   void              spkpvn_c ( SpiceInt            handle,
                                ConstSpiceDouble    descr [5],
                                SpiceDouble         et,
                                SpiceInt          * ref,
                                SpiceDouble         state [6],
                                SpiceInt          * center    );
*/
void mice_spkpvn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt               handle;
   SpiceDouble          * descr;
   SpiceDouble            et;
   SpiceInt               ref;
   SpiceDouble            state  [6];
   SpiceInt               center;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle", MiceInt,    0, {0}, 0},
      { "descr",  MiceDouble, 1, {5}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "spkpvn", MicePVN,    0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   handle = S_INT_ARGV(1);
   descr  = A_DBL_ARGV(2);
   et     = S_DBL_ARGV(3);

   (void) spkpvn_c ( handle,
                     descr,
                     et,
                     &ref,
                     state,
                     &center );
   CHECK_CALL_FAILURE(SCALAR);

   mxDestroyArray( mxGetField( plhs[0], 0, "ref" ) );
   mxSetField( plhs[0], 0, "ref", zzmice_CreateIntScalar(ref) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"state" ) ),
           state,
           6*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "center" ) );
   mxSetField( plhs[0], 0, "center", zzmice_CreateIntScalar(center) );

   }




/*
   void              spksfs_c ( SpiceInt            body,
                                SpiceDouble         et,
                                SpiceInt            idlen,
                                SpiceInt          * handle,
                                SpiceDouble         descr [5],
                                SpiceChar         * ident,
                                SpiceBoolean      * found  );
*/
void mice_spksfs(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt              body;
   SpiceDouble           et;
   SpiceInt              idlen;
   SpiceInt              handle;
   SpiceDouble           descr [5];
   SpiceChar             ident [SIDLEN+1];
   SpiceBoolean          found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "body",   MiceInt,    0, { 0 },    0},
      { "et",     MiceDouble, 0, { 0 },    0},
      { "spksfs", MiceSFS,    0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   body   = S_INT_ARGV(1);
   et     = S_DBL_ARGV(2);

   idlen  = SIDLEN;

   (void) spksfs_c ( body,
                     et,
                     idlen,
                     &handle,
                     descr,
                     ident,
                     &found  );

   /*
   Test for a SPICE error signal. If found, display an error message to
   the user then return to the IDL application.
   */
   CHECK_CALL_FAILURE( SCALAR );

   /*
   Copy the output values into the return structure.
   */
   mxDestroyArray( mxGetField( plhs[0], 0, "handle" ) );
   mxSetField( plhs[0], 0, "handle", zzmice_CreateIntScalar(handle) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"descr") ),
           descr,
           5*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "ident" ) );
   mxSetField( plhs[0], 0, "ident", mxCreateString(ident) );

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found", 
               mxCreateLogicalScalar(found ? true: false));
   }




/*
   void              spkw08_c ( SpiceInt             handle,
                                SpiceInt             body,
                                SpiceInt             center,
                                ConstSpiceChar     * frame,
                                SpiceDouble          first,
                                SpiceDouble          last,
                                ConstSpiceChar     * segid,
                                SpiceInt             degree,
                                SpiceInt             n,
                                ConstSpiceDouble     states[][6],
                                SpiceDouble          epoch1,
                                SpiceDouble          step         );
*/
void cspice_spkw08(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             handle;
   SpiceInt             body;
   SpiceInt             center;
   SpiceChar            frame   [DEFAULT_STR_LENGTH+1];
   SpiceDouble          first;
   SpiceDouble          last;
   SpiceChar            segid   [DEFAULT_STR_LENGTH+1];
   SpiceInt             degree;
   SpiceInt             n;
   ConstSpiceDouble   * states;
   SpiceDouble          epoch1;
   SpiceDouble          step;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "handle",  MiceInt,    0, { 0 },    0},
      { "body",    MiceInt,    0, { 0 },    0},
      { "center",  MiceInt,    0, { 0 },    0},
      { "frame",   MiceChar,   0, { 0 },    0},
      { "first",   MiceDouble, 0, { 0 },    0},
      { "last",    MiceDouble, 0, { 0 },    0},
      { "segid",   MiceChar,   0, { 0 },    0},
      { "degree",  MiceInt,    0, { 0 },    0},
      { "states",  MiceDouble, 2, { 6, 0 }, 0},
      { "epoch1",  MiceDouble, 0, { 0 },    0},
      { "step",    MiceDouble, 0, { 0 },    0},
      };

   check_arg_num( nrhs, nlhs, 11, 0);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /*
   Number of state sets = number of elements in array divided by six;
   we expect a 6xN array.
   */
   n = mxGetNumberOfElements( prhs[9]) / 6;

   handle  = S_INT_ARGV(1);
   body    = S_INT_ARGV(2);
   center  = S_INT_ARGV(3);

   mxGetString(prhs[4], frame, DEFAULT_STR_LENGTH);

   first   = S_DBL_ARGV(5);
   last    = S_DBL_ARGV(6);

   mxGetString(prhs[7], segid, DEFAULT_STR_LENGTH);

   degree  = S_INT_ARGV(8);

   states  = (ConstSpiceDouble*)mxGetData(prhs[9]);

   epoch1  = S_DBL_ARGV(10);
   step    = S_DBL_ARGV(11);

   spkw08_c ( handle,
              body,
              center,
              frame,
              first,
              last,
              segid,
              degree,
              n,
              (Nx6)states,
              epoch1,
              step );

   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              srfxpt_c( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                ConstSpiceChar    * dref,
                                ConstSpiceDouble    dvec   [3],
                                SpiceDouble         spoint [3],
                                SpiceDouble       * dist,
                                SpiceDouble       * trgepc,
                                SpiceDouble         obspos [3],
                                SpiceBoolean      * found         );
*/
void mice_srfxpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceChar            dref  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * dvec;
   SpiceDouble          spoint[3];
   SpiceDouble          dist;
   SpiceDouble          trgepc;
   SpiceDouble          obspos[3];
   SpiceBoolean         found;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "dref",   MiceChar,   0, {0}, 0},
      { "dvec",   MiceDouble, 1, {3}, 0},
      { "surf",   MiceSurf,   0, {0}, 1}
      };

   check_arg_num( nrhs, nlhs, 7, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], dref,   DEFAULT_STR_LENGTH);

   dvec = A_DBL_ARGV(7);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         srfxpt_c( method, target,   et,
                   abcorr, obsrvr, dref,
                   dvec,   spoint, &dist,
                   &trgepc, obspos, &found );
         CHECK_CALL_FAILURE(i);

         memcpy( mxGetPr( mxGetField(plhs[0],i,"spoint" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         memcpy( mxGetPr( mxGetField(plhs[0],i,"obspos" ) ),
                 obspos,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "dist" ) );
         mxSetField( plhs[0], i, "dist", mxCreateDoubleScalar(dist) );

         mxDestroyArray( mxGetField( plhs[0], i, "trgepc" ) );
         mxSetField( plhs[0], i, "trgepc", mxCreateDoubleScalar(trgepc) );

         mxDestroyArray( mxGetField( plhs[0], i, "found" ) );
         mxSetField( plhs[0], i, "found",
                     mxCreateLogicalScalar(found ? true: false));
         }

      }
   else
      {

      et = *vec_et;

      srfxpt_c( method, target,     et,
                abcorr, obsrvr,   dref,
                dvec,   spoint,  &dist,
                &trgepc, obspos, &found );
      CHECK_CALL_FAILURE(SCALAR);

      memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      memcpy( mxGetPr( mxGetField(plhs[0],0,"obspos" ) ),
              obspos,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "dist" ) );
      mxSetField( plhs[0], 0, "dist", mxCreateDoubleScalar(dist) );

      mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
      mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

      mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
      mxSetField( plhs[0], 0, "found",
                  mxCreateLogicalScalar(found ? true: false));
      }

   }





/*
   void              str2et_c( ConstSpiceChar * str,
                               SpiceDouble    * et   )
*/
void cspice_str2et(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            str[DEFAULT_STR_LENGTH+1];
   mxChar             * mx_str;
   SpiceDouble        * et;
   SpiceDouble        * vec_et;

   SpiceInt             i;
   SpiceInt             j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "str", MiceChar,   0, {0}, 1},
      { "et",  MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      mx_str = (mxChar *)mxGetChars(prhs[1]);

      for ( i=0; i<extra->count; i++)
         {

         /*
         Extract the string data, character by character, into
         CSPICE strings. The mx_str array stores the data in a column
         major format, we need to extract the data by rows.
         */
         for ( j=0; j<extra->offset[0]; j++)
            {
            str[j] = (char)mx_str[i + (extra->count*j)];
            }

         str[extra->offset[0]] = '\0';
         et                    = (vec_et+i*extra->offset[1]);

         str2et_c(str, et);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], str, DEFAULT_STR_LENGTH);

      et = vec_et;

      str2et_c(str, et);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              stpool_c ( ConstSpiceChar    * item,
                                SpiceInt            nth,
                                ConstSpiceChar    * contin,
                                SpiceInt            lenout,
                                SpiceChar         * string,
                                SpiceInt          * size,
                                SpiceBoolean      * found  );
*/
void cspice_stpool(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];
   SpiceInt             nth;
   SpiceChar            contin[DEFAULT_STR_LENGTH+1];
   SpiceChar            stringx[DEFAULT_STR_LENGTH+1];
   SpiceInt             size;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar,    0, {0}, 0},
      { "nth",    MiceInt,     0, {0}, 0},
      { "contin", MiceChar,    0, {0}, 0},
      { "string", MiceChar,    0, {0}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   /*
   MATLAB uses a base 1 array index convention, as is proper,
   C does not, which is weird. Subtract one off the 'nth' index.
   */
   nth = S_INT_ARGV(2) - 1;

   mxGetString(prhs[3], contin, DEFAULT_STR_LENGTH);

   found  = A_BOOL_RET_ARGV(1);

   stpool_c ( item,  nth, contin, DEFAULT_STR_LENGTH, stringx, &size, found );

   if( *found )
      {
      plhs[0] = mxCreateString( stringx );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      }

   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt(
         "MICE(BUG): mxCreateString failed in cspice_kdata: plhs[0]" );
      }

   if ( size > DEFAULT_STR_LENGTH )
      {
      mexErrMsgTxt(
         "MICE(BUG): The Mice interface truncated the string value "
         "corresponding to the kernel variable." );
      }

   CHECK_CALL_FAILURE(SCALAR);
   }




/*
   void              subpnt_c ( ConstSpiceChar       * method,
                                ConstSpiceChar       * target,
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble            spoint [3],
                                SpiceDouble          * trgepc,
                                SpiceDouble            srfvec [3] )
*/
void mice_subpnt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "subpnt", MiceSub_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   subpnt_c ( method,
              target,
              et,
              fixref,
              abcorr,
              obsrvr,
              spoint,
              &trgepc,
              srfvec );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
           spoint,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   }




/*
   void              subpt_c ( ConstSpiceChar       * method,
                               ConstSpiceChar       * target,
                               SpiceDouble            et,
                               ConstSpiceChar       * abcorr,
                               ConstSpiceChar       * obsrvr,
                               SpiceDouble            spoint [3],
                               SpiceDouble          * alt         )
*/
void mice_subpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble          spoint[3];
   SpiceDouble          alt;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceNear,    0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et + i*extra->offset[2]);

         subpt_c(method, target, et, abcorr, obsrvr, spoint, &alt);
         CHECK_CALL_FAILURE(i);

         /*
         Copy the position and altitude values into the ith
         structure element.
         */
         memcpy( mxGetPr( mxGetField(plhs[0],i,"pos" ) ),
                 spoint,
                 3*sizeof(SpiceDouble));

         mxDestroyArray( mxGetField( plhs[0], i, "alt" ) );
         mxSetField( plhs[0], i, "alt", mxCreateDoubleScalar(alt) );

        }

     }
   else
      {

      subpt_c(method, target, et, abcorr, obsrvr, spoint, &alt);
      CHECK_CALL_FAILURE(SCALAR); ;

      /*
      Copy the position and altitude values into the 0 structure element.
      */
      memcpy( mxGetPr( mxGetField(plhs[0],0,"pos" ) ),
              spoint,
              3*sizeof(SpiceDouble));

      mxDestroyArray( mxGetField( plhs[0], 0, "alt" ) );
      mxSetField( plhs[0], 0, "alt", mxCreateDoubleScalar(alt) );

      }

   }




/*
   void              subslr_c ( ConstSpiceChar       * method,
                                ConstSpiceChar       * target,
                                SpiceDouble            et,
                                ConstSpiceChar       * fixref,
                                ConstSpiceChar       * abcorr,
                                ConstSpiceChar       * obsrvr,
                                SpiceDouble            spoint [3],
                                SpiceDouble          * trgepc,
                                SpiceDouble            srfvec [3] )
*/
void mice_subslr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceChar            fixref[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          spoint[3];
   SpiceDouble          trgepc;
   SpiceDouble          srfvec[3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 0},
      { "fixref", MiceChar,   0, {0}, 0},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "subslr", MiceSub_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 6, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   et = S_DBL_ARGV(3);

   mxGetString(prhs[4], fixref, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[6], obsrvr, DEFAULT_STR_LENGTH);

   subslr_c ( method,
              target,
              et,
              fixref,
              abcorr,
              obsrvr,
              spoint,
              &trgepc,
              srfvec );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
           spoint,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "trgepc" ) );
   mxSetField( plhs[0], 0, "trgepc", mxCreateDoubleScalar(trgepc) );

   memcpy( mxGetPr( mxGetField(plhs[0],0,"srfvec" ) ),
           srfvec,
           3*sizeof(SpiceDouble));

   }





/*
   void              subsol_c ( ConstSpiceChar    * method,
                                ConstSpiceChar    * target,
                                SpiceDouble         et,
                                ConstSpiceChar    * abcorr,
                                ConstSpiceChar    * obsrvr,
                                SpiceDouble         spoint[3] );
*/
void cspice_subsol(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_spoint;
   SpiceChar            method[DEFAULT_STR_LENGTH+1];
   SpiceChar            target[DEFAULT_STR_LENGTH+1];
   SpiceChar            abcorr[DEFAULT_STR_LENGTH+1];
   SpiceChar            obsrvr[DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * spoint;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "method", MiceChar,   0, {0}, 0},
      { "target", MiceChar,   0, {0}, 0},
      { "et",     MiceDouble, 0, {0}, 1},
      { "abcorr", MiceChar,   0, {0}, 0},
      { "obsrvr", MiceChar,   0, {0}, 0},
      { "spoint", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], method, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], target, DEFAULT_STR_LENGTH);

   vec_et = A_DBL_ARGV(3);
   et     = *(vec_et);

   mxGetString(prhs[4], abcorr, DEFAULT_STR_LENGTH);
   mxGetString(prhs[5], obsrvr, DEFAULT_STR_LENGTH);

   vec_spoint = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et     = *(vec_et     + i*extra->offset[2]);
         spoint =  (vec_spoint + i*extra->offset[5]);

         subsol_c(method, target, et, abcorr, obsrvr, spoint );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      spoint = vec_spoint;

      subsol_c(method, target, et, abcorr, obsrvr, spoint );
      CHECK_CALL_FAILURE(SCALAR); ;
      }

   }




/*
   void              surfnm_c( SpiceDouble        a,
                               SpiceDouble        b,
                               SpiceDouble        c,
                               ConstSpiceDouble   point[3],
                               SpiceDouble        normal[3] )
*/
void cspice_surfnm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_point;
   SpiceDouble        * vec_normal;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble        * point;
   SpiceDouble        * normal;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceDouble, 0, {0}, 0},
      { "b",      MiceDouble, 0, {0}, 0},
      { "c",      MiceDouble, 0, {0}, 0},
      { "point",  MiceDouble, 1, {3}, 1},
      { "normal", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a          = S_DBL_ARGV(1);
   b          = S_DBL_ARGV(2);
   c          = S_DBL_ARGV(3);
   vec_point  = A_DBL_ARGV(4);
   vec_normal = A_DBL_RET_ARGV(0);

   point      = (vec_point);
   normal     = (vec_normal);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         point  =  (vec_point  + i*extra->offset[3]);
         normal =  (vec_normal + i*extra->offset[4]);

         surfnm_c(a, b, c, point, normal);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      surfnm_c(a, b, c, point, normal);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void               surfpt_c ( ConstSpiceDouble   positn[3],
                                 ConstSpiceDouble   u[3],
                                 SpiceDouble        a,
                                 SpiceDouble        b,
                                 SpiceDouble        c,
                                 SpiceDouble        point[3],
                                 SpiceBoolean     * found     )
*/
void mice_surfpt(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * positn;
   SpiceDouble        * u;
   SpiceDouble          a;
   SpiceDouble          b;
   SpiceDouble          c;
   SpiceDouble          point[3];
   SpiceBoolean         found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "positn", MiceDouble,  1, {3}, 0},
      { "u",      MiceDouble,  1, {3}, 0},
      { "a",      MiceDouble,  0, {0}, 0},
      { "b",      MiceDouble,  0, {0}, 0},
      { "c",      MiceDouble,  0, {0}, 0},
      { "surfpt", MiceSurf_PS, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 5, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   /* extra-> offset corresponds to argcheck table from[0]*/
   positn  = A_DBL_ARGV(1);
   u       = A_DBL_ARGV(2);
   a       = S_DBL_ARGV(3);
   b       = S_DBL_ARGV(4);
   c       = S_DBL_ARGV(5);

   surfpt_c ( positn,
              u,
              a,
              b,
              c,
              point,
              &found );

   CHECK_CALL_FAILURE(SCALAR);

   memcpy( mxGetPr( mxGetField(plhs[0],0,"spoint" ) ),
           point,
           3*sizeof(SpiceDouble));

   mxDestroyArray( mxGetField( plhs[0], 0, "found" ) );
   mxSetField( plhs[0], 0, "found",
               mxCreateLogicalScalar(found ? true: false));

   }




/*
 void               sxform_c( ConstSpiceChar  * from,
                               ConstSpiceChar  * to,
                               SpiceDouble       et,
                               SpiceDouble       xform[6][6] )
 */
void cspice_sxform(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_et;
   SpiceDouble        * vec_xform;
   SpiceChar            from[DEFAULT_STR_LENGTH+1];
   SpiceChar            to  [DEFAULT_STR_LENGTH+1];
   SpiceDouble          et;
   SpiceDouble        * xform;
   SpiceDouble          xr[6][6];

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "from",  MiceChar,   0, {0},    0},
      { "to",    MiceChar,   0, {0},    0},
      { "et",    MiceDouble, 0, {0},    1},
      { "xform", MiceDouble, 2, {6, 6}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], from, DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], to,   DEFAULT_STR_LENGTH);

   vec_et    = A_DBL_ARGV(3);
   vec_xform = A_DBL_RET_ARGV(0);
   et        = *vec_et;
   xform     =  vec_xform;

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         et    = *(vec_et    + i*extra->offset[2]);
         xform =  (vec_xform + i*extra->offset[3]);

         sxform_c(from, to, et, (SpiceDouble (*)[6])xr);
         CHECK_CALL_FAILURE(i);

         xpose6_c( xr, (SpiceDouble (*)[6])xform );
         }

      }
   else
      {

      sxform_c(from, to, et, (SpiceDouble (*)[6])xr);
      CHECK_CALL_FAILURE(SCALAR);

      xpose6_c( xr, (SpiceDouble (*)[6])xform );
      }

   }




/*
   void              timdef_c ( ConstSpiceChar    * action,
                                ConstSpiceChar    * item,
                                SpiceInt            lenout,
                                SpiceChar         * value );
*/
void cspice_timdef_get(int nlhs, mxArray *plhs[], int nrhs,
                                      const mxArray *prhs[])
   {

   SpiceChar           item  [DEFAULT_STR_LENGTH+1];
   SpiceChar           value [DEFAULT_STR_LENGTH+1];

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar, 0, {0}, 0},
      { "value",  MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item,  DEFAULT_STR_LENGTH);

   timdef_c ( "GET", item, DEFAULT_STR_LENGTH, value );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString( value );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_timdef_get" );
      }

   }




/*
   void              timdef_c ( ConstSpiceChar    * action,
                                ConstSpiceChar    * item,
                                SpiceInt            lenout,
                                SpiceChar         * value );
*/
void cspice_timdef_set(int nlhs, mxArray *plhs[], int nrhs,
                                     const mxArray *prhs[])
   {

   SpiceChar           item  [DEFAULT_STR_LENGTH+1];
   SpiceChar           value [DEFAULT_STR_LENGTH+1];

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",   MiceChar, 0, {0}, 0},
      { "value",  MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[2], value, DEFAULT_STR_LENGTH);

   timdef_c ( "SET", item, DEFAULT_STR_LENGTH, value );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void               timout_c ( SpiceDouble       et,
                                 ConstSpiceChar  * pictur,
                                 SpiceInt          lenout,
                                 SpiceChar       * output )
*/
void cspice_timout(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * vec_et;
   SpiceDouble         et;
   SpiceChar           pictur[DEFAULT_STR_LENGTH+1];
   SpiceChar           output[DEFAULT_STR_LENGTH+1];
   SpiceChar        ** cval;
   SpiceChar        ** array;

   SpiceInt            i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "et",     MiceDouble, 0, {0}, 1},
      { "pictur", MiceChar,   0, {0}, 0},
      { "output", MiceChar,   0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   memset( output, 0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_et = A_DBL_ARGV(1);

   mxGetString(prhs[2], pictur, DEFAULT_STR_LENGTH);

   if (extra->count>1)
      {
      /*
      Allocate needed memory for intermediate operations.
      */
      cval  = (SpiceChar**)alloc_SpiceString_C_array(DEFAULT_STR_LENGTH,
                                                     extra->count );
      array = (SpiceChar**)alloc_SpiceString_Pointer_array(extra->count);

      CHECK_CALL_FAILURE_MEM1(SCALAR, 1, cval, array);

      for (i=0;i<extra->count;i++)
         {

         et = *(vec_et+i*extra->offset[0]);

         /*
         Copy the ith string pointer to the array of pointers,
         use this pointer for the call output.
         */
         array[i] = *cval + i*default_str_size;

         timout_c(et, pictur, DEFAULT_STR_LENGTH, array[i]);
         CHECK_CALL_FAILURE_MEM1(i, 1, cval, array);
         }

      /*
      I think this functions as a copy, creating needed
      memory for plhs.
      */
      plhs[0] = mxCreateCharMatrixFromStrings( extra->count,
                                               (const char **)array);

      free_SpiceString_C_array ( 1, cval );
      free_SpiceMemory( array );
      }
   else
      {

      et = *(vec_et);

      timout_c(et, pictur, DEFAULT_STR_LENGTH, output);
      CHECK_CALL_FAILURE(SCALAR);

      plhs[0] = mxCreateString( output );
      if ( plhs[0] == NULL )
         {
         mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_timout" );
         }

      }

   /*
   Confirm the code released all allocated memory.
   */
   MICE_ALLOC_CHECK;
   }




/*
   ConstSpiceChar  * tkvrsn_c ( ConstSpiceChar    * item );
*/
void cspice_tkvrsn(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            item  [DEFAULT_STR_LENGTH+1];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "item",  MiceChar, 0, {0}, 0},
      { "value", MiceChar, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], item, DEFAULT_STR_LENGTH);

   plhs[0] = mxCreateString( tkvrsn_c(item) );
   if ( plhs[0] == NULL )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_tkvrsn" );
      }

   }




/*
   void              tpictr_c ( ConstSpiceChar     * sample,
                                SpiceInt            lenpictur,
                                SpiceInt            lenerror,
                                SpiceChar         * pictur,
                                SpiceBoolean      * ok,
                                SpiceChar         * error     );
*/
void cspice_tpictr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar           sample[DEFAULT_STR_LENGTH+1];
   SpiceChar           pictur[DEFAULT_STR_LENGTH+1];
   SpiceChar           error [DEFAULT_STR_LENGTH+1];
   SpiceBoolean        ok;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "sample", MiceChar,   0, {0}, 0},
      { "pictur", MiceIgnore, 0, {0}, 0},
      { "ok",     MiceIgnore, 0, {0}, 0},
      { "error",  MiceIgnore, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 3 );

   memset( pictur, 0, default_str_size );
   memset( error,  0, default_str_size );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], sample, DEFAULT_STR_LENGTH);

   tpictr_c( sample,
             DEFAULT_STR_LENGTH,
             DEFAULT_STR_LENGTH,
             pictur,
             &ok,
             error );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] = mxCreateString( pictur );
   plhs[1] = zzmice_CreateIntScalar(ok);
   plhs[2] = mxCreateString( error );

   if ( ok )
      {
      plhs[0] = mxCreateString( pictur );
      plhs[2] = mxCreateString( "\0" );
      }
   else
      {
      plhs[0] = mxCreateString( "\0" );
      plhs[2] = mxCreateString( error );
      }

   if ( (plhs[0] == NULL) || (plhs[2] == NULL) )
      {
      mexErrMsgTxt( "MICE(BUG): mxCreateString failed in cspice_tpictr" );
      }

   }




/*
   void tsetyr_c ( SpiceInt year )
*/
void cspice_tsetyr(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceInt             year;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "year",  MiceInt, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   year = S_INT_ARGV(1);

   tsetyr_c ( year );
   CHECK_CALL_FAILURE(SCALAR);
   }






/*
   SpiceDouble twopi_c( void )
*/
void cspice_twopi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( twopi_c() );
   }




/*
   void              twovec_c( ConstSpiceDouble    axdef  [3],
                               SpiceInt            indexa,
                               ConstSpiceDouble    plndef [3],
                               SpiceInt            indexp,
                               SpiceDouble         mout   [3][3] )
*/
void cspice_twovec(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * axdef;
   SpiceInt             indexa;
   SpiceDouble        * plndef;
   SpiceInt             indexp;
   SpiceDouble        * mout;
   SpiceDouble          xr[3][3];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "axdef",  MiceDouble, 1, {3},    0},
      { "indexa", MiceInt,    0, {0},    0},
      { "plndef", MiceDouble, 1, {3},    0},
      { "indexp", MiceInt,    0, {0},    0},
      { "mout",   MiceDouble, 2, {3, 3}, 0},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   axdef  = A_DBL_ARGV(1);
   indexa = S_INT_ARGV(2);
   plndef = A_DBL_ARGV(3);
   indexp = S_INT_ARGV(4);
   mout   = A_DBL_RET_ARGV(0);

   twovec_c(axdef, indexa, plndef, indexp, (SpiceDouble(*)[3])xr);
   CHECK_CALL_FAILURE(SCALAR);

   xpose_c( xr, (SpiceDouble(*)[3])mout);

   }




/*
   SpiceDouble       tyear_c  ( void );
*/
void cspice_tyear(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   check_arg_num( nrhs, nlhs, 0, 1 );

   /*
   Directly return the scalar value. This simple case needs no
   error checks.
   */
   plhs[0] = mxCreateDoubleScalar( tyear_c() );
   }




/*
   void              unload_c ( ConstSpiceChar   * file );
*/
void cspice_unload(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar     file[DEFAULT_STR_LENGTH+1];
   mxChar      * mx_file;

   SpiceInt      i;
   SpiceInt      j;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "file", MiceChar, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 0 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);


   if (extra->count>1)
      {

      mx_file = (mxChar *)mxGetChars(prhs[1]);

      for (i=0;i<extra->count;i++)
         {

         for (j=0;j<extra->offset[0];j++)
            {
            file[j] = (char)mx_file[j + i*extra->offset[0]];
            }

         file[extra->offset[0]] = '\0';

         unload_c(file);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      mxGetString(prhs[1], file, DEFAULT_STR_LENGTH-1);

      unload_c(file);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       unitim_c ( SpiceDouble         epoch,
                                ConstSpiceChar    * insys,
                                ConstSpiceChar    * outsys )
*/
void cspice_unitim(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_epoch;
   SpiceDouble          epoch;
   SpiceChar            insys  [DEFAULT_STR_LENGTH+1];
   SpiceChar            outsys [DEFAULT_STR_LENGTH+1];
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "epoch",  MiceDouble, 0, {0}, 1},
      { "insys",  MiceChar,   0, {0}, 0},
      { "outsys", MiceChar,   0, {0}, 0},
      { "retval", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], insys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], outsys, DEFAULT_STR_LENGTH);

   vec_epoch  = A_DBL_ARGV(1);

   if (extra->count>1)
      {

      vec_retval = A_DBL_RET_ARGV(0);

      for (i=0;i<extra->count;i++)
         {

         epoch = *(vec_epoch + i*extra->offset[0]);
         retval = vec_retval + i*extra->offset[3];

         *retval = unitim_c ( epoch, insys, outsys );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      epoch = *vec_epoch;

      plhs[0] = mxCreateDoubleScalar( unitim_c ( epoch, insys, outsys ) );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              unorm_c  ( ConstSpiceDouble    v1[3],
                                SpiceDouble         vout[3],
                                SpiceDouble       * vmag    );
*/
void cspice_unorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * v1;
   SpiceDouble        * vec_v1;
   SpiceDouble        * vout;
   SpiceDouble        * vec_vout;
   SpiceDouble        * vmag;
   SpiceDouble        * vec_vmag;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "vout", MiceDouble, 1, {3}, 1},
      { "vmag", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);
   vec_vmag = A_DBL_RET_ARGV(1);

   v1   = (vec_v1);
   vout = (vec_vout);
   vmag = (vec_vmag);

   if (extra->count>1)
      {
      for (i=0;i<extra->count;i++)
         {

         v1   =  (vec_v1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);
         vmag =  (vec_vmag + i*extra->offset[2]);

         unorm_c(v1, vout, vmag);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      unorm_c(v1, vout, vmag);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       vdist_c  ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] );
*/
void cspice_vdist(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_v2;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   SpiceInt             i;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",    MiceDouble, 1, {3}, 1},
      { "v2",    MiceDouble, 1, {3}, 1},
      { "vdist", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_v2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         v2     = (vec_v2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = vdist_c(v1, v2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      v2     = vec_v2;
      retval = vec_retval;

      *retval = vdist_c(v1, v2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vhat_c   ( ConstSpiceDouble    v1  [3],
                                SpiceDouble         vout[3] );
*/
void cspice_vhat(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_vout;
   SpiceDouble        * v1;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims  * extra;

   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "vout", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1   = A_DBL_ARGV(1);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         v1   =  (vec_v1   + i*extra->offset[0]);
         vout =  (vec_vout + i*extra->offset[1]);

         vhat_c(v1, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {

      v1   =  vec_v1;
      vout =  vec_vout;

      vhat_c(v1, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vperp_c ( ConstSpiceDouble   a[3],
                               ConstSpiceDouble   b[3],
                               SpiceDouble        p[3] )

*/
void cspice_vperp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a",     MiceDouble, 1, {3}, 1},
      { "b",     MiceDouble, 1, {3}, 1},
      { "vperp", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         vperp_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      vperp_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceDouble       vnorm_c   ( ConstSpiceDouble    v1[3] );
*/
void cspice_vnorm(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * v1;
   SpiceDouble        * vec_retval;
   SpiceDouble        * retval;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",    MiceDouble, 1, {3}, 1},
      { "vnorm", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         retval = (vec_retval + i*extra->offset[1]);

         *retval = vnorm_c(v1);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      retval = vec_retval;

      *retval = vnorm_c(v1);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vprjp_c  ( ConstSpiceDouble    vin   [3],
                                ConstSpicePlane   * plane,
                                SpiceDouble         vout  [3] );
*/
void cspice_vprjp(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vin;
   SpicePlane           plane;
   SpiceDouble        * vout;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vin",   MiceDouble, 1, {3}, 0},
      { "plane", MicePlane,  0, {0}, 0},
      { "vout",  MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vin = A_DBL_ARGV(1);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( plane.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   plane.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   vout = A_DBL_RET_ARGV(0);

   (void)vprjp_c( vin, &plane, vout );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              vprjpi_c ( ConstSpiceDouble    vin    [3],
                                ConstSpicePlane   * projpl,
                                ConstSpicePlane   * invpl,
                                SpiceDouble         vout   [3],
                                SpiceBoolean      * found       );
*/
void cspice_vprjpi(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vin;
   SpicePlane           projpl;
   SpicePlane           invpl;
   SpiceDouble        * vout;
   SpiceBoolean       * found;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "vin",    MiceDouble,  1, {3}, 0},
      { "projpl", MicePlane,   0, {0}, 0},
      { "invpl",  MicePlane,   0, {0}, 0},
      { "vout",   MiceDouble,  1, {3}, 0},
      { "found",  MiceBoolean, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vin = A_DBL_ARGV(1);

   /*
   Assemble a plane structure from the input arguments.
   */
   memcpy( projpl.normal,
           mxGetPr( mxGetField( prhs[2], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   projpl.constant = *mxGetPr( mxGetField( prhs[2], 0,"constant") );

   memcpy( invpl.normal,
           mxGetPr( mxGetField( prhs[3], 0,"normal") ),
           3*sizeof(SpiceDouble)
         );

   invpl.constant = *mxGetPr( mxGetField( prhs[3], 0,"constant") );

   vout   = A_DBL_RET_ARGV(0);
   found  = A_BOOL_RET_ARGV(1);

   (void)vprjpi_c( vin, &projpl, &invpl, vout, found );
   CHECK_CALL_FAILURE( SCALAR );

   }




/*
   void              vproj_c ( ConstSpiceDouble   a[3],
                               ConstSpiceDouble   b[3],
                               SpiceDouble        p[3] )

*/
void cspice_vproj(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_s1;
   SpiceDouble        * vec_s2;
   SpiceDouble        * vec_vout;
   SpiceDouble        * s1;
   SpiceDouble        * s2;
   SpiceDouble        * vout;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "a",     MiceDouble, 1, {3}, 1},
      { "b",     MiceDouble, 1, {3}, 1},
      { "vproj", MiceDouble, 1, {3}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_s1   = A_DBL_ARGV(1);
   vec_s2   = A_DBL_ARGV(2);
   vec_vout = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         s1   = (vec_s1   + i*extra->offset[0]);
         s2   = (vec_s2   + i*extra->offset[1]);
         vout = (vec_vout + i*extra->offset[2]);

         vproj_c(s1, s2, vout);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      s1   = vec_s1;
      s2   = vec_s2;
      vout = vec_vout;

      vproj_c(s1, s2, vout);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              vrotv_c  ( ConstSpiceDouble    v    [3],
                                ConstSpiceDouble    axis [3],
                                SpiceDouble         theta,
                                SpiceDouble         r    [3] );
*/
void cspice_vrotv(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * v;
   SpiceDouble        * axis;
   SpiceDouble          theta;
   SpiceDouble        * r;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "v",     MiceDouble, 1, {3}, 0},
      { "axis",  MiceDouble, 1, {3}, 0},
      { "theta", MiceDouble, 0, {0}, 0},
      { "r",     MiceDouble, 1, {3}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   v      = A_DBL_ARGV(1);
   axis   = A_DBL_ARGV(2);
   theta  = S_DBL_ARGV(3);
   r      = A_DBL_RET_ARGV(0);

   vrotv_c( v, axis, theta, r );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   SpiceDouble       vsep_c   ( ConstSpiceDouble    v1[3],
                                ConstSpiceDouble    v2[3] );
*/
void cspice_vsep(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * vec_v1;
   SpiceDouble        * vec_v2;
   SpiceDouble        * v1;
   SpiceDouble        * v2;
   SpiceDouble        * retval;
   SpiceDouble        * vec_retval;

   SpiceInt             i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "v1",   MiceDouble, 1, {3}, 1},
      { "v2",   MiceDouble, 1, {3}, 1},
      { "vsep", MiceDouble, 0, {0}, 1},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_v1     = A_DBL_ARGV(1);
   vec_v2     = A_DBL_ARGV(2);
   vec_retval = A_DBL_RET_ARGV(0);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {
         v1     = (vec_v1     + i*extra->offset[0]);
         v2     = (vec_v2     + i*extra->offset[1]);
         retval = (vec_retval + i*extra->offset[2]);

         *retval = vsep_c(v1, v2);
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      v1     = vec_v1;
      v2     = vec_v2;
      retval = vec_retval;

      *retval = vsep_c(v1, v2);
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   SpiceInt          wncard_c ( SpiceCell          * window );

*/
void cspice_wncard(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceInt            card;

   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,    1, {0}, 0},
      { "card",   MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   card = wncard_( ( doublereal * ) window );
   CHECK_CALL_FAILURE(SCALAR);

   plhs[0] =  zzmice_CreateIntScalar(card) ;
   }




/*
   void              wncomd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window,
                                SpiceCell          * result );
*/
void cspice_wncomd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          left;
   SpiceDouble          right;
   SpiceDouble        * window;
   SpiceDouble        * result;
   SpiceDouble        * result_f;

   SpiceInt            card = 0;
   SpiceInt            window_size;
   SpiceInt            size;

   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",     MiceDouble, 0, {0}, 0},
      { "right",    MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "result",   MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);
   window = (SpiceDouble*)mxGetData(prhs[3]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of
   'window' without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );


   /*
   Allocate the memory for the return window, provide the needed room
   for the control segment.

   The maximum size of the output window 'return' equals no more than
   the size of 'window' plus 2.
   */
   size = window_size + 2;

   result = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the 'return' before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) result );
   scardd_( ( integer * ) &card, ( double * ) result );

   wncomd_ ( (doublereal * ) &left,
             (doublereal * ) &right,
             (doublereal * ) (window),
             (doublereal * ) (result) );

   /*
   Check for a failure signal. Free the memory assigned to 'result'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( result );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = result[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   result_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'result' to 'result_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'result[5]'
   elements.
   */
   MOVED( result + SPICE_CELL_CTRLSZ, result[5], result_f );
   mxFree( result );
   }






/*
   void              wndifd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wndifd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b'.
   */
   size =  a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation. Add
   size and cardinality values to this control segment.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wndifd_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );
   }




/*
   SpiceBoolean      wnelmd_c ( SpiceDouble          point,
                                SpiceCell          * window );
*/
void cspice_wnelmd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble         point;

   SpiceInt            window_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "point",  MiceDouble,  0, {0}, 0},
      { "window", MiceWin,     1, {0}, 0},
      { "retval", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   point   = S_DBL_ARGV(1);
   window = (SpiceDouble*)mxGetData(prhs[2]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   *retval = wnelmd_( (doublereal * ) &point,
                      (doublereal * ) (window) );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnexpd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window );
*/
void cspice_wnexpd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          left;
   SpiceDouble          right;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",     MiceDouble, 0, {0}, 0},
      { "right",    MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 3, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left     = S_DBL_ARGV(1);
   right    = S_DBL_ARGV(2);
   window_i = (SpiceDouble*)mxGetData(prhs[3]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[3] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnexpd_ ( (doublereal * )  &left,
             (doublereal * )  &right,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }




/*
   void              wnextd_c ( SpiceChar            side,
                                SpiceCell          * window );
*/
void cspice_wnextd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceChar            side[DEFAULT_STR_LENGTH+1];
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "side",     MiceChar,   0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[1], side, DEFAULT_STR_LENGTH);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnextd_ ( ( char       * ) &side,
             ( doublereal * ) window,
             ( ftnlen       ) 1 );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }




/*
   void              wnfetd_c ( SpiceCell          * window,
                                SpiceInt             n,
                                SpiceDouble        * left,
                                SpiceDouble        * right   );
*/
void cspice_wnfetd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble       * left;
   SpiceDouble       * right;

   SpiceInt            n;
   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,     1, {0}, 0},
      { "n",      MiceInt,     0, {0}, 0},
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);
   n      = S_INT_ARGV(2);
   left   = A_DBL_RET_ARGV(0);
   right  = A_DBL_RET_ARGV(1);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   wnfetd_ ( ( doublereal * ) window,
             ( integer    * ) &n,
             ( doublereal * ) left,
             ( doublereal * ) right );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnfild_c ( SpiceDouble          sml,
                                SpiceCell          * window );
*/
void cspice_wnfild(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          sml;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sml",      MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sml      = S_DBL_ARGV(1);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnfild_ ( (doublereal * )  &sml,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }




/*
   void              wnfltd_c ( SpiceDouble          sml,
                                SpiceCell          * window );
*/
void cspice_wnfltd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble          sml;
   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "sml",      MiceDouble, 0, {0}, 0},
      { "window_i", MiceWin,    1, {0}, 0},
      { "window_f", MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   sml      = S_DBL_ARGV(1);
   window_i = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[2] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and cardinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size,  window  + SPICE_CELL_CTRLSZ);

   wnfltd_ ( (doublereal * )  &sml,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }




/*
   SpiceBoolean      wnincd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window  );
*/
void cspice_wnincd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         left;
   SpiceDouble         right;
   SpiceDouble       * window;

   SpiceInt            window_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      { "window", MiceWin,     1, {0}, 0},
      { "retval", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);
   window = (SpiceDouble*)mxGetData(prhs[3]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   *retval = wnincd_( (doublereal *) &left,
                      (doublereal *) &right,
                      (doublereal *) (window) );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wninsd_c ( SpiceDouble          left,
                                SpiceDouble          right,
                                SpiceCell          * window );
*/
void cspice_wninsd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble         left;
   SpiceDouble         right;

   SpiceInt            card;
   SpiceInt            size;

   int                 sizearray[2];

   SpiceDouble        * window;
   SpiceDouble        * window_f;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "left",   MiceDouble,  0, {0}, 0},
      { "right",  MiceDouble,  0, {0}, 0},
      { "window", MiceIgnore,  0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 2, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   left   = S_DBL_ARGV(1);
   right  = S_DBL_ARGV(2);

   /*
   The insert creates a new window with two elements.
   */
   card   = 0;
   size   = 2;

   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &card, ( double * ) window );

   wninsd_ ( (doublereal * )  &left,
             (doublereal * )  &right,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'cover' to 'cover_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'cover[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }




/*
   void              wnintd_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wnintd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b' (I think the proper value
   equals "size_a + size_b - 1" ).
   */
   size =  a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wnintd_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );
   }




/*
   SpiceBoolean      wnreld_c ( SpiceCell          * a,
                                ConstSpiceChar     * op,
                                SpiceCell          * b   );
*/
void cspice_wnreld(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * a;
   SpiceDouble        * b;

   SpiceChar            op[DEFAULT_STR_LENGTH+1];

   SpiceInt            a_size;
   SpiceInt            b_size;
   SpiceBoolean      * retval;

   struct extra_dims * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",      MiceWin,     1, {0}, 0},
      { "op",     MiceChar,    0, {0}, 0},
      { "b",      MiceWin,     1, {0}, 0},
      { "retval", MiceBoolean, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 3, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a      = (SpiceDouble*)mxGetData(prhs[1]);

   mxGetString(prhs[2], op, MAXLEN);

   b      = (SpiceDouble*)mxGetData(prhs[3]);
   retval = A_BOOL_RET_ARGV(0);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[3] ) - SPICE_CELL_CTRLSZ;

  /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   *retval = wnreld_( (doublereal * ) (a),
                      (char       * ) op,
                      (doublereal * ) (b),
                      (ftnlen       ) strlen(op)  );
   CHECK_CALL_FAILURE(SCALAR);

   }




/*
   void              wnsumd_c ( SpiceCell      * window,
                                SpiceDouble    * meas,
                                SpiceDouble    * avg,
                                SpiceDouble    * stddev,
                                SpiceInt       * shortest,
                                SpiceInt       * longest   )
*/
void mice_wnsumd(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble       * window;
   SpiceDouble         meas;
   SpiceDouble         avg;
   SpiceDouble         stddev;
   SpiceInt            shortest;
   SpiceInt            longest;

   SpiceInt            window_size;

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window", MiceWin,    1, {0}, 0},
      { "sumd",   MiceWnsumd, 0, {0}, 0},
      };

   check_arg_num( nrhs, nlhs, 1, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   The size of array 'window' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'window'
   without the append size.
   */
   window_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'window' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &window_size, ( double * ) window );
   scardd_( ( integer * ) &window_size, ( double * ) window );

   wnsumd_ ( ( doublereal * ) window,
             ( doublereal * ) &meas,
             ( doublereal * ) &avg,
             ( doublereal * ) &stddev,
             ( integer    * ) &shortest,
             ( integer    * ) &longest );
   CHECK_CALL_FAILURE(SCALAR);

   /*
   Copy the state vector and the lighttime value into the return structure.
   */

   mxDestroyArray( mxGetField( plhs[0], 0, "meas" ) );
   mxSetField( plhs[0], 0, "meas", mxCreateDoubleScalar(meas) );

   mxDestroyArray( mxGetField( plhs[0], 0, "avg" ) );
   mxSetField( plhs[0], 0, "avg", mxCreateDoubleScalar(avg) );

   mxDestroyArray( mxGetField(plhs[0], 0, "stddev" ) );
   mxSetField( plhs[0], 0, "stddev", mxCreateDoubleScalar(stddev) );

   mxDestroyArray( mxGetField( plhs[0], 0, "shortest" ) );
   mxSetField( plhs[0], 0, "shortest", zzmice_CreateIntScalar(shortest) );

   mxDestroyArray( mxGetField( plhs[0], 0, "longest" ) );
   mxSetField( plhs[0], 0, "longest", zzmice_CreateIntScalar(longest) );

   }




/*
   void              wnunid_c ( SpiceCell          * a,
                                SpiceCell          * b,
                                SpiceCell          * c  );
*/
void cspice_wnunid(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * a;
   SpiceDouble        * b;
   SpiceDouble        * c;
   SpiceDouble        * c_f;

   SpiceInt            card = 0;
   SpiceInt            size;

   SpiceInt            a_size;
   SpiceInt            b_size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "a",    MiceWin,    1, {0}, 0},
      { "b",    MiceWin,    1, {0}, 0},
      { "c",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 2, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   a = (SpiceDouble*)mxGetData(prhs[1]);
   b = (SpiceDouble*)mxGetData(prhs[2]);

   /*
   The size of array 'a' and 'b' includes an addition SPICE_CELL_CTRLSZ
   zero elements appended to the arrays. Calculate the size of 'a'
   and 'b' without the append size.
   */
   a_size = mxGetNumberOfElements( prhs[1] ) - SPICE_CELL_CTRLSZ;
   b_size = mxGetNumberOfElements( prhs[2] ) - SPICE_CELL_CTRLSZ;

   /*
   The maximum size of the output window 'c' equals no more than
   the size of 'a' plus the size of 'b' (when 'a' and 'b' do not
   intersect).
   */
   size = a_size + b_size;

   /*
   The interface wrapper appended a 6x1 zeros array to
   'a' and 'b' to provide a control segment. Use of the
   SPICE window routines requires this operation.
   */
   ssized_( ( integer * ) &a_size, ( double * ) a );
   scardd_( ( integer * ) &a_size, ( double * ) a );

   ssized_( ( integer * ) &b_size, ( double * ) b );
   scardd_( ( integer * ) &b_size, ( double * ) b );

   c = (SpiceDouble*)
        mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble) );

   ssized_( ( integer * ) &size, ( double * ) c );
   scardd_( ( integer * ) &card, ( double * ) c );

   wnunid_(  (doublereal *) (a),
             (doublereal *) (b),
             (doublereal *) (c));

   /*
   Check for a failure signal. Free the memory assigned to 'c'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( c );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = c[5];
   sizearray[1] = 1;

   plhs[0] = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   c_f     = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'c' to 'c_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'c[5]'
   elements.
   */
   MOVED( c + SPICE_CELL_CTRLSZ, c[5], c_f );
   mxFree( c );
   }




/*
   void              wnvald_c ( SpiceInt             size,
                                SpiceInt             n,
                                SpiceCell          * window );

*/
void cspice_wnvald(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble        * window_i;
   SpiceDouble        * window;
   SpiceDouble        * window_f;

   SpiceInt            size;
   int                 sizearray[2];

   struct extra_dims  * extra;
   struct argcheck ArgCheck[] =
      {
      { "window_i",    MiceWin,    1, {0}, 0},
      { "window_f",    MiceIgnore, 0, {0}, 0}
      };

   check_arg_num( nrhs, nlhs, 1, 1);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   window_i = (SpiceDouble*)mxGetData(prhs[1]);

   /*
   Calculate the size of 'window_i'. This corresponds to a CSPICE window
   size and cardinality for this case

   The maximum size of the work window 'window' equals no more than
   the size of 'window_i'.
   */
   size = mxGetNumberOfElements( prhs[1] );

   /*
   Allocate the memory for the window, provide the needed room for the
   control segment.
   */
   window = (SpiceDouble*)
             mxMalloc( (size + SPICE_CELL_CTRLSZ)*sizeof(SpiceDouble)  );

   /*
   Set to size and carfinality for the window before passing to CSPICE.
   */
   ssized_( ( integer * ) &size, ( double * ) window );
   scardd_( ( integer * ) &size, ( double * ) window );

   /*
   Copy the window data from the input window to the work window. The
   window data should begin at 'window' element SPICE_CELL_CTRLSZ.
   */
   MOVED( window_i, size, window  + SPICE_CELL_CTRLSZ);

   wnvald_ ( (integer    * ) &size,
             (integer    * ) &size,
             (doublereal * )  (window) );

   /*
   Check for a failure signal. Free the memory assigned to 'window'
   before signaling a Matlab error.
   */
   if ( failed_c())
      {
      mxFree( window );

      /*
      The mice_fail call creates the error string then returns control
      to the MATLAB interpreter.
      */
      mice_fail(SCALAR);
      }

   /*
   Array element 6, index 5, contains the cell cardinality. Create an output
   array CARDx1.
   */
   sizearray[0] = window[5];
   sizearray[1] = 1;

   plhs[0]  = mxCreateNumericArray( 2, sizearray, mxDOUBLE_CLASS, mxREAL);
   window_f = A_DBL_RET_ARGV(0);

   /*
   Copy the data contents of 'window' to 'window_f'. The set of window data
   starts at 'cover' array index SPICE_CELL_CTRLSZ and contains 'window[5]'
   elements.
   */
   MOVED( window + SPICE_CELL_CTRLSZ, window[5], window_f );
   mxFree( window );
   }





/*
   void              xf2eul_c ( ConstSpiceDouble     xform  [6][6],
                                SpiceInt             axisa,
                                SpiceInt             axisb,
                                SpiceInt             axisc,
                                SpiceDouble          eulang [6],
                                SpiceBoolean       * unique         );

*/
void cspice_xf2eul(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble        * vec_xform;
   SpiceDouble        * vec_eulang;
   SpiceBoolean       * vec_unique;
   SpiceInt             axisa;
   SpiceInt             axisb;
   SpiceInt             axisc;
   SpiceDouble        * xform;
   SpiceDouble        * eulang;
   SpiceBoolean       * unique;

   SpiceInt             i;
   SpiceDouble          xr[6][6];

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "xform",  MiceDouble,  2, {6, 6}, 1},
      { "axisa",  MiceInt,     0, {0},    0},
      { "axisb",  MiceInt,     0, {0},    0},
      { "axisc",  MiceInt,     0, {0},    0},
      { "eulang", MiceDouble,  1, {6},    1},
      { "unique", MiceBoolean, 0, {0},    1}
      };

   check_arg_num( nrhs, nlhs, 4, 2);

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_xform  = A_DBL_ARGV(1);
   axisa      = S_INT_ARGV(2);
   axisb      = S_INT_ARGV(3);
   axisc      = S_INT_ARGV(4);
   vec_eulang = A_DBL_RET_ARGV(0);
   vec_unique = A_BOOL_RET_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         xform  = (vec_xform  + i*extra->offset[0]);
         eulang = (vec_eulang + i*extra->offset[4]);
         unique = (vec_unique + i*extra->offset[5]);

         xpose6_c( xform, (SpiceDouble(*)[6])xr );

         xf2eul_c( xr, axisa, axisb, axisc, eulang, unique );
         CHECK_CALL_FAILURE(i);
         }

      }
   else
      {
      xform  = vec_xform;
      eulang = vec_eulang;
      unique = vec_unique;

      xpose6_c( xform, (SpiceDouble(*)[6])xr );

      xf2eul_c( xr, axisa, axisb, axisc, eulang, unique );
      CHECK_CALL_FAILURE(SCALAR);
      }

   }




/*
   void              xf2rav_c ( ConstSpiceDouble     xform [6][6],
                                SpiceDouble          rot   [3][3],
                                SpiceDouble          av    [3]     );
*/
void cspice_xf2rav(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {
   SpiceDouble  * vec_xform;
   SpiceDouble  * vec_rot;
   SpiceDouble  * vec_av;
   SpiceDouble  * xform;
   SpiceDouble  * rot;
   SpiceDouble  * av;
   SpiceDouble    xr[3][3];
   SpiceDouble    xf[6][6];

   SpiceInt       i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "xform", MiceDouble, 2, {6,6}, 1},
      { "rot",   MiceDouble, 2, {3,3}, 1},
      { "av",    MiceDouble, 1, {3},   1},
      };

   check_arg_num( nrhs, nlhs, 1, 2 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   vec_xform = A_DBL_ARGV(1);
   vec_rot   = A_DBL_RET_ARGV(0);
   vec_av    = A_DBL_RET_ARGV(1);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         xform = (vec_xform  + i*extra->offset[0]);
         rot   = (vec_rot    + i*extra->offset[1]);
         av    = (vec_av     + i*extra->offset[2]);

         xpose6_c( xform, (SpiceDouble(*)[6])xf );

         xf2rav_c( xf, (SpiceDouble(*)[3])xr, av );
         CHECK_CALL_FAILURE(i);

         xpose_c( xr, (SpiceDouble(*)[3])rot );
         }

      }
   else
      {

      xform = (vec_xform);
      rot   = (vec_rot);
      av    = (vec_av);

      xpose6_c( xform, (SpiceDouble(*)[6])xf );

      xf2rav_c( xf, (SpiceDouble(*)[3])xr, av );
      CHECK_CALL_FAILURE(SCALAR);

      xpose_c( xr, (SpiceDouble(*)[3])rot );
      }

   }




/*
   void xfmsta_c ( ConstSpiceDouble     input_state[6],
                   ConstSpiceChar     * input_coord_sys,
                   ConstSpiceChar     * output_coord_sys,
                   ConstSpiceChar     * body,
                   SpiceDouble          output_state[6]  )
*/
void cspice_xfmsta(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   SpiceDouble    * vec_input_state;
   SpiceDouble    * input_state;
   SpiceChar        input_coord_sys  [DEFAULT_STR_LENGTH+1];
   SpiceChar        output_coord_sys [DEFAULT_STR_LENGTH+1];
   SpiceChar        body             [DEFAULT_STR_LENGTH+1];
   SpiceDouble    * vec_output_state;
   SpiceDouble    * output_state;

   SpiceInt         i;

   struct extra_dims *extra;
   struct argcheck ArgCheck[] =
      {
      { "input_state",      MiceDouble, 1, {6}, 1},
      { "input_coord_sys",  MiceChar,   0, {0}, 0},
      { "output_coord_sys", MiceChar,   0, {0}, 0},
      { "body",             MiceChar,   0, {0}, 0},
      { "output_state",     MiceDouble, 1, {6}, 1},
      };

   check_arg_num( nrhs, nlhs, 4, 1 );

   extra = mice_checkargs(nlhs,plhs,nrhs,prhs,ArgCheck);

   mxGetString(prhs[2], input_coord_sys,  DEFAULT_STR_LENGTH);
   mxGetString(prhs[3], output_coord_sys, DEFAULT_STR_LENGTH);
   mxGetString(prhs[4], body,             DEFAULT_STR_LENGTH);

   vec_input_state  = A_DBL_ARGV(1);
   vec_output_state = A_DBL_RET_ARGV(0);

   input_state      = (vec_input_state);
   output_state     = (vec_output_state);

   if (extra->count>1)
      {

      for (i=0;i<extra->count;i++)
         {

         input_state  = (vec_input_state   + i*extra->offset[0]);
         output_state = (vec_output_state  + i*extra->offset[4]);

         xfmsta_c( input_state, input_coord_sys, output_coord_sys, body,
                   output_state );
         CHECK_CALL_FAILURE(i);

         }

      }
   else
      {

      xfmsta_c( input_state, input_coord_sys, output_coord_sys, body,
                output_state );
      CHECK_CALL_FAILURE(SCALAR);

      }

   }




/*
The cleanup routine called on exit.
*/
void mice_cleanup()
   {
   char                    msg[1024];

   hashtable_destroy();

   /*
   This error should never signal. If it does, an unknown error exists
   in the memory allocation routines - the computational equivalent
   of a warp core breach but with less noise.
   */
   if ( alloc_count() != 0 )
      {

      sprintf( msg, "\n"
                 "MICE(BUG): Memory allocation count not zero at "
                 "mexAtExit. Value = %d. This indicates an unexpected "
                 "error. Contact NAIF."
                 "\n\n",
                 alloc_count()  );
      mexErrMsgTxt(msg);
      }

   }




/*

   The routine called by MATLAB to access to external routines.

*/


/*
Now, with the interfaces defined above, include the name to function
pointer list.
*/
#include "npf_cspice.h"


void mexFunction( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
   {

   /*
   Size of array of function name/pointer pairs.
   */
   static int SIZE = sizeof(NPF)/sizeof(NPF[0]);

   /*
   Initialize hash table first time through.
   */
   static SpiceBoolean   first = SPICETRUE;
   int                   i;
   int                   n;
   char                  erract_buf[1024];
   char                * function_name;
   integer               divisor = HASHSIZE;

   void                (*function_reference)(int,
                                             mxArray*[],
                                             int,
                                             const mxArray*[]);

   /*
   Ensure the user doesn't try to directly call the Mice library
   without arguments. Bad user.
   */
   if( nrhs == 0 )
      {
      sprintf( erract_buf,
            "MICE(BOGUSENTRY): Usage error. Do not call the Mice MEX "
            "library without arguments. Access Mice functions by "
            "calling the cspice_*.m or mice_*.m wrappers.");
      mexErrMsgTxt( erract_buf );
      }

   if (first)
      {

      /*
      Initialize the values needed by the hash value functions.
      */
      zzshsh_( &divisor );

      /*
      Initialize hash table
      */
      memset( table, 0, sizeof(table) );

      for ( i=0; i<SIZE; i++)
         {
         hashtable_insert(NPF[i].name, NPF[i].pfunc);
         }

      /*
      By default, CSPICE calls exit() when an error occurs. This response
      causes the MATLAB application to exit (collapse).

      All interface functions immediately execute the CHECK_CALL_FAILURE
      macro calling their CSPICE namesakes. This macro checks the failure_c
      state, making the needed calls to create a MATLAB error message
      if an error occurs.

      Set the error status to RETURN and the error device to NULL.
      */
      zzerrorinit();

      /*
      This block need execute only once. Set the 'first' flag to false.
      */
      first = SPICEFALSE;

      /*
      Register the clean up routine, i.e. the routine executed when
      MATLAB terminates.
      */
      mexAtExit(mice_cleanup);
      }


   /*
   Retrieve the cspice routine name from the function call. Note,
   the first right hand value, prhs[0], for all interface calls
   is a pointer to the interface string name. mxGetN returns the number
   of columns in a MATLAB array; MATLAB defines a string as a 1XN
   vector of characters, so mxGetN returns the length (not null terminated
   length) of the string. When allocating memory for the string, allocate
   N + 1 to accommodate the null terminator.
   */
   n             = mxGetN(prhs[0]) + 1;
   function_name = mxCalloc( n, sizeof(char));

   /*
   Extract the string name from the pointer.
   */
   mxGetString( prhs[0], function_name, n);

   /*
   Now find the address of the function corresponding to the call name...
   */
   function_reference = hashtable_lookup(function_name);

   /*
   ...if found, execute that function. If not found, signal an error
   to the user.
   */
   if (function_reference)
      {
      (*function_reference)(nlhs, plhs, nrhs, prhs);
      }
   else
      {
      sprintf( erract_buf,
            "MICE(UNKNOWNCALL): Unknown CSPICE interface function call: %s\n",
             function_name);

      mexErrMsgTxt( erract_buf );
      }

   mxFree(function_name);
   }
