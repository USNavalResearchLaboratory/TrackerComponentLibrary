
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>raxisa_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>raxisa_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void raxisa_c ( ConstSpiceDouble     matrix[3][3],
                   SpiceDouble          axis  [3],
                   SpiceDouble        * angle       ) 

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Compute the axis of the rotation given by an input matrix 
   and the angle of the rotation about that axis. 
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/rotation.html">ROTATION</a> 
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   ANGLE,  MATRIX,  ROTATION 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   VARIABLE  I/O  DESCRIPTION 
   --------  ---  -------------------------------------------------- 
   matrix     I   3x3 rotation matrix in double precision. 
   axis       O   Axis of the rotation. 
   angle      O   Angle through which the rotation is performed. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   matrix     is a 3x3 rotation matrix in double precision. 
 </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   axis       is a unit vector pointing along the axis of the rotation.
              In other words, `axis' is a unit eigenvector of the input
              matrix, corresponding to the eigenvalue 1. If the input
              matrix is the identity matrix, `axis' will be the vector
              (0, 0, 1). If the input rotation is a rotation by pi
              radians, both `axis' and -axis may be regarded as the
              axis of the rotation.
 
   angle      is the angle between `v' and matrix*v for any non-zero
              vector `v' orthogonal to `axis'.  `angle' is given in
              radians.  The angle returned will be in the range from 0
              to pi radians.
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1) If the input matrix is not a rotation matrix (a fairly
      loose tolerance is used to check this) a routine in the
      call tree of this routine will signal an error indicating
      the problem.

   2) If the input matrix is the identity matrix, this routine
      returns an angle of 0.0, and an axis of ( 0.0, 0.0, 1.0 ).
      </PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   Every rotation matrix has an axis `a' such any vector `v'
   parallel to that axis satisfies the equation

      v = matrix * v

   This routine returns a unit vector `axis' parallel to the axis of
   the input rotation matrix.  Moreover for any vector `w' orthogonal
   to the axis of the rotation, the two vectors

       axis, 
       w x (matrix*w)

      (where &quot;x&quot; denotes the cross product operation)

   will be positive scalar multiples of one another (at least
   to within the ability to make such computations with double
   precision arithmetic, and under the assumption that `matrix'
   does not represent a rotation by zero or pi radians).

   The angle returned will be the angle between `w' and matrix*w
   for any vector orthogonal to `axis'.

   If the input matrix is a rotation by 0 or pi radians some
   choice must be made for the axis returned.  In the case of
   a rotation by 0 radians, `axis' is along the positive z-axis.
   In the case of a rotation by 180 degrees, two choices are
   possible.  The choice made this routine is unspecified.
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
    This routine can be used to numerically approximate the 
    instantaneous angular velocity vector of a rotating object. 
 
    Suppose that r(t) is the rotation matrix whose columns 
    represent the inertial pointing vectors of the bodyfixed 
    axes of an object at time t. 
 
    Then the angular velocity vector points along the vector 
    given by: 
                           T 
       limit  axis( r(t+h)r ) 
       h--&gt;0 
 
    And the magnitude of the angular velocity at time t is given by: 
 
                           T 
       d angle ( r(t+h)r(t) ) 
       ----------------------   at   h = 0 
       dh 
 
    Thus to approximate the angular velocity vector the following 
    code fragment will do 
 
       [ Load t      into the double precision variable t 
         Load h      into the double precision variable h 
         Load r(t+h) into the 3 by 3 double precision array rth 
         Load r(t)   into the 3 by 3 double precision array rt 
          . 
          . 
          . 
       ]
       
       /.
                                                    T
       Compute the infinitesimal rotation r(t+h)r(t)  
       ./
       <a href="mxmt_c.html">mxmt_c</a> ( rth, rt, infrot );

       /.
       Compute the axis and angle of the infinitesimal rotation.
       /.
       <b>raxisa_c</b> ( infrot, axis, &amp;angle );

       /.
       Scale axis to get the angular velocity vector.
       ./
       <a href="vscl_c.html">vscl_c</a> ( angle/h, axis, angvel ); 
 
 </PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
    1) If the input matrix is not a rotation matrix but is close enough
       to pass the tests this routine performs on it, no error will be
       signaled, but the results may have poor accuracy.
 
    2) The input matrix is taken to be an object that acts on (rotates)
       vectors---it is not regarded as a coordinate transformation.  To
       find the axis and angle of a coordinate transformation, input
       the transpose of that matrix to this routine.
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
    None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
    N.J. Bachman    (JPL)
    W.L. Taber      (JPL) 
    F.S. Turner     (JPL)  
  </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.0.1, 05-JAN-2005 (NJB) (WLT) (FST)

       Various header updates were made to reflect changes
       made to the underlying SPICELIB Fortran code.  
       Miscellaneous header corrections were made as well.    

   -CSPICE Version 1.0.0, 31-MAY-1999 (WLT) (NJB)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   rotation axis of a matrix 
 </PRE>
<h4>Link to routine raxisa_c source file <a href='../../../src/cspice/raxisa_c.c'>raxisa_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:31:41 2014</pre>

</body>
</html>

