
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>gfrfov_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>gfrfov_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void gfrfov_c ( ConstSpiceChar     * inst,
                   ConstSpiceDouble     raydir [3],
                   ConstSpiceChar     * rframe,
                   ConstSpiceChar     * abcorr,
                   ConstSpiceChar     * obsrvr,
                   SpiceDouble          step,
                   SpiceCell          * cnfine,
                   SpiceCell          * result  )   
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Determine time intervals when a specified ray intersects the 
   space bounded by the field-of-view (FOV) of a specified 
   instrument. 
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/ck.html">CK</a> 
   <a href="../req/frames.html">FRAMES</a> 
   <a href="../req/gf.html">GF</a> 
   <a href="../req/kernel.html">KERNEL</a> 
   <a href="../req/naif_ids.html">NAIF_IDS</a> 
   <a href="../req/pck.html">PCK</a> 
   <a href="../req/spk.html">SPK</a> 
   <a href="../req/time.html">TIME</a> 
   <a href="../req/windows.html">WINDOWS</a>   
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   EVENT 
   FOV 
   GEOMETRY 
   INSTRUMENT 
   SEARCH 
   WINDOW       
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   VARIABLE         I/O  DESCRIPTION 
   ---------------  ---  ------------------------------------------------ 
   SPICE_GF_MARGIN   P   Minimum complement of FOV cone angle.
   SPICE_GF_CNVTOL   P   Convergence tolerance. 
   SPICE_GF_MAXVRT   P   Maximum number of FOV boundary vertices. 
   inst              I   Name of the instrument. 
   raydir            I   Ray's direction vector. 
   rframe            I   Reference frame of ray's direction vector. 
   abcorr            I   Aberration correction flag. 
   obsrvr            I   Name of the observing body. 
   step              I   Step size in seconds for finding FOV events. 
   cnfine           I-O  SPICE window to which the search is restricted. 
   result            O   SPICE window containing results. 
    
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
 
   inst       indicates the name of an instrument, such as a 
              spacecraft-mounted framing camera, the field of view 
              (FOV) of which is to be used for an target intersection 
              search: the direction from the observer to a target 
              is represented by a ray, and times when the specified 
              ray intersects the region of space bounded by the FOV 
              are sought. 
 
              The position of the instrument designated by `inst' is 
              considered to coincide with that of the ephemeris 
              object designated by the input argument `obsrvr' (see 
              description below). 
 
              `inst' must have a corresponding NAIF ID and a frame 
              defined, as is normally done in a frame kernel. It 
              must also have an associated reference frame and a FOV 
              shape, boresight and boundary vertices (or reference 
              vector and reference angles) defined, as is usually 
              done in an instrument kernel. 
 
              See the header of the CSPICE routine <a href="getfov_c.html">getfov_c</a> for a 
              description of the required parameters associated with 
              an instrument. 
 
 
   raydir     is the direction vector associated with a ray 
              representing a target. The ray emanates from the 
              location of the ephemeris object designated by the 
              input argument `obsrvr' and is expressed relative to the 
              reference frame designated by `rframe' (see descriptions 
              below). 
 
 
   rframe     is the name of the reference frame associated with  
              the input ray's direction vector `raydir'. 
 
              Since light time corrections are not supported for 
              rays, the orientation of the frame is always evaluated 
              at the epoch associated with the observer, as opposed 
              to the epoch associated with the light-time corrected 
              position of the frame center. 
               
              Case and leading or trailing blanks bracketing a 
              non-blank frame name are not significant in the string 
              `rframe'. 
 
 
   abcorr     indicates the aberration corrections to be applied 
              when computing the ray's direction. 
 
              The supported aberration correction options are 
 
                 &quot;NONE&quot;          No correction. 
                 &quot;S&quot;             Stellar aberration correction, 
                                 reception case. 
                 &quot;XS&quot;            Stellar aberration correction, 
                                 transmission case. 
 
              For detailed information, see the geometry finder 
              required reading, gf.req.  
 
              Case, leading and trailing blanks are not significant 
              in the string `abcorr'. 
  
 
   obsrvr     is the name of the body from which the target 
              represented by `raydir' is observed. The instrument 
              designated by `inst' is treated as if it were co-located 
              with the observer. 


   step       is the step size to be used in the search. `step' must 
              be shorter than any interval, within the confinement 
              window, over which the specified condition is met. In 
              other words, `step' must be shorter than the shortest 
              visibility event that the user wishes to detect. `step' 
              also must be shorter than the minimum duration 
              separating any two visibility events. However, `step' 
              must not be *too* short, or the search will take an 
              unreasonable amount of time. 
 
              The choice of `step' affects the completeness but not 
              the precision of solutions found by this routine; the 
              precision is controlled by the convergence tolerance. 
              See the discussion of the parameter SPICE_GF_CNVTOL for 
              details. 
 
              `step' has units of seconds.  


   cnfine     is a SPICE window that confines the time period over 
              which the specified search is conducted. `cnfine' may 
              consist of a single interval or a collection of  
              intervals.  
 
              The endpoints of the time intervals comprising `cnfine'
              are interpreted as seconds past J2000 TDB.
               
              See the Examples section below for a code example  
              that shows how to create a confinement window.   
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
  
   cnfine     is the input confinement window, updated if necessary
              so the control area of its data array indicates the
              window's size and cardinality. The window data are
              unchanged.

 
   result     is a SPICE window representing the set of time 
              intervals, within the confinement period, when the 
              input ray is &quot;visible&quot;; that is, when the ray is 
              contained in the space bounded by the specified 
              instrument's field of view. 
 
              The endpoints of the time intervals comprising `result'
              are interpreted as seconds past J2000 TDB.

              If `result' is non-empty on input, its contents 
              will be discarded before <b>gfrfov_c</b> conducts its 
              search. 
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
  
   All parameters described here are declared in the header file
   SpiceGF.h. See that file for parameter values.

   SPICE_GF_CNVTOL     

              is the convergence tolerance used for finding endpoints
              of the intervals comprising the result window.
              SPICE_GF_CNVTOL is used to determine when binary searches
              for roots should terminate: when a root is bracketed
              within an interval of length SPICE_GF_CNVTOL, the root is
              considered to have been found.
 
              The accuracy, as opposed to precision, of roots found 
              by this routine depends on the accuracy of the input 
              data. In most cases, the accuracy of solutions will be 
              inferior to their precision. 

 
   SPICE_GF_MAXVRT   

              is the maximum number of vertices that may be used 
              to define the boundary of the specified instrument's 
              field of view. 
 

   SPICE_GF_MARGIN     

              is a small positive number used to constrain the
              orientation of the boundary vectors of polygonal
              FOVs. Such FOVs must satisfy the following constraints:

                 1)  The boundary vectors must be contained within
                     a right circular cone of angular radius less
                     than than (pi/2) - SPICE_GF_MARGIN radians; in other
                     words, there must be a vector A such that all
                     boundary vectors have angular separation from
                     A of less than (pi/2)-SPICE_GF_MARGIN radians.

                 2)  There must be a pair of boundary vectors U, V
                     such that all other boundary vectors lie in the
                     same half space bounded by the plane containing U
                     and V. Furthermore, all other boundary vectors
                     must have orthogonal projections onto a specific
                     plane normal to this plane (the normal plane
                     contains the angle bisector defined by U and V)
                     such that the projections have angular separation
                     of at least 2*SPICE_GF_MARGIN radians from the
                     plane spanned by U and V.
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
 
   1)  In order for this routine to produce correct results, 
       the step size must be appropriate for the problem at hand. 
       Step sizes that are too large may cause this routine to miss 
       roots; step sizes that are too small may cause this routine 
       to run unacceptably slowly and in some cases, find spurious 
       roots. 
 
       This routine does not diagnose invalid step sizes, except 
       that if the step size is non-positive, the error  
       SPICE(INVALIDSTEPSIZE) will be signaled. 
 
   2)  Due to numerical errors, in particular, 
 
          - Truncation error in time values 
          - Finite tolerance value 
          - Errors in computed geometric quantities 
 
       it is *normal* for the condition of interest to not always be 
       satisfied near the endpoints of the intervals comprising the 
       result window. 
 
       The result window may need to be contracted slightly by the 
       caller to achieve desired results. The SPICE window routine 
       WNCOND can be used to contract the result window. 
 
   3)  If the observer's name cannot be mapped to an ID code, the 
       error SPICE(IDCODENOTFOUND) is signaled. 
 
   4)  If the aberration correction flag calls for light time 
       correction, the error SPICE(INVALIDOPTION) is signaled. 
 
   5)  If the ray's direction vector is zero, the error 
       SPICE(ZEROVECTOR) is signaled. 
 
   6)  If the instrument name `inst' does not have corresponding NAIF 
       ID code, the error will be diagnosed by a routine in the call 
       tree of this routine. 
 
   7)  If the FOV parameters of the instrument are not present in 
       the kernel pool, the error will be be diagnosed by routines 
       in the call tree of this routine. 
 
   8)  If the FOV boundary has more than SPICE_GF_MAXVRT vertices, the error 
       will be be diagnosed by routines in the call tree of this 
       routine. 
  
   9)  If the instrument FOV is polygonal, and this routine cannot
       find a ray R emanating from the FOV vertex such that maximum
       angular separation of R and any FOV boundary vector is within
       the limit (pi/2)-SPICE_GF_MARGIN radians, the error will be diagnosed
       by a routine in the call tree of this routine. If the FOV
       is any other shape, the same error check will be applied with
       the instrument boresight vector serving the role of R.
 
   10) If the loaded kernels provide insufficient data to compute a 
       requested state vector, the error will be diagnosed by a 
       routine in the call tree of this routine. 
 
   11) If an error occurs while reading an SPK or other kernel file, 
       the error will be diagnosed by a routine in the call tree  
       of this routine. 
 
   12) If the output SPICE window `result' has insufficient capacity 
       to contain the number of intervals on which the specified 
       visibility condition is met, the error will be diagnosed 
       by a routine in the call tree of this routine. If the result 
       window has size less than 2, the error SPICE(WINDOWTOOSMALL) 
       will be signaled by this routine. 

   13) If any input string argument pointer is null, the error
       SPICE(NULLPOINTER) will be signaled.
 
   14) If any input string argument other than `tframe' is empty, the
       error SPICE(EMPTYSTRING) will be signaled.
 </PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   Appropriate SPICE kernels must be loaded by the calling program
   before this routine is called.
 
   The following data are required: 
 
      - SPK data:  ephemeris data for the observer for the period 
        defined by the confinement window `cnfine' must be loaded. 
        If aberration corrections are used, the state of the 
        observer relative to the solar system barycenter must be 
        calculable from the available ephemeris data. Typically 
        ephemeris data are made available by loading one or more SPK 
        files via <a href="furnsh_c.html">furnsh_c</a>. 
 
      - Data defining the reference frame associated with the 
        instrument designated by `inst' must be available in the kernel
        pool. Additionally the name `inst' must be associated with an
        ID code. Normally these data are  made available by loading a
        frame kernel via <a href="furnsh_c.html">furnsh_c</a>.
 
      - IK data: the kernel pool must contain data such that 
        the CSPICE routine <a href="getfov_c.html">getfov_c</a> may be called to obtain 
        parameters for `inst'. Normally such data are provided by 
        an IK via <a href="furnsh_c.html">furnsh_c</a>. 
 
   The following data may be required: 
 
      - CK data: if the instrument frame is fixed to a spacecraft, 
        at least one CK file will be needed to permit transformation 
        of vectors between that frame and the J2000 frame. 
 
      - SCLK data: if a CK file is needed, an associated SCLK 
        kernel is required to enable conversion between encoded SCLK 
        (used to time-tag CK data) and barycentric dynamical time 
        (TDB). 
 
      - Since the input ray direction may be expressed in any  
        frame, FKs, CKs, SCLK kernels, PCKs, and SPKs may be 
        required to map the direction to the J2000 frame. 
 
   Kernel data are normally loaded once per program run, NOT every 
   time this routine is called. 
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   This routine determines a set of one or more time intervals when 
   the specified ray in contained within the field of view of a 
   specified instrument. We'll use the term &quot;visibility event&quot; to 
   designate such an appearance. The set of time intervals resulting 
   from the search is returned as a SPICE window. 
 
   This routine provides a simpler, but less flexible, interface 
   than does the CSPICE routine <a href="gffove_c.html">gffove_c</a> for conducting searches for 
   visibility events. Applications that require support for progress 
   reporting, interrupt handling, non-default step or refinement 
   functions, or non-default convergence tolerance should call 
   <a href="gffove_c.html">gffove_c</a> rather than this routine. 
 
   Below we discuss in greater detail aspects of this routine's 
   solution process that are relevant to correct and efficient use 
   of this routine in user applications. 
 
 
   The Search Process 
   ================== 
 
   The search for visibility events is treated as a search for state 
   transitions: times are sought when the state of the ray 
   changes from &quot;not visible&quot; to &quot;visible&quot; or vice versa. 
 
   Step Size 
   ========= 
 
   Each interval of the confinement window is searched as follows: 
   first, the input step size is used to determine the time 
   separation at which the visibility state will be sampled. 
   Starting at the left endpoint of an interval, samples will be 
   taken at each step. If a state change is detected, a root has 
   been bracketed; at that point, the &quot;root&quot;--the time at which the 
   state change occurs---is found by a refinement process, for 
   example, via binary search. 
 
   Note that the optimal choice of step size depends on the lengths 
   of the intervals over which the visibility state is constant: 
   the step size should be shorter than the shortest visibility event 
   duration and the shortest period between visibility events, within 
   the confinement window. 
 
   Having some knowledge of the relative geometry of the ray and 
   observer can be a valuable aid in picking a reasonable step size. 
   In general, the user can compensate for lack of such knowledge by 
   picking a very short step size; the cost is increased computation 
   time. 
 
   Note that the step size is not related to the precision with which 
   the endpoints of the intervals of the result window are computed. 
   That precision level is controlled by the convergence tolerance. 
 
 
   Convergence Tolerance 
   ===================== 
 
   Once a root has been bracketed, a refinement process is used to 
   narrow down the time interval within which the root must lie. 
   This refinement process terminates when the location of the root 
   has been determined to within an error margin called the 
   &quot;convergence tolerance.&quot; The convergence tolerance used by this 
   routine is set via the parameter SPICE_GF_CNVTOL. 
  
   The value of SPICE_GF_CNVTOL is set to a &quot;tight&quot; value so that the 
   tolerance doesn't become the limiting factor in the accuracy of 
   solutions found by this routine. In general the accuracy of input 
   data will be the limiting factor. 
 
   To use a different tolerance value, a lower-level GF routine such 
   as <a href="gffove_c.html">gffove_c</a>  must be called. Making the tolerance tighter than 
   SPICE_GF_CNVTOL is unlikely to be useful, since the results are unlikely 
   to be more accurate. Making the tolerance looser will speed up 
   searches somewhat, since a few convergence steps will be omitted. 
   However, in most cases, the step size is likely to have a much 
   greater effect on processing time than would the convergence 
   tolerance. 
 
 
   The Confinement Window 
   ====================== 
 
   The simplest use of the confinement window is to specify a time 
   interval within which a solution is sought. However, the confinement
   window can, in some cases, be used to make searches more efficient.
   Sometimes it's possible to do an efficient search to reduce the size
   of the time period over which a relatively slow search of interest
   must be performed. For an example, see the program CASCADE in the GF
   Example Programs chapter of the GF Required Reading, gf.req.
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
  
   The numerical results shown for these examples may differ across 
   platforms. The results depend on the SPICE kernels used as 
   input, the compiler and supporting libraries, and the machine  
   specific arithmetic implementation.  
 
 
   1) This example is an extension of example #1 in the
      header of 

         <a href="gftfov_c.html">gftfov_c</a>

      The problem statement for that example is

         Search for times when Saturn's satellite Phoebe is within the
         FOV of the Cassini narrow angle camera (CASSINI_ISS_NAC). To
         simplify the problem, restrict the search to a short time
         period where continuous Cassini bus attitude data are
         available.
 
         Use a step size of 10 seconds to reduce chances of missing
         short visibility events.

      Here we search the same confinement window for times when a
      selected background star is visible. We use the FOV of the
      Cassini ISS wide angle camera (CASSINI_ISS_WAC) to enhance the
      probability of viewing the star.
 
      The star we'll use has catalog number 6000 in the Hipparcos
      Catalog. The star's J2000 right ascension and declination, proper
      motion, and parallax are taken from that catalog.
       
      Use the meta-kernel from the <a href="gftfov_c.html">gftfov_c</a> example:

         
         KPL/MK 
 
         File name: gftfov_ex1.tm

         This meta-kernel is intended to support operation of SPICE 
         example programs. The kernels shown here should not be 
         assumed to contain adequate or correct versions of data 
         required by SPICE-based user applications. 
 
         In order for an application to use this meta-kernel, the 
         kernels referenced here must be present in the user's 
         current working directory. 
 
         The names and contents of the kernels referenced 
         by this meta-kernel are as follows: 
 
            File name                     Contents 
            ---------                     -------- 
            naif0009.tls                  Leapseconds 
            cpck05Mar2004.tpc             Satellite orientation and 
                                          radii 
            981005_PLTEPH-DE405S.bsp      Planetary ephemeris 
            020514_SE_SAT105.bsp          Satellite ephemeris 
            030201AP_SK_SM546_T45.bsp     Spacecraft ephemeris 
            cas_v37.tf                    Cassini FK 
            04135_04171pc_psiv2.bc        Cassini bus CK 
            cas00084.tsc                  Cassini SCLK kernel 
            cas_iss_v09.ti                Cassini IK 
             
 
         \begindata 
 
            KERNELS_TO_LOAD = ( 'naif0009.tls', 
                                'cpck05Mar2004.tpc', 
                                '981005_PLTEPH-DE405S.bsp', 
                                '020514_SE_SAT105.bsp', 
                                '030201AP_SK_SM546_T45.bsp', 
                                'cas_v37.tf', 
                                '04135_04171pc_psiv2.bc', 
                                'cas00084.tsc', 
                                'cas_iss_v09.ti'            ) 
         \begintext 
 
 
 
      Example code begins here. 


         #include &lt;stdio.h&gt;
         #include &lt;stdlib.h&gt;
         #include &lt;math.h&gt;
         #include &quot;SpiceUsr.h&quot;
         #include &quot;SpiceZmc.h&quot;

         int main()
         {
            /.
            PROGRAM EX1 
            ./

            /. 
            Local constants 
            ./ 
            #define  AU             149597870.693
            #define  META           &quot;gftfov_ex1.tm&quot;
            #define  TIMFMT         &quot;YYYY-MON-DD HR:MN:SC.######::TDB (TDB)&quot;
            #define  TIMLEN         41
            #define  MAXWIN         10000

            /.
            Local variables 
            ./
            SPICEDOUBLE_CELL ( cnfine, MAXWIN );
            SPICEDOUBLE_CELL ( result, MAXWIN );

            SpiceChar             * abcorr;
            SpiceChar             * inst;
            SpiceChar             * obsrvr;
            SpiceChar             * rframe;
            SpiceChar               timstr  [2][ TIMLEN ];

            SpiceDouble             dec;
            SpiceDouble             dec_deg;
            SpiceDouble             dec_deg_0;
            SpiceDouble             dec_epoch;
            SpiceDouble             dec_pm;
            SpiceDouble             dtdec;
            SpiceDouble             dtra;
            SpiceDouble             endpt   [2];
            SpiceDouble             et0;
            SpiceDouble             et1;
            SpiceDouble             lt;
            SpiceDouble             parallax;
            SpiceDouble             parallax_deg;
            SpiceDouble             pos     [3];
            SpiceDouble             ra;
            SpiceDouble             ra_deg;
            SpiceDouble             ra_deg_0;
            SpiceDouble             ra_epoch;
            SpiceDouble             ra_pm;
            SpiceDouble             raydir  [3];
            SpiceDouble             stardist;
            SpiceDouble             starpos [3];
            SpiceDouble             stepsz;
            SpiceDouble             t;

            SpiceInt                catno;
            SpiceInt                i;
            SpiceInt                j;
            SpiceInt                n;

            /.
            Load kernels. 
            ./
            <a href="furnsh_c.html">furnsh_c</a> ( META );

            /.
            Insert search time interval bounds into the
            confinement window.
            ./
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 06:30:00 TDB&quot;, &amp;et0 );
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 12:00:00 TDB&quot;, &amp;et1 );

            <a href="wninsd_c.html">wninsd_c</a> ( et0, et1, &amp;cnfine );

            /.
            Initialize inputs for the search.
            ./
            inst   = &quot;CASSINI_ISS_WAC&quot;;

            /.
            Create a unit direction vector pointing from observer to star. 
            We'll assume the direction is constant during the confinement
            window, and we'll use et0 as the epoch at which to compute the
            direction from the spacecraft to the star.

            The data below are for the star with catalog number 6000
            in the Hipparcos catalog. Angular units are degrees; epochs
            have units of Julian years and have a reference epoch of J1950.
            The reference frame is J2000.
            ./
            catno        = 6000;

            parallax_deg = 0.000001056;

            ra_deg_0     = 19.290789927;
            ra_pm        = -0.000000720;
            ra_epoch     = 41.2000;

            dec_deg_0    =  2.015271007;
            dec_pm       =  0.000001814;
            dec_epoch    = 41.1300;

            rframe       = &quot;J2000&quot;;

            /.
            Correct the star's direction for proper motion.

            The argument t represents et0 as Julian years past J1950. 
            ./
            t         = et0/<a href="jyear_c.html">jyear_c</a>()  +  ( <a href="j2000_c.html">j2000_c</a>()- <a href="j1950_c.html">j1950_c</a>() )/365.25;

            dtra      = t - ra_epoch;
            dtdec     = t - dec_epoch;

            ra_deg    = ra_deg_0  +  dtra  * ra_pm;
            dec_deg   = dec_deg_0 +  dtdec * dec_pm;

            ra        = ra_deg  * <a href="rpd_c.html">rpd_c</a>();
            dec       = dec_deg * <a href="rpd_c.html">rpd_c</a>();

            <a href="radrec_c.html">radrec_c</a> ( 1.0, ra, dec, starpos );

            /.
            Correct star position for parallax applicable at 
            the Cassini orbiter's position. (The parallax effect
            is negligible in this case; we're simply demonstrating
            the computation.)
            ./
            parallax = parallax_deg * <a href="rpd_c.html">rpd_c</a>();
            stardist = AU / tan(parallax);

            /.
            Scale the star's direction vector by its distance from
            the solar system barycenter. Subtract off the position
            of the spacecraft relative to the solar system barycenter;
            the result is the ray's direction vector.
            ./
            <a href="vscl_c.html">vscl_c</a>   ( stardist, starpos, starpos );

            <a href="spkpos_c.html">spkpos_c</a> ( &quot;cassini&quot;, et0, &quot;J2000&quot;,  &quot;NONE&quot;, 
                       &quot;solar system barycenter&quot;, pos,  &amp;lt );

            <a href="vsub_c.html">vsub_c</a>   ( starpos, pos, raydir );

            /.
            Correct the star direction for stellar aberration when
            we conduct the search. 
            ./
            abcorr = &quot;S&quot;;
            obsrvr = &quot;CASSINI&quot;;
            stepsz = 10.0;

            printf ( &quot;\n&quot;
                     &quot; Instrument:            %s\n&quot;
                     &quot; Star's catalog number: %ld\n&quot;
                     &quot;\n&quot;,
                     inst,
                     catno            );

            /.
            Perform the search.
            ./
            <b>gfrfov_c</b> ( inst,   raydir, rframe,  abcorr, 
                       obsrvr, stepsz, &amp;cnfine, &amp;result );


            n = <a href="wncard_c.html">wncard_c</a> ( &amp;result );

            if ( n == 0 )
            {
               printf (  &quot;No FOV intersection found.\n&quot; );
            }
            else
            {
               printf ( &quot;  Visibility start time              Stop time\n&quot; );

               for ( i = 0;  i &lt; n;  i++ )
               {
                  <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;result, i, endpt, endpt+1 );

                  for ( j = 0;  j &lt; 2;  j++ )
                  {
                     <a href="timout_c.html">timout_c</a> ( endpt[j], TIMFMT, TIMLEN, timstr[j] );
                  }

                  printf ( &quot;  %s  %s\n&quot;,
                           timstr[0],
                           timstr[1]                                   ); 
               }      
            }

            printf ( &quot;\n&quot; );

            return ( 0 );
         }


      When this program was executed on a PC/Linux/gcc platform, the 
      output was: 
 

         Instrument:            CASSINI_ISS_WAC
         Star's catalog number: 6000

          Visibility start time              Stop time
          2004-JUN-11 06:30:00.000000 (TDB)  2004-JUN-11 12:00:00.000000 (TDB)


      The star is visible throughout the confinement window.

 </PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   The kernel files to be used by <b>gfrfov_c</b> must be loaded (normally via 
   the CSPICE routine <a href="furnsh_c.html">furnsh_c</a>) before <b>gfrfov_c</b> is called. 
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman  (JPL) 
   L.S. Elson    (JPL) 
   E.D. Wright   (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.0.0, 12-FEB-2009 (NJB) (LSE) (EDW)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   GF ray in instrument FOV search
</PRE>
<h4>Link to routine gfrfov_c source file <a href='../../../src/cspice/gfrfov_c.c'>gfrfov_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:31:35 2014</pre>

</body>
</html>

