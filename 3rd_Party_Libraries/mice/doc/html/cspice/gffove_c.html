
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>gffove_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>gffove_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void gffove_c ( ConstSpiceChar     * inst,
                   ConstSpiceChar     * tshape,
                   ConstSpiceDouble     raydir [3],
                   ConstSpiceChar     * target,
                   ConstSpiceChar     * tframe,
                   ConstSpiceChar     * abcorr,
                   ConstSpiceChar     * obsrvr,
                   SpiceDouble          tol,
                   void             ( * udstep ) ( SpiceDouble       et,
                                                   SpiceDouble     * step ),

                   void             ( * udrefn ) ( SpiceDouble       t1,
                                                   SpiceDouble       t2,
                                                   SpiceBoolean      s1,
                                                   SpiceBoolean      s2,
                                                   SpiceDouble     * t    ),
                   SpiceBoolean         rpt,  

                   void             ( * udrepi ) ( SpiceCell       * cnfine,
                                                   ConstSpiceChar  * srcpre,
                                                   ConstSpiceChar  * srcsuf ),

                   void             ( * udrepu ) ( SpiceDouble       ivbeg,
                                                   SpiceDouble       ivend,
                                                   SpiceDouble       et      ),

                   void             ( * udrepf ) ( void ),
                   SpiceBoolean         bail,      
                   SpiceBoolean     ( * udbail ) ( void ),
                   SpiceCell          * cnfine,
                   SpiceCell          * result                                )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Determine time intervals when a specified target body or ray
   intersects the space bounded by the field-of-view (FOV) of a
   specified instrument. Report progress and handle interrupts if so
   commanded.
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/ck.html">CK</a> 
   <a href="../req/frames.html">FRAMES</a> 
   <a href="../req/gf.html">GF</a> 
   <a href="../req/kernel.html">KERNEL</a> 
   <a href="../req/naif_ids.html">NAIF_IDS</a> 
   <a href="../req/pck.html">PCK</a> 
   <a href="../req/spk.html">SPK</a> 
   <a href="../req/time.html">TIME</a> 
   <a href="../req/windows.html">WINDOWS</a>   
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   EVENT 
   FOV 
   GEOMETRY 
   INSTRUMENT 
   SEARCH 
   WINDOW       
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   VARIABLE  I/O  DESCRIPTION 
   --------  ---  -------------------------------------------------- 
   SPICE_GF_MARGIN    
              P   Minimum complement of FOV cone angle.
   SPICE_GF_CNVTOL     
              P   Convergence tolerance. 
   SPICE_GF_MAXVRT     
              P   Maximum number of FOV boundary vertices. 
   inst       I   Name of the instrument. 
   tshape     I   Type of shape model used for target body. 
   raydir     I   Ray's direction vector. 
   target     I   Name of the target body. 
   tframe     I   Body-fixed, body-centered frame for target body. 
   abcorr     I   Aberration correction flag. 
   obsrvr     I   Name of the observing body. 
   tol        I   Convergence tolerance in seconds. 
   udstep     I   Name of the routine returns a time step. 
   udrefn     I   Name of the routine that computes a refined time. 
   rpt        I   Progress report flag. 
   udrepi     I   Function that initializes progress reporting. 
   udrepu     I   Function that updates the progress report. 
   udrepf     I   Function that finalizes progress reporting. 
   bail       I   Logical indicating program interrupt monitoring. 
   udbail     I   Name of a routine that signals a program interrupt.
   cnfine    I-O  SPICE window to which the search is restricted. 
   result     O   SPICE window containing results. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   inst       indicates the name of an instrument, such as a 
              spacecraft-mounted framing camera, the field of view 
              (FOV) of which is to be used for a target intersection 
              search: times when the specified target intersects the 
              region of space corresponding to the FOV are sought. 
 
              `inst' must have a corresponding NAIF ID and a frame 
              defined, as is normally done in a frame kernel. It 
              must also have an associated reference frame and a FOV 
              shape, boresight and boundary vertices (or reference 
              vector and reference angles) defined, as is usually 
              done in an instrument kernel. 
 
              See the header of the CSPICE routine <a href="getfov_c.html">getfov_c</a> for a 
              description of the required parameters associated with 
              an instrument. 
 
 
   tshape     is a string indicating the geometric model used to 
              represent the location and shape of the target body. 
              The target body may be represented by either an 
              ephemeris object or a ray emanating from the observer. 
 
              The supported values of `tshape' are: 
 
                 &quot;ELLIPSOID&quot;     The target is an ephemeris object. 
 
                                 The target's shape is represented 
                                 using triaxial ellipsoid model, 
                                 with radius values provided via the 
                                 kernel pool. A kernel variable 
                                 having a name of the form 
 
                                    &quot;BODYnnn_RADII&quot;  
 
                                 where nnn represents the NAIF 
                                 integer code associated with the 
                                 body, must be present in the kernel 
                                 pool. This variable must be 
                                 associated with three numeric 
                                 values giving the lengths of the 
                                 ellipsoid's X, Y, and Z semi-axes. 
 
                 &quot;POINT&quot;         The target is an ephemeris object. 
                                 The body is treated as a single 
                                 point. 
 
                 &quot;RAY&quot;           The target is NOT an ephemeris 
                                 object. Instead, the target is
                                 represented by the ray emanating from
                                 the observer's location and having
                                 direction vector `raydir'. The target
                                 is considered to be visible if and
                                 only if the ray is contained within
                                 the space bounded by the instrument
                                 FOV.
 
              Case and leading or trailing blanks are not 
              significant in the string `tshape'. 
 
 
   raydir     is the direction vector associated with a ray  
              representing the target. `raydir' is used if and only 
              if `tshape' (see description above) indicates the 
              target is modeled as a ray. 
 
 
   target     is the name of the target body, the appearances of 
              which in the specified instrument's field of view are 
              sought. The body must be an ephemeris object. 
 
              Optionally, you may supply the integer NAIF ID code 
              for the body as a string. For example both &quot;MOON&quot; and 
              &quot;301&quot; are legitimate strings that designate the Moon. 
 
              Case and leading or trailing blanks are not 
              significant in the string `target'. 
 
              The input argument `target' is used if and only if the 
              target is NOT modeled as ray, as indicated by the
              input argument `tshape'.
 
              `target' may be set to a blank string if the target is 
              modeled as a ray. 
 
 
   tframe     is the name of the reference frame associated with the 
              target. Examples of such names are &quot;IAU_SATURN&quot; 
              (for Saturn) and &quot;ITRF93&quot; (for the Earth). 
 
              If the target is an ephemeris object modeled as an 
              ellipsoid, `tframe' must designate a body-fixed 
              reference frame centered on the target body. 
 
              If the target is an ephemeris object modeled as a point,
              `tframe' is ignored; `tframe' should be left blank.
 
              If the target is modeled as a ray, `tframe' may 
              designate any reference frame. Since light time 
              corrections are not supported for rays, the 
              orientation of the frame is always evaluated at the 
              epoch associated with the observer, as opposed to the 
              epoch associated with the light-time corrected 
              position of the frame center. 
               
              Case and leading or trailing blanks bracketing a 
              non-blank frame name are not significant in the string 
              `tframe'.  
 
 
   abcorr     indicates the aberration corrections to be applied 
              when computing the target's position and orientation. 
              The supported values of `abcorr' depend on the target 
              representation. 
 
              If the target is represented by a ray, the aberration 
              correction options are 
 
                 &quot;NONE&quot;          No correction. 
                 &quot;S&quot;             Stellar aberration correction, 
                                 reception case. 
                 &quot;XS&quot;            Stellar aberration correction, 
                                 transmission case. 
 
              If the target is an ephemeris object, the aberration 
              correction options are those supported by the SPICE 
              SPK system. For remote sensing applications, where the 
              apparent position and orientation of the target seen 
              by the observer are desired, normally either of the 
              corrections 
             
                 'LT+S'  
                 'CN+S' 
    
              should be used. These and the other supported options 
              are described below.  
 
              Supported aberration correction options for 
              observation (the case where radiation is received by 
              observer at ET) are: 
 
                 &quot;NONE&quot;       No correction. 
                 &quot;LT&quot;         Light time only 
                 'LT+S'       Light time and stellar aberration. 
                 &quot;CN&quot;         Converged Newtonian (CN) light time. 
                 'CN+S'       CN light time and stellar aberration. 
 
              Supported aberration correction options for 
              transmission (the case where radiation is emitted from 
              observer at ET) are: 
 
                 &quot;XLT&quot;        Light time only. 
                 'XLT+S'      Light time and stellar aberration. 
                 &quot;XCN&quot;        Converged Newtonian (CN) light time. 
                 'XCN+S'      CN light time and stellar aberration. 
 
              For detailed information, see the geometry finder 
              required reading, gf.req.  
 
              Case, leading and trailing blanks are not significant 
              in the string `abcorr'. 
  
 
   obsrvr     is the name of the body from which the target is 
              observed. The instrument designated by `inst' is treated 
              as if it were co-located with the observer. 
 
              Optionally, you may supply the integer NAIF ID code 
              for the body as a string. 
 
              Case and leading or trailing blanks are not 
              significant in the string `obsrvr'. 
 
   
   tol        is a tolerance value used to determine convergence of
              root-finding operations. `tol' is measured in TDB seconds
              and must be greater than zero.
 
 
   udstep     is an externally specified routine that computes a time
              step used to find transitions of the state being
              considered. A state transition occurs where the state
              changes from being &quot;in view&quot; to being &quot;not in view&quot; or
              vice versa.
          
              This routine relies on `udstep' returning step sizes 
              small enough so that state transitions within the 
              confinement window are not overlooked.  
  
              The prototype for `udstep' is
 
                 void   ( * udstep ) ( SpiceDouble       et,
                                       SpiceDouble     * step )

              where: 
 
                 et      is the input start time from which the 
                         algorithm is to search forward for a state 
                         transition. `et' is expressed as seconds past 
                         J2000 TDB.  
 
                 step    is the output step size. `step' indicates 
                         how far to advance `et' so that `et' and 
                         et+step may bracket a state transition and 
                         definitely do not bracket more than one 
                         state transition. Units are TDB seconds. 
 
              If a constant step size is desired, the CSPICE routine 

                 <a href="gfstep_c.html">gfstep_c</a> 
 
              may be used as the step size function. If <a href="gfstep_c.html">gfstep_c</a> is
              used, the step size must be set by calling <a href="gfsstp_c.html">gfsstp_c</a> prior
              to calling this routine.
 
 
   udrefn     is the name of the externally specified routine that 
              computes a refinement in the times that bracket a 
              transition point. In other words, once a pair of 
              times have been detected such that the system is in 
              different states at each of the two times, `udrefn' 
              selects an intermediate time which should be closer to 
              the transition state than one of the two known times. 
              The prototype for `udrefn' is: 
 
                 void   ( * udrefn ) ( SpiceDouble       t1,
                                       SpiceDouble       t2,
                                       SpiceBoolean      s1,
                                       SpiceBoolean      s2,
                                       SpiceDouble     * t   )
 
              where the inputs are: 
 
                 t1    is a time when the visibility state is `s1'. `t1'
                       is expressed as seconds past J2000 TDB.
 
                 t2    is a time when the system is in state `s2'. `t2'
                       is expressed as seconds past J2000 TDB. `t2' is
                       assumed to be larger than `t1'.
 
                 s1    is the visibility state at time at time t1. 

                 s2    is the visibility state at time at time t2. 
  
              The output is: 
 
                 t     is next time to check for a state transition.
                       `t' is a number between `t1' and `t2'. `t' is
                       expressed as seconds past J2000 TDB.
 
              If a simple bisection method is desired, the CSPICE routine 
              <a href="gfrefn_c.html">gfrefn_c</a> may be used as the refinement function.
 
 
   rpt        is a logical variable that controls whether 
              progress reporting is enabled. When `rpt' is SPICETRUE, 
              progress reporting is enabled and the routines 
              udrepi, udrepu, and udpref (see descriptions below) 
              are used to report progress.  
  
 
   udrepi     is a user-defined subroutine that initializes a 
              progress report.  When progress reporting is  
              enabled, `udrepi' is called at the start 
              of a search. The prototype for `udrefi' is

                 void   ( * udrepi ) ( SpiceCell       * cnfine,
                                       ConstSpiceChar  * srcpre,
                                       ConstSpiceChar  * srcsuf )
 
              where 
 
                 cnfine  
 
              is a confinement window specifying the time period
              over which a search is conducted, and
  
                 srcpre 
                 srcsuf 
 
              are prefix and suffix strings used in the progress 
              report: these strings are intended to bracket a  
              representation of the fraction of work done. For
              example, when the CSPICE progress reporting functions
              are used, if srcpre and srcsuf are, respectively,

                 &quot;FOV search&quot;
                 &quot;done.&quot;
 
              the progress report display at the end of
              the search will be:

                 FOV search 100.00% done.

              The CSPICE routine <a href="gfrepi_c.html">gfrepi_c</a> may be used as the
              actual argument corresponding to `udrepi'. If so,
              the CSPICE routines <a href="gfrepu_c.html">gfrepu_c</a> and <a href="gfrepf_c.html">gfrepf_c</a> must be
              the actual arguments corresponding to `udrepu' and
              `udrepf'.
 
             
   udrepu     is a user-defined subroutine that updates the  
              progress report for a search.  The prototype
              of `udrepu' is 
  
                 void   ( * udrepu ) ( SpiceDouble       ivbeg,
                                       SpiceDouble       ivend,
                                       SpiceDouble       et      )
 
              In order for a meaningful progress report to be displayed,
              `ivbeg' and `ivend' must satisfy the following constraints:

                 - `ivbeg' must be less than or equal to `ivend'. 

                 - Over a search, the sum of the differences 

                      ivend - ivbeg

                   for all calls to this routine made during the search
                   must equal the measure (that is, the sum of the 
                   lengths of the intervals) of the confinement window
                   `cnfine'.

              `et' is the current time reached in the search for an event. 
              `et' must lie in the interval  

                 ivbeg : ivend 

              inclusive. The input values of `et' for a given interval 
              need not form an increasing sequence.  

              The CSPICE routine <a href="gfrepu_c.html">gfrepu_c</a> may be used as the actual
              argument corresponding to `udrepu'. If so, the CSPICE
              routines <a href="gfrepi_c.html">gfrepi_c</a> and <a href="gfrepf_c.html">gfrepf_c</a> must be the actual
              arguments corresponding to `udrepi' and `udrepf'.

 
   udrepf     is a user-defined subroutine that finalizes a progress
              report. `udrepf' has no arguments.
 
              The CSPICE routine <a href="gfrepf_c.html">gfrepf_c</a> may be used as the actual
              argument corresponding to `udrepf'. If so, the CSPICE
              routines <a href="gfrepi_c.html">gfrepi_c</a> and <a href="gfrepu_c.html">gfrepu_c</a> must be the actual
              arguments corresponding to `udrepi' and `udrepu'.
 
 
   bail       is a logical variable indicating whether or not interrupt
              handling is enabled. When `bail' is set to SPICETRUE, the
              input function `udbail' (see description below) is used
              to determine whether an interrupt has been issued.
 
 
   udbail     is the name of a user defined logical function that
              indicates whether an interrupt signal has been issued
              (for example, from the keyboard). udbail has the
              prototype

                 SpiceBoolean   ( * udbail ) ( void )

              The return value is SPICETRUE if an interrupt has 
              been issued; otherwise the value is SPICEFALSE.

              <b>gffove_c</b> uses `udbail' only when `bail' (see above) is set 
              to SPICETRUE, indicating that interrupt handling is 
              enabled. When interrupt handling is enabled, <b>gffove_c</b> 
              and routines in its call tree will call `udbail' to 
              determine whether to terminate processing and return 
              immediately.                

              If the user doesn't wish to provide a custom interrupt
              handling function, the CSPICE routine

                 <a href="gfbail_c.html">gfbail_c</a>

              may be used.   

              The function `udbail' will be usually be tested
              multiple times by the GF system between the time
              an interrupt is issued and the time when 
              control is returned to the calling program, so
              `udbail' nmust continue to return SPICETRUE
              until explicitly reset by the calling application.
              So `udbail' must provide a &quot;reset&quot; mechanism.&quot;
              In the case of <a href="gfbail_c.html">gfbail_c</a>, the reset function is
              
                 <a href="gfclrh_c.html">gfclrh_c</a>              

              If interrupt handing is not enabled, a logical 
              function must still be passed to <b>gffove_c</b> as 
              an input argument. The CSPICE function  
 
                 <a href="gfbail_c.html">gfbail_c</a> 
       
              may be used for this purpose. 
 
              See the Examples header section below for a complete code
              example demonstrating use of the CSPICE interrupt
              handling capability.


   cnfine     is a SPICE window that confines the time period over 
              which the specified search is conducted. `cnfine' may 
              consist of a single interval or a collection of  
              intervals.  
 
              The endpoints of the time intervals comprising `cnfine'
              are interpreted as seconds past J2000 TDB.
               
              See the Examples section below for a code example  
              that shows how to create a confinement window. 
 </PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   cnfine     is the input confinement window, updated if necessary
              so the control area of its data array indicates the
              window's size and cardinality. The window data are
              unchanged.


   result     is a SPICE window representing the set of time 
              intervals, within the confinement period, when the 
              specified target intersection with the FOV occurs. 
 
              The endpoints of the time intervals comprising `result'
              are interpreted as seconds past J2000 TDB.

              If `result' is non-empty on input, its contents 
              will be discarded before <b>gffove_c</b> conducts its 
              search. 
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 

   All parameters described here are declared in the header file
   SpiceGF.h. See that file for parameter values.
 
   SPICE_GF_CNVTOL     

              is the convergence tolerance used for finding endpoints
              of the intervals comprising the result window.
              SPICE_GF_CNVTOL is used to determine when binary searches
              for roots should terminate: when a root is bracketed
              within an interval of length SPICE_GF_CNVTOL; the root is
              considered to have been found.
 
              The accuracy, as opposed to precision, of roots found by
              this routine depends on the accuracy of the input data.
              In most cases, the accuracy of solutions will be inferior
              to their precision.

 
   SPICE_GF_MAXVRT

              is the maximum number of vertices that may be used 
              to define the boundary of the specified instrument's 
              field of view. 


   SPICE_GF_MARGIN     

              is a small positive number used to constrain the
              orientation of the boundary vectors of polygonal
              FOVs. Such FOVs must satisfy the following constraints:

                 1)  The boundary vectors must be contained within
                     a right circular cone of angular radius less
                     than than (pi/2) - SPICE_GF_MARGIN radians; in other
                     words, there must be a vector A such that all
                     boundary vectors have angular separation from
                     A of less than (pi/2)-SPICE_GF_MARGIN radians.

                 2)  There must be a pair of boundary vectors U, V
                     such that all other boundary vectors lie in the
                     same half space bounded by the plane containing U
                     and V. Furthermore, all other boundary vectors
                     must have orthogonal projections onto a specific
                     plane normal to this plane (the normal plane
                     contains the angle bisector defined by U and V)
                     such that the projections have angular separation
                     of at least 2*SPICE_GF_MARGIN radians from the
                     plane spanned by U and V.
 
   See header file SpiceGF.h for declarations and descriptions of  
   parameters used throughout the GF system. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1)  In order for this routine to produce correct results, 
       the step size must be appropriate for the problem at hand. 
       Step sizes that are too large may cause this routine to miss 
       roots; step sizes that are too small may cause this routine 
       to run unacceptably slowly and in some cases, find spurious 
       roots. 
 
       This routine does not diagnose invalid step sizes, except 
       that if the step size is non-positive, the error  
       SPICE(INVALIDSTEPSIZE) will be signaled. 
 
   2)  Due to numerical errors, in particular, 
 
          - Truncation error in time values 
          - Finite tolerance value 
          - Errors in computed geometric quantities 
 
       it is *normal* for the condition of interest to not always be 
       satisfied near the endpoints of the intervals comprising the 
       result window. 
 
       The result window may need to be contracted slightly by the 
       caller to achieve desired results. The SPICE window routine 
       <a href="wncond_c.html">wncond_c</a> can be used to contract the result window. 
 
   3)  If the name of either the target or observer cannot be 
       translated to a NAIF ID code, the error will be diagnosed by 
       a routine in the call tree of this routine. 
        
   4)  If the specified aberration correction is not a supported value
       for the target type (ephemeris object or ray), the error will be
       diagnosed by a routine in the call tree of this routine.
 
   5)  If the radii of a target body modeled as an ellipsoid cannot 
       be determined by searching the kernel pool for a kernel 
       variable having a name of the form 
 
          &quot;BODYnnn_RADII&quot;  
 
       where nnn represents the NAIF integer code associated with 
       the body, the error will be diagnosed by a routine in the 
       call tree of this routine. 
 
   6)  If the target body coincides with the observer body `obsrvr', 
       the error will be diagnosed by a routine in the call tree of 
       this routine. 
        
   7)  If the body model specifier `tshape' is not recognized, the 
       error will be diagnosed by a routine in the call tree of this 
       routine. 
 
   8)  If a target body-fixed reference frame associated with a  
       non-point target is not recognized, the error will be 
       diagnosed by a routine in the call tree of this routine. 
 
   9)  If a target body-fixed reference frame is not centered at 
       the corresponding target body,  the error will be 
       diagnosed by a routine in the call tree of this routine. 
 
   10) If the instrument name `inst' does not have corresponding NAIF 
       ID code, the error will be diagnosed by a routine in the call 
       tree of this routine. 
 
   11) If the FOV parameters of the instrument are not present in 
       the kernel pool, the error will be be diagnosed by routines 
       in the call tree of this routine. 
 
   12) If the FOV boundary has more than SPICE_GF_MAXVRT vertices, 
       the error will be be diagnosed by routines in the call tree of
       this routine.
 
   13) If the instrument FOV is polygonal, and this routine cannot
       find a ray R emanating from the FOV vertex such that maximum
       angular separation of R and any FOV boundary vector is within
       the limit (pi/2)-SPICE_GF_MARGIN radians, the error will be
       diagnosed by a routine in the call tree of this routine. If the
       FOV is any other shape, the same error check will be applied
       with the instrument boresight vector serving the role of R.

   14) If the loaded kernels provide insufficient data to compute a 
       requested state vector, the error will be diagnosed by a 
       routine in the call tree of this routine. 
 
   15) If an error occurs while reading an SPK or other kernel file, 
       the error will be diagnosed by a routine in the call tree  
       of this routine. 
 
   16) If the output SPICE window `result' has insufficient capacity 
       to contain the number of intervals on which the specified 
       visibility condition is met, the error will be diagnosed 
       by a routine in the call tree of this routine. 
 
   17) If the convergence tolerance size is non-positive, the error 
       SPICE(INVALIDTOLERANCE) will be signaled. 
 
   18) If the step size is non-positive, the error 
       SPICE(INVALIDSTEP) will be signaled. 

   19) If the ray's direction vector is zero, the error 
       SPICE(ZEROVECTOR) is signaled. 

   20) If any input string argument pointer is null, the error
       SPICE(NULLPOINTER) will be signaled.
 
   21) If any input string argument other than `tframe', `target',
       or `obsrvr' is empty, the error SPICE(EMPTYSTRING) will be
       signaled.
 
   22) If any attempt to change the handler for the interrupt 
       signal SIGINT fails, the error SPICE(SIGNALFAILURE) is
       signaled.

   23) If operation of this routine is interrupted, the output result
       window will be invalid.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
   Appropriate SPICE kernels must be loaded by the 
   calling program before this routine is called. 
 
   The following data are required: 
 
      - SPK data:  ephemeris data for target and observer that  
        describes the ephemeris of these objects for the period 
        defined by the confinement window, `cnfine' must be 
        loaded.  If aberration corrections are used, the states of 
        target and observer relative to the solar system barycenter 
        must be calculable from the available ephemeris data. 
        Typically ephemeris data are made available by loading one 
        or more SPK files via <a href="furnsh_c.html">furnsh_c</a>. 
 
      - Frame data:  if a frame definition is required to convert 
        the observer and target states to the body-fixed frame of 
        the target, that definition must be available in the kernel 
        pool. Typically the definitions of frames not already 
        built-in to SPICE are supplied by loading a frame kernel. 
 
        Data defining the reference frame associated with the 
        instrument designated by `inst' must be available in the kernel 
        pool. Additionally the name `inst' must be associated with an 
        ID code. Normally these data are  made available by loading 
        a frame kernel via <a href="furnsh_c.html">furnsh_c</a>. 
 
      - IK data: the kernel pool must contain data such that 
        the CSPICE routine <a href="getfov_c.html">getfov_c</a> may be called to obtain 
        parameters for `inst'. Normally such data are provided by 
        an IK via <a href="furnsh_c.html">furnsh_c</a>. 
 
   The following data may be required: 
 
      - PCK data: bodies modeled as triaxial ellipsoids must have 
        orientation data provided by variables in the kernel pool. 
        Typically these data are made available by loading a text 
        PCK file via <a href="furnsh_c.html">furnsh_c</a>. 
 
        Bodies modeled as triaxial ellipsoids must have semi-axis 
        lengths provided by variables in the kernel pool. Typically 
        these data are made available by loading a text PCK file via 
        <a href="furnsh_c.html">furnsh_c</a>. 
 
      - CK data: if the instrument frame is fixed to a spacecraft, 
        at least one CK file will be needed to permit transformation 
        of vectors between that frame and both J2000 and the target 
        body-fixed frame. 
 
      - SCLK data:  if a CK file is needed, an associated SCLK 
        kernel is required to enable conversion between encoded SCLK 
        (used to time-tag CK data) and barycentric dynamical time 
        (TDB). 

      - Since the input ray direction may be expressed in any  
        frame, FKs, CKs, SCLK kernels, PCKs, and SPKs may be 
        required to map the direction to the J2000 frame. 
 
   Kernel data are normally loaded once per program run, NOT every 
   time this routine is called. 
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   This routine determines a set of one or more time intervals within
   the confinement window when a specified ray or any portion of a
   specified target body appears within the field of view of a
   specified instrument. We'll use the term &quot;visibility event&quot; to
   designate such an appearance. The set of time intervals resulting
   from the search is returned as a SPICE window.
 
   This routine provides the SPICE GF system's most flexible 
   interface for searching for FOV intersection events. 
  
   Applications that require do not require support for progress 
   reporting, interrupt handling, non-default step or refinement 
   functions, or non-default convergence tolerance normally should 
   call either <a href="gftfov_c.html">gftfov_c</a> or <a href="gfrfov_c.html">gfrfov_c</a> rather than this routine. 
 
   Below we discuss in greater detail aspects of this routine's 
   solution process that are relevant to correct and efficient use 
   of this routine in user applications. 
 
 
   The Search Process 
   ================== 
 
   The search for visibility events is treated as a search for state
   transitions: times are sought when the state of the target ray or
   body changes from &quot;not visible&quot; to &quot;visible&quot; or vice versa.
 
   Step Size 
   ========= 
 
   Each interval of the confinement window is searched as follows: 
   first, the input step size is used to determine the time 
   separation at which the visibility state will be sampled. 
   Starting at the left endpoint of an interval, samples will be 
   taken at each step. If a state change is detected, a root has 
   been bracketed; at that point, the &quot;root&quot;--the time at which the 
   state change occurs---is found by a refinement process, for 
   example, via binary search. 
 
   Note that the optimal choice of step size depends on the lengths 
   of the intervals over which the visibility state is constant: 
   the step size should be shorter than the shortest visibility event 
   duration and the shortest period between visibility events, within 
   the confinement window. 
 
   Having some knowledge of the relative geometry of the target and 
   observer can be a valuable aid in picking a reasonable step size. 
   In general, the user can compensate for lack of such knowledge by 
   picking a very short step size; the cost is increased computation 
   time. 
 
   Note that the step size is not related to the precision with which 
   the endpoints of the intervals of the result window are computed. 
   That precision level is controlled by the convergence tolerance. 
 
 
   Convergence Tolerance 
   ===================== 
 
   The times of state transitions are called ``roots.''

   Once a root has been bracketed, a refinement process is used to
   narrow down the time interval within which the root must lie. This
   refinement process terminates when the location of the root has been
   determined to within an error margin called the &quot;convergence
   tolerance.&quot; 

   The convergence tolerance used by high-level GF routines that call
   this routine is set via the parameter SPICE_GF_CNVTOL, which is
   declared in the header file SpiceGF.h. The value of SPICE_GF_CNVTOL
   is set to a &quot;tight&quot; value so that the tolerance doesn't become the
   limiting factor in the accuracy of solutions found by this routine.
   In general the accuracy of input data will be the limiting factor.
 
   Setting the input tolerance `tol' tighter than SPICE_GF_CNVTOL is
   unlikely to be useful, since the results are unlikely to be more
   accurate. Making the tolerance looser will speed up searches
   somewhat, since a few convergence steps will be omitted. However, in
   most cases, the step size is likely to have a much greater effect on
   processing time than would the convergence tolerance.
 
 
   The Confinement Window 
   ====================== 
 
   The simplest use of the confinement window is to specify a time
   interval within which a solution is sought. However, the confinement
   window can, in some cases, be used to make searches more efficient.
   Sometimes it's possible to do an efficient search to reduce the size
   of the time period over which a relatively slow search of interest
   must be performed. For an example, see the program CASCADE in the
   GF Example Programs chapter of the GF Required Reading, gf.req.
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
   The numerical results shown for these examples may differ across 
   platforms. The results depend on the SPICE kernels used as 
   input, the compiler and supporting libraries, and the machine  
   specific arithmetic implementation.  
 
 
   1) Conduct a search using default GF progress reporting 
      and interrupt handling capabilities. 

      The program will use console I/O to display a simple
      ASCII-based progress report. 

      The program will trap keyboard interrupts (on most systems,
      generated by typing the &quot;control C&quot; key combination). This
      feature can be used in non-trivial applications to allow
      the application to continue after a search as been interrupted.

      Search for times when Saturn's satellite Phoebe is within 
      the FOV of the Cassini narrow angle camera (CASSINI_ISS_NAC). 
      To simplify the problem, restrict the search to a short time 
      period where continuous Cassini bus attitude data are 
      available. 
 
      Use a step size of 1 second to reduce chances of missing 
      short visibility events. 
       
      Use the meta-kernel shown below to load the required SPICE 
      kernels. 
 
 
         KPL/MK 
 
         File name: gffove_ex1.tm

         This meta-kernel is intended to support operation of SPICE 
         example programs. The kernels shown here should not be 
         assumed to contain adequate or correct versions of data 
         required by SPICE-based user applications. 
 
         In order for an application to use this meta-kernel, the 
         kernels referenced here must be present in the user's 
         current working directory. 
 
         The names and contents of the kernels referenced 
         by this meta-kernel are as follows: 
 
            File name                     Contents 
            ---------                     -------- 
            naif0009.tls                  Leapseconds 
            cpck05Mar2004.tpc             Satellite orientation and 
                                          radii 
            981005_PLTEPH-DE405S.bsp      Planetary ephemeris 
            020514_SE_SAT105.bsp          Satellite ephemeris 
            030201AP_SK_SM546_T45.bsp     Spacecraft ephemeris 
            cas_v37.tf                    Cassini FK 
            04135_04171pc_psiv2.bc        Cassini bus CK 
            cas00084.tsc                  Cassini SCLK kernel 
            cas_iss_v09.ti                Cassini IK 
             
 
         \begindata 
 
            KERNELS_TO_LOAD = ( 'naif0009.tls', 
                                'cpck05Mar2004.tpc', 
                                '981005_PLTEPH-DE405S.bsp', 
                                '020514_SE_SAT105.bsp', 
                                '030201AP_SK_SM546_T45.bsp', 
                                'cas_v37.tf', 
                                '04135_04171pc_psiv2.bc', 
                                'cas00084.tsc', 
                                'cas_iss_v09.ti'            ) 
         \begintext 
 
 
 
      Example code begins here. 


         #include &lt;stdio.h&gt;
         #include &quot;SpiceUsr.h&quot;

         int main()
         {
            /.
            PROGRAM EX1 
            ./

            /.
            Local constants 
            ./ 
            #define  META           &quot;gffove_ex1.tm&quot;
            #define  TIMFMT         &quot;YYYY-MON-DD HR:MN:SC.######::TDB (TDB)&quot;
            #define  TIMLEN         41
            #define  MAXWIN         10000
            #define  TIMTOL         1.e-6

            /.
            Local variables 
            ./
            SPICEDOUBLE_CELL ( cnfine, MAXWIN );
            SPICEDOUBLE_CELL ( result, MAXWIN );

            SpiceBoolean            bail;
            SpiceBoolean            rpt;

            SpiceChar             * abcorr;
            SpiceChar             * inst;
            SpiceChar             * obsrvr;
            SpiceChar             * target;
            SpiceChar             * tframe;
            SpiceChar               timstr  [2][ TIMLEN ];
            SpiceChar             * tshape;

            SpiceDouble             endpt   [2];
            SpiceDouble             et0;
            SpiceDouble             et1;
            SpiceDouble             raydir [3];

            SpiceInt                i;
            SpiceInt                j;
            SpiceInt                n;

            /.
            Load kernels. 
            ./
            <a href="furnsh_c.html">furnsh_c</a> ( META );

            /.
            Insert search time interval bounds into the
            confinement window.
            ./
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 06:30:00 TDB&quot;, &amp;et0 );
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 12:00:00 TDB&quot;, &amp;et1 );

            <a href="wninsd_c.html">wninsd_c</a> ( et0, et1, &amp;cnfine );

            /.
            Initialize inputs for the search.
            ./
            inst   = &quot;CASSINI_ISS_NAC&quot;;
            target = &quot;PHOEBE&quot;;
            tshape = &quot;ELLIPSOID&quot;;
            tframe = &quot;IAU_PHOEBE&quot;;
            abcorr = &quot;LT+S&quot;;
            obsrvr = &quot;CASSINI&quot;;

            /.
            Select a 1-second step. We'll ignore any target
            appearances lasting less than 1 second.
            ./
            <a href="gfsstp_c.html">gfsstp_c</a> ( 1.0 );

            printf ( &quot;\n&quot;
                     &quot;Instrument: %s\n&quot;
                     &quot;Target:     %s\n&quot;,
                     inst,
                     target            );

            /.
            Turn on interrupt handling and progress reporting.
            ./
            bail = SPICETRUE;
            rpt  = SPICETRUE;

            /.
            Perform the search.
            ./
            <b>gffove_c</b> ( inst,      tshape,    raydir,    target,    tframe,
                       abcorr,    obsrvr,    TIMTOL,    <a href="gfstep_c.html">gfstep_c</a>,  <a href="gfrefn_c.html">gfrefn_c</a>,
                       rpt,       <a href="gfrepi_c.html">gfrepi_c</a>,  <a href="gfrepu_c.html">gfrepu_c</a>,  <a href="gfrepf_c.html">gfrepf_c</a>,  bail,
                       <a href="gfbail_c.html">gfbail_c</a>,  &amp;cnfine,   &amp;result                        );

            if ( <a href="gfbail_c.html">gfbail_c</a>() ) 
            {
               /.
               Clear the CSPICE interrupt indication. This is
               an essential step for programs that continue
               running after an interrupt; <a href="gfbail_c.html">gfbail_c</a> will
               continue to return SPICETRUE until this step
               has been performed.
               ./
               <a href="gfclrh_c.html">gfclrh_c</a>();

               /.
               We've trapped an interrupt signal. In a realistic
               application, the program would continue operation
               from this point. In this simple example, we simply
               display a message and quit.
               ./
               printf ( &quot;\nSearch was interrupted.\n\nThis message &quot;
                        &quot;was written after an interrupt signal\n&quot;
                        &quot;was trapped. By default, the program &quot;
                        &quot;would have terminated \nbefore this message &quot;
                        &quot;could be written.\n\n&quot;                       );
            }
            else
            {

               n = <a href="wncard_c.html">wncard_c</a> ( &amp;result );

               if ( n == 0 )
               {
                  printf (  &quot;No FOV intersection found.\n&quot; );
               }
               else
               {
                  printf ( &quot;  Visibility start time              Stop time\n&quot; );

                  for ( i = 0;  i &lt; n;  i++ )
                  {
                     <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;result, i, endpt, endpt+1 );

                     for ( j = 0;  j &lt; 2;  j++ )
                     {
                        <a href="timout_c.html">timout_c</a> ( endpt[j], TIMFMT, TIMLEN, timstr[j] );
                     }

                     printf ( &quot;  %s  %s\n&quot;, timstr[0], timstr[1] ); 
                  }      
               }

               printf ( &quot;\n&quot; );

            }

            return ( 0 );
         }
 
 
      When this program was executed on a PC/Linux/gcc platform, the
      progress report had the format shown below:

         Target visibility search   2.66% done.

      The completion percentage was updated approximately once per
      second.
 
      When this program completed execution, the output was:


         Instrument: CASSINI_ISS_NAC
         Target:     PHOEBE

         Target visibility search 100.00% done.

           Visibility start time              Stop time
           2004-JUN-11 07:35:49.958590 (TDB)  2004-JUN-11 08:48:27.485965 (TDB)
           2004-JUN-11 09:03:19.767799 (TDB)  2004-JUN-11 09:35:27.634790 (TDB)
           2004-JUN-11 09:50:19.585474 (TDB)  2004-JUN-11 10:22:27.854254 (TDB)
           2004-JUN-11 10:37:19.332696 (TDB)  2004-JUN-11 11:09:28.116016 (TDB)
           2004-JUN-11 11:24:19.049484 (TDB)  2004-JUN-11 11:56:28.380304 (TDB)

 

   2) A variation of example (1): search the same confinement
      window for times when a selected background star is visible.
      We use the FOV of the Cassini ISS wide angle camera
      (CASSINI_ISS_WAC) to enhance the probability of viewing the
      star.

      The star we'll use has catalog number 6000 in the Hipparcos
      Catalog. The star's J2000 right ascension and declination,
      proper motion, and parallax are taken from that catalog.

      Use the meta-kernel from the first example.

      Example code begins here.


         #include &lt;stdio.h&gt;
         #include &lt;math.h&gt;
         #include &quot;SpiceUsr.h&quot;

         int main()
         {
            /.
            PROGRAM EX2
            ./

            /.
            Local constants 
            ./ 
            #define  META           &quot;gffove_ex1.tm&quot;
            #define  TIMFMT         &quot;YYYY-MON-DD HR:MN:SC.######::TDB (TDB)&quot;
            #define  TIMLEN         41
            #define  MAXWIN         10000
            #define  TIMTOL         1.e-6
            #define  AU             149597870.693 

            /.
            Local variables 
            ./
            SPICEDOUBLE_CELL ( cnfine, MAXWIN );
            SPICEDOUBLE_CELL ( result, MAXWIN );

            SpiceBoolean            bail;
            SpiceBoolean            rpt;

            SpiceChar             * abcorr;
            SpiceChar             * inst;
            SpiceChar             * obsrvr;
            SpiceChar             * rframe;
            SpiceChar             * target;
            SpiceChar               timstr  [2][ TIMLEN ];
            SpiceChar             * tshape;

            SpiceDouble             dec;
            SpiceDouble             decdeg;
            SpiceDouble             decdg0;
            SpiceDouble             decepc;
            SpiceDouble             decpm;
            SpiceDouble             dtdec;
            SpiceDouble             dtra;
            SpiceDouble             endpt   [2];
            SpiceDouble             et0;
            SpiceDouble             et1;
            SpiceDouble             lt;
            SpiceDouble             parlax;
            SpiceDouble             plxdeg;
            SpiceDouble             pos     [3];
            SpiceDouble             pstar   [3];
            SpiceDouble             ra;
            SpiceDouble             radeg0;
            SpiceDouble             radeg;
            SpiceDouble             raepc;
            SpiceDouble             rapm;
            SpiceDouble             raydir  [3];
            SpiceDouble             rstar;
            SpiceDouble             t;

            SpiceInt                catno;
            SpiceInt                i;
            SpiceInt                j;
            SpiceInt                n;

            /.
            Load kernels. 
            ./
            <a href="furnsh_c.html">furnsh_c</a> ( META );

            /.
            Insert search time interval bounds into the
            confinement window.
            ./
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 06:30:00 TDB&quot;, &amp;et0 );
            <a href="str2et_c.html">str2et_c</a> ( &quot;2004 JUN 11 12:00:00 TDB&quot;, &amp;et1 );

            <a href="wninsd_c.html">wninsd_c</a> ( et0, et1, &amp;cnfine );

            /.
            Initialize inputs for the search.
            ./
            inst   = &quot;CASSINI_ISS_WAC&quot;;
            target = &quot; &quot;;
            tshape = &quot;RAY&quot;;

            /.
            Create a unit direction vector pointing from
            observer to star. We'll assume the direction
            is constant during the confinement window, and
            we'll use et0 as the epoch at which to compute the
            direction from the spacecraft to the star.

            The data below are for the star with catalog
            number 6000 in the Hipparcos catalog. Angular
            units are degrees; epochs have units of Julian
            years and have a reference epoch of J1950.
            The reference frame is J2000.
            ./
            catno  = 6000;

            plxdeg = 0.000001056;

            radeg0 = 19.290789927;
            rapm   = -0.000000720;
            raepc  = 41.2000;

            decdg0 =  2.015271007;
            decpm  =  0.000001814;
            decepc = 41.1300;

            rframe = &quot;j2000&quot;;

            /.
            Correct the star's direction for proper motion.

            The argument t represents et0 as Julian years
            past J1950.
            ./
            t      =    ( et0      / <a href="jyear_c.html">jyear_c</a>() )  
                     +  ( <a href="j2000_c.html">j2000_c</a>()- <a href="j1950_c.html">j1950_c</a>() ) / 365.25;

            dtra   = t - raepc;
            dtdec  = t - decepc;

            radeg  = radeg0  +  dtra  * rapm;
            decdeg = decdg0  +  dtdec * decpm;

            ra     = radeg  * <a href="rpd_c.html">rpd_c</a>();
            dec    = decdeg * <a href="rpd_c.html">rpd_c</a>();

            <a href="radrec_c.html">radrec_c</a> ( 1.0, ra, dec, pstar );

            /.
            Correct star position for parallax applicable at
            the Cassini orbiter's position. (The parallax effect
            is negligible in this case; we're simply demonstrating
            the computation.)
            ./
            parlax = plxdeg * <a href="rpd_c.html">rpd_c</a>();
            rstar  = AU / tan(parlax);

            /.
            Scale the star's direction vector by its distance from
            the solar system barycenter. Subtract off the position
            of the spacecraft relative to the solar system barycenter;
            the result is the ray's direction vector.
            ./
            <a href="vscl_c.html">vscl_c</a> ( rstar, pstar, pstar );

            <a href="spkpos_c.html">spkpos_c</a> ( &quot;cassini&quot;, et0, &quot;j2000&quot;,  &quot;none&quot;,   
                       &quot;solar system barycenter&quot;, pos,  &amp;lt );

            <a href="vsub_c.html">vsub_c</a>   ( pstar, pos, raydir );

            /.
            Correct the star direction for stellar aberration when
            we conduct the search.
            ./
            abcorr = &quot;S&quot;;
            obsrvr = &quot;CASSINI&quot;;

            /.
            Select a 1-second step. We'll ignore any target
            appearances lasting less than 1 second.
            ./
            <a href="gfsstp_c.html">gfsstp_c</a> ( 1.0 );

            /.
            Turn on interrupt handling and progress reporting.
            ./
            bail = SPICETRUE;
            rpt  = SPICETRUE;


            printf ( &quot;\n&quot;
                     &quot;Instrument:            %s\n&quot;
                     &quot;Star's catalog number: %ld\n&quot;, 
                     inst,
                     catno                        );

            /.
            Perform the search.
            ./
            <b>gffove_c</b> ( inst,      tshape,    raydir,    target,    rframe,
                       abcorr,    obsrvr,    TIMTOL,    <a href="gfstep_c.html">gfstep_c</a>,  <a href="gfrefn_c.html">gfrefn_c</a>,
                       rpt,       <a href="gfrepi_c.html">gfrepi_c</a>,  <a href="gfrepu_c.html">gfrepu_c</a>,  <a href="gfrepf_c.html">gfrepf_c</a>,  bail,
                       <a href="gfbail_c.html">gfbail_c</a>,  &amp;cnfine,   &amp;result                        );

            if ( <a href="gfbail_c.html">gfbail_c</a>() ) 
            {
               /.
               Clear the CSPICE interrupt indication. This is
               an essential step for programs that continue
               running after an interrupt; <a href="gfbail_c.html">gfbail_c</a> will
               continue to return SPICETRUE until this step
               has been performed.
               ./
               <a href="gfclrh_c.html">gfclrh_c</a>();

               /.
               We've trapped an interrupt signal. In a realistic
               application, the program would continue operation
               from this point. In this simple example, we simply
               display a message and quit.
               ./
               printf ( &quot;\nSearch was interrupted.\n\nThis message &quot;
                        &quot;was written after an interrupt signal\n&quot;
                        &quot;was trapped. By default, the program &quot;
                        &quot;would have terminated \nbefore this message &quot;
                        &quot;could be written.\n\n&quot;                       );
            }
            else
            {

               n = <a href="wncard_c.html">wncard_c</a> ( &amp;result );

               if ( n == 0 )
               {
                  printf (  &quot;No FOV intersection found.\n&quot; );
               }
               else
               {
                  printf ( &quot;  Visibility start time              Stop time\n&quot; );

                  for ( i = 0;  i &lt; n;  i++ )
                  {
                     <a href="wnfetd_c.html">wnfetd_c</a> ( &amp;result, i, endpt, endpt+1 );

                     for ( j = 0;  j &lt; 2;  j++ )
                     {
                        <a href="timout_c.html">timout_c</a> ( endpt[j], TIMFMT, TIMLEN, timstr[j] );
                     }

                     printf ( &quot;  %s  %s\n&quot;, timstr[0], timstr[1] ); 
                  }      
               }

               printf ( &quot;\n&quot; );

            }

            return ( 0 );
         }
  

      When this program was executed on a PC/Linux/gcc platform, the
      output was:


         Instrument:            CASSINI_ISS_WAC
         Star's catalog number: 6000

         Target visibility search 100.00% done.

           Visibility start time              Stop time
           2004-JUN-11 06:30:00.000000 (TDB)  2004-JUN-11 12:00:00.000000 (TDB)
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   The kernel files to be used by <b>gffove_c</b> must be loaded (normally via 
   the CSPICE routine <a href="furnsh_c.html">furnsh_c</a>) before <b>gffove_c</b> is called. 
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman  (JPL)   
   E.D. Wright   (JPL)
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.0.0, 15-APR-2009 (NJB) (EDW)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
    GF low-level target in instrument FOV search
 </PRE>
<h4>Link to routine gffove_c source file <a href='../../../src/cspice/gffove_c.c'>gffove_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:31:34 2014</pre>

</body>
</html>

