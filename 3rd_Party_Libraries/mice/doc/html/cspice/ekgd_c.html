
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>ekgd_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>ekgd_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void ekgd_c ( SpiceInt          selidx,
                 SpiceInt          row,
                 SpiceInt          elment,
                 SpiceDouble     * ddata,
                 SpiceBoolean    * null,
                 SpiceBoolean    * found  ) 
</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
 
   Return an element of an entry in a column of double precision 
   type in a specified row. 
 </PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/ek.html">EK</a> 
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   ASSIGNMENT 
   EK 
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
 
   Variable  I/O  Description 
   --------  ---  -------------------------------------------------- 
   selidx     I   Index of parent column in SELECT clause. 
   row        I   Row to fetch from. 
   elment     I   Index of element, within column entry, to fetch. 
   ddata      O   Double precision element of column entry. 
   null       O   Flag indicating whether column entry was null. 
   found      O   Flag indicating whether column was present in row. 
 </PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
 
   selidx         is the SELECT clause index of the column to fetch
                  from.  The range of selidx is from 0 to one less than
                  the number of columns in the SELECT clause.                 
 
   row            is the output row containing the entry to fetch 
                  from.  The range of row is from 0 to one less than
                  the number of rows satisfying the previous query.
 
   elment         is the index of the element of the column entry 
                  to fetch.  The normal range of elment is from 0 to 
                  one less than the size of the column's entry, but 
                  elment is allowed to exceed the number of elements in 
                  the column entry; if it does, found is returned 
                  as SPICEFALSE.  This allows the caller to read data 
                  from the column entry in a loop without checking the 
                  number of available elements first. 
 
                  Null values in variable-sized columns are 
                  considered to have size 1. 
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
 
   ddata          is the requested element of the specified column 
                  entry.  If the entry is null, ddata is undefined. 
                    
   null           is a logical flag indicating whether the entry 
                  belonging to the specified column in the specified 
                  row is null. 
 
   found          is a logical flag indicating whether the specified 
                  element was found.  If the element does not exist, 
                  found is returned as SPICEFALSE.
 </PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
 
   1)  If the input argument elment is less than 0, found is returned as
       SPICEFALSE, and the error SPICE(INVALIDINDEX) is signalled. 
       However, elment is allowed to be greater than or equal to 
       the number of elements in the specified column entry; this allows
       the caller to read data from the column entry in a loop without 
       checking the number of available elements first.  If elment is 
       greater than or equal to the number of available elements, found 
       is returned as SPICEFALSE.
 
   2)  If selidx is outside of the range established by the 
       last query passed to eksrch_, the error SPICE(INVALIDINDEX) 
       will be signalled. 
 
   3)  If the input argument row is less than 0 or greater than or
       equal to the number of rows matching the query, found is returned 
       as SPICEFALSE, and the error SPICE(INVALIDINDEX) is signalled. 
 
   4)  If the specified column does not have double precision type, the 
       error SPICE(INVALIDTYPE) is signalled. 
 
   5)  If this routine is called when no E-kernels have been loaded, 
       the error SPICE(NOLOADEDFILES) is signalled. 
 </PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
 
      The EK &quot;query and fetch&quot; suite of functions reads binary `sequence
      component' EK files.  In order for a binary EK file to be 
      accessible to this routine, the file must be `loaded' via a call 
      to the function <a href="eklef_c.html">eklef_c</a>.
 
      Text format EK files cannot be used by this routine; they must
      first be converted by binary format by the NAIF Toolkit utility
      SPACIT.
 </PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
 
   This routine allows retrieval of data from double precision columns. 
 
   This routine returns one element at a time in order to save the 
   caller from imposing a limit on the size of the column entries 
   that can be handled. 
 </PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
 
   1)  Suppose the EK table TAB contains the following columns: 
 
          Column name   Data Type   Size 
          -----------   ---------   ---- 
          DP_COL_1      DP          1 
          DP_COL_2      DP          VARIABLE 
          DP_COL_3      DP          10 
 
 
       Suppose the query 
 
          query = &quot;SELECT DP_COL_1 FROM TAB&quot;
 
       is issued to <a href="ekfind_c.html">ekfind_c</a> via the call 
 
          <a href="ekfind_c.html">ekfind_c</a> ( query, lenout, nmrows, error, errmsg );
 
       To fetch and dump column values from the rows that satisfy the 
       query, the loop below could be used.  Note that we don't check 
       the found flags returned by <b>ekgd_c</b> since we know that every 
       entry in column DP_COL_1 contains one element. 
 
          /.
          Since DP_COL_1 was the first column selected, 
          the selection index selidx is set to 0. 
          The column is scalar, so the element index eltidx 
          is set to 0.  The variable nmrows is the number of 
          matching rows returned by <a href="ekfind_c.html">ekfind_c</a>. 
          ./
 
          selidx = 0;
          eltidx = 0;
 
          for ( row = 0;  row &lt; nmrows;  row++ )
             {
             printf ( &quot;\nRow = %d\n\n&quot;, row );
 
             /.
             Fetch values from column DP_COL_1. 
             ./
             <b>ekgd_c</b> ( selidx,  row,      eltidx, 
                      dval,    &amp;isnull,  &amp;found );
                      
             if ( isnull )
                {
                printf ( &quot;%s\n&quot;, &quot;&lt;null&gt;&quot; );
                }
             else
                {
                printf ( &quot;%f\n&quot;, dval );
                }
             } 
 
 
   2)  Suppose the EK table TAB is as in example 1, and we issue 
       the query 
 
          query = &quot;SELECT DP_COL_1, DP_COL_2, DP_COL_3 FROM TAB&quot; 
 
       to <a href="ekfind_c.html">ekfind_c</a> via the call 
 
          <a href="ekfind_c.html">ekfind_c</a> ( query, lenout, &amp;nmrows, &amp;error, errmsg );
 
       To fetch and dump column values from the rows that satisfy the 
       query, the loop below could be used.  Note that we don't check 
       the found flags returned by <b>ekgd_c</b> since we know in advance how 
       many elements are contained in each column entry we fetch. 
 
 
          for ( row = 0;  row &lt; nmrows;  row++ )
          {
             printf ( &quot;\nRow = %d\n\n&quot;, row );
 
             /.
             Fetch values from column DP_COL_1.  Since 
             DP_COL_1 was the first column selected, the 
             selection index selidx is set to 0. 
             ./
             
             selidx = 0; 
             eltidx = 0;
             
             <b>ekgd_c</b> ( selidx,    row,      eltidx, 
                      dvals[0],  &amp;isnull,  &amp;found ) 

             printf ( &quot;\nColumn = DP_COL_1\n\n&quot; );
             
             if ( isnull )
                {
                printf ( &quot;%s\n&quot;, &quot;&lt;null&gt;&quot; );
                }
             else
                {
                printf ( &quot;%f\n&quot;, dvals[0] );
                }

 
             /.
             Fetch values from column DP_COL_2 in the current 
             row.  Since DP_COL_2 contains variable-size array 
             entries, we call <a href="eknelt_c.html">eknelt_c</a> to determine how many 
             elements to fetch. 
             ./
             selidx = 1;
             
             <a href="eknelt_c.html">eknelt_c</a> ( selidx, row, &amp;nelt );
             
             eltidx = 0;
             isnull = SPICEFALSE;
             
             while (  ( eltidx &lt; nelt ) &amp;&amp; ( !isnull )  )
                {
    
                <b>ekgd_c</b> ( selidx,         row,      eltidx,  
                         dvals[eltidx],  &amp;isnull,  &amp;found );
    
                eltidx++;
    
                /.
                If the column entry is null, we'll be kicked 
                out of this loop after the first iteration. 
                ./
                }
    
             printf ( &quot;\nColumn = DP_COL_2\n\n&quot; );
   
             if ( isnull )
                {
                printf ( &quot;%s\n&quot;, &quot;&lt;null&gt;&quot; );
                }
             else
                {
                for ( i = 0;  i &lt; nelt;  i++ )
                   {
                   printf ( &quot;%f\n&quot;, dvals[i] );
                   }
                } 


             /.
             Fetch values from column DP_COL_3 in the current 
             row.  We need not call <a href="eknelt_c.html">eknelt_c</a> since we know how 
             many elements are in each column entry. 
             ./
             selidx = 2;
             eltidx = 0;
             isnull = SPICEFALSE;
     
              
             while (  ( eltidx &lt; 10 ) &amp;&amp; ( !isnull )  )
                {
    
                <b>ekgd_c</b> ( selidx,         row,      eltidx, 
                         dvals[eltidx],  &amp;isnull,  &amp;found );
    
                eltidx++;
                }


             printf ( &quot;\nColumn = DP_COL_3\n\n&quot; );
   
             if ( isnull )
                {
                printf ( &quot;%s\n&quot;, &quot;&lt;null&gt;&quot; );
                }
             else
                {
                for ( i = 0;  i &lt; 10;  i++ )
                    {
                    printf ( &quot;%f\n&quot;, dvals[i] );
                    }
                }

             }
 
   3)  See the Examples section of the query routine <a href="ekfind_c.html">ekfind_c</a> 
       for an example in which the names and data types of the 
       columns from which to fetch data are not known in advance. 
 </PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
 
   None. 
 </PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
 
   N.J. Bachman   (JPL) 
 </PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 
   -CSPICE Version 1.1.1, 09-FEB-2003 (EDW)

       Minor edit to correct typo in header.

   -CSPICE Version 1.1.0, 09-JUL-1998 (NJB)
   
       Bug fix:  now uses local logical variable to capture the
       error flag value returned by the underlying f2c'd routine.

   -CSPICE Version 1.0.0, 27-MAR-1998

       Based on SPICELIB Version 1.1.0, 07-JUL-1996 (NJB)
  </PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
 
   fetch element from double precision column entry 
 </PRE>
<h4>Link to routine ekgd_c source file <a href='../../../src/cspice/ekgd_c.c'>ekgd_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:31:32 2014</pre>

</body>
</html>

