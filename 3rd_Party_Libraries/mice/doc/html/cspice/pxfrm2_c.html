
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
   <TITLE>pxfrm2_c</TITLE>
</HEAD>

<BODY style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);">
<A name="TOP"></A>

<table style="text-align: left; margin-left: auto; margin-right: auto; width: 800px;"
 border="0" cellpadding="5" cellspacing="2">
  <tbody>
    <tr>
      <td style="background-color: rgb(153, 153, 153); vertical-align: middle; text-align: center;">
      <div align="right"> 
      <small><small><a href="index.html">Index Page</a></small></small>
      </div>
      <b>pxfrm2_c</b> </td>
    </tr>

    <tr>
      <td style="vertical-align: top;">

<small><div align="center">
<A HREF="index.html#A">A</A>&nbsp;
<A HREF="index.html#B">B</A>&nbsp;
<A HREF="index.html#C">C</A>&nbsp;
<A HREF="index.html#D">D</A>&nbsp;
<A HREF="index.html#E">E</A>&nbsp;
<A HREF="index.html#F">F</A>&nbsp;
<A HREF="index.html#G">G</A>&nbsp;
<A HREF="index.html#H">H</A>&nbsp;
<A HREF="index.html#I">I</A>&nbsp;
<A HREF="index.html#J">J</A>&nbsp;
<A HREF="index.html#K">K</A>&nbsp;
<A HREF="index.html#L">L</A>&nbsp;
<A HREF="index.html#M">M</A>&nbsp;
<A HREF="index.html#N">N</A>&nbsp;
<A HREF="index.html#O">O</A>&nbsp;
<A HREF="index.html#P">P</A>&nbsp;
<A HREF="index.html#Q">Q</A>&nbsp;
<A HREF="index.html#R">R</A>&nbsp;
<A HREF="index.html#S">S</A>&nbsp;
<A HREF="index.html#T">T</A>&nbsp;
<A HREF="index.html#U">U</A>&nbsp;
<A HREF="index.html#V">V</A>&nbsp;
<A HREF="index.html#W">W</A>&nbsp;
<A HREF="index.html#X">X</A>&nbsp;
</div></small>
       <br>
       <table style="text-align: left; width: 60%; margin-left: auto; margin-right: auto;"
       border="0" cellspacing="2" cellpadding="2">
        <tbody>
          <tr>
            <td style="width: 33%; text-align: center;">
            <small>
              <a href="#Procedure">Procedure<br></a>
              <a href="#Abstract">Abstract<br></a>
              <a href="#Required_Reading">Required_Reading<br></a>
              <a href="#Keywords">Keywords<br></a>
              <a href="#Brief_I/O">Brief_I/O<br></a>
              <a href="#Detailed_Input">Detailed_Input<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Detailed_Output">Detailed_Output<br></a>
              <a href="#Parameters">Parameters<br></a>
              <a href="#Exceptions">Exceptions<br></a>
              <a href="#Files">Files<br></a>
              <a href="#Particulars">Particulars<br></a>
              <a href="#Examples">Examples<br></a>

              </small>
              </td>
              <td style="vertical-align: top; width: 33%; text-align: center;">
              <small>               <a href="#Restrictions">Restrictions<br></a>
              <a href="#Literature_References">Literature_References<br></a>
              <a href="#Author_and_Institution">Author_and_Institution<br></a>
              <a href="#Version">Version<br></a>
              <a href="#Index_Entries">Index_Entries<br></a>
             </small>
            </td>
          </tr>
        </tbody>
</table>

<h4><a name="Procedure">Procedure</a></h4>
<PRE>
   void pxfrm2_c ( ConstSpiceChar   * from,
                   ConstSpiceChar   * to,
                   SpiceDouble        etfrom,
                   SpiceDouble        etto,
                   SpiceDouble        rotate[3][3]     )

</PRE>
<h4><a name="Abstract">Abstract</a></h4>
<PRE>
   Return the 3x3 matrix that transforms position vectors from one
   specified frame at a specified epoch to another specified
   frame at another specified epoch.
</PRE>
<h4><a name="Required_Reading">Required_Reading</a></h4>
<PRE>
 
   <a href="../req/frames.html">FRAMES</a>
 </PRE>
<h4><a name="Keywords">Keywords</a></h4>
<PRE>
 
   FRAMES
   TRANSFORM
 

</PRE>
<h4><a name="Brief_I/O">Brief_I/O</a></h4>
<PRE>
   VARIABLE  I/O  DESCRIPTION
   --------  ---  --------------------------------------------------
   from       I   Name of the frame to transform from.
   to         I   Name of the frame to transform to.
   etfrom     I   Evaluation time of `from' frame.
   etto       I   Evaluation time of `to' frame.
   rotate     O   A position transformation matrix from
                  frame `from' to frame `to'.
</PRE>
<h4><a name="Detailed_Input">Detailed_Input</a></h4>
<PRE>
   from       is the name of a reference frame recognized by
              cspice that corresponds to the input `etfrom'.


   to         is the name of a reference frame recognized by
              cspice that corresponds to the desired output
              at `etto'.


   etfrom     is the epoch in ephemeris seconds past the epoch
              of J2000 (TDB) corresponding to the `from' reference
              frame.


   etto       is the epoch in ephemeris seconds past the epoch
              of J2000 (TDB) that corresponds to the `to' reference
              frame.
</PRE>
<h4><a name="Detailed_Output">Detailed_Output</a></h4>
<PRE>
   rotate     is the transformation matrix that relates the reference
              frame `from' at epoch `etfrom' to the frame `to' at epoch
              `etto'.

              If (x, y, z) is a position relative to the reference
              frame `from' at time `etfrom' then the vector ( x', y',
              z') is the same position relative to the frame `to' at
              epoch `etto'. Here the vector ( x', y', z' ) is defined
              by the equation:

                 -   -       -        -     -  -
                | x'  |     |          |   | x  |
                | y'  |  =  |  rotate  |   | y  |
                | z'  |     |          |   | z  |
                 -   -       -        -     -  -</PRE>
<h4><a name="Parameters">Parameters</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Exceptions">Exceptions</a></h4>
<PRE>
   1)  If sufficient information has not been supplied via loaded
       SPICE kernels to compute the transformation between the
       two frames, the error will be diagnosed by a routine
       in the call tree to this routine.

   2)  If either frame `from' or `to' is not recognized the error
       'SPICE(UNKNOWNFRAME)' will be signaled.
</PRE>
<h4><a name="Files">Files</a></h4>
<PRE>
   Appropriate kernels must be loaded by the calling program before
   this routine is called.  Kernels that may be required include
   SPK files, PCK files, frame kernels, C-kernels, and SCLK kernels.

   Such kernel data are normally loaded once per program
   run, NOT every time this routine is called.
</PRE>
<h4><a name="Particulars">Particulars</a></h4>
<PRE>
   The routine `<b>pxfrm2_c</b>' is most commonly used to transform a
   position between time-dependant reference frames.

   For more examples of where to use `<b>pxfrm2_c</b>', please see:

         <a href="sincpt_c.html">sincpt_c</a>
         <a href="surfpt_c.html">surfpt_c</a>
         <a href="subslr_c.html">subslr_c</a>
         <a href="ilumin_c.html">ilumin_c</a>
</PRE>
<h4><a name="Examples">Examples</a></h4>
<PRE>
      The numerical results shown for these examples may differ across
      platforms. The results depend on the SPICE kernels used as
      input, the compiler and supporting libraries, and the machine
      specific arithmetic implementation.
 
      1) Suppose that MGS has taken a picture of Mars at time `etrec' with
         the MOC narrow angle camera. We want to know the latitude and
         longitude associated with two pixels projected to Mars'
         surface: the boresight and one along the boundary of the
         field of view (FOV). Due to light time, the photons taken in
         the picture left Mars at time `etemit', when Mars was at a
         different state than at time `etrec'.
 
         In order to solve this problem, we could use the `<a href="sincpt_c.html">sincpt_c</a>'
         routine for both pixels, but this would be slow.  Instead, we
         will assume that the light time for each pixel is the same. We
         will call `<a href="sincpt_c.html">sincpt_c</a>' once to get the light time and surface point
         associated with the boresight. Then, we will rotate one of the
         FOV boundary vectors from the camera frame at `etrec' to the
         body-fixed Mars frame at `etemit', and call the faster routine
         `<a href="surfpt_c.html">surfpt_c</a>' to retrieve the surface point for one of the FOV
         boundary vectors.
 
         This example problem could be extended to find the latitude
         and longitude associated with every pixel in an instrument's
         field of view, but this example is simplified to only solve
         for two pixels:  the boresight and one along the boundary of
         the field of view.
 
         Assumptions:
 
            1)  The light times from the surface points in the camera's
                field of view to the camera are equal.
 
            2)  The camera offset from the center of gravity of the
                spacecraft is zero. If the data are more accurate
                and precise, this assumption can be easily discarded.
 
            3)  An ellipsoid shape model for the target body is
                sufficient.
 
            4)  The boundary field of view vector returned from `<a href="getfov_c.html">getfov_c</a>'
                is associated with a boundary field of view pixel. If
                this example were extended to include a geometric camera
                model, this assumption would not be needed since the
                direction vectors associated with each pixel would be
                calculated from the geometric camera model.
 
         Use the meta-kernel shown below to load the required SPICE
         kernels.
 
            KPL/MK
 
            File name: mgs_ex.tm
 
            This is the meta-kernel file for the example problem for
            the subroutine PXFRM2. These kernel files can be found in
            the NAIF archives.
 
            In order for an application to use this meta-kernel, the
            kernels referenced here must be present in the user's
            current working directory.
 
            The names and contents of the kernels referenced
            by this meta-kernel are as follows:
 
               File name                     Contents
               ---------                     --------
               de421.bsp                     Planetary ephemeris
               pck00009.tpc                  Planet orientation and
                                             radii
               naif0009.tls                  Leapseconds
               mgs_ext12_ipng_mgs95j.bsp     MGS ephemeris
               mgs_moc_v20.ti                MGS MOC instrument
                                             parameters
               mgs_sclkscet_00061.tsc        MGS SCLK coefficients
               mgs_sc_ext12.bc               MGS s/c bus attitude
 
            \begindata
 
            KERNELS_TO_LOAD = ( 'de421.bsp',
                                'pck00009.tpc',
                                'naif0009.tls',
                                'mgs_ext12_ipng_mgs95j.bsp',
                                'mgs_moc_v20.ti',
                                'mgs_sclkscet_00061.tsc',
                                'mgs_sc_ext12.bc' )
 
            \begintext
 
            End of meta-kernel.

      Example code begins here.

            #include &lt;stdio.h&gt;
            #include &lt;math.h&gt;
            #include &quot;SpiceUsr.h&quot;

            int main()
            {
                /.
                 Constants 

                 ABCORR is the desired light time and stellar
                 aberration correction setting.

                 METAKR is the name of the meta-kernel.
                ./

                 #define ABCORR &quot;CN+S&quot;
                 #define METAKR &quot;mgs_ex.tm&quot;
                 #define FRMNLN 32
                 #define NCORNR 4
                 #define SHPLEN 80

                 /.
                 Local variables  
                 ./
                 SpiceBoolean            found;

                 /. 
                 MGS_MOC_NA is the name of the camera that took
                 the picture being analyzed.
                 ./
                 SpiceChar              *camera  = &quot;MGS_MOC_NA&quot;; 

                 /. 
                 The variable `obsref' is the observer reference frame
                 on MGS.
                 ./
                 SpiceChar               obsref [FRMNLN] ;
                 SpiceChar               shape  [SHPLEN] ;

                 SpiceDouble             bounds [NCORNR][3];
                 SpiceDouble             bndvec [3];
                 SpiceDouble             bsight [3];
                 SpiceDouble             dist;

                 /.
                 The variable `etemit' is the time at which the photons were
                 emitted from Mars, and `etrec' is the time at
                 which the picture was taken by MGS.
                 ./
                 SpiceDouble             etemit;
                 SpiceDouble             etrec;

                 /. 
                 The variables `lat' and `lon' and the latitude and longitude
                 associated with one of the boundary FOV vectors.
                 ./
                 SpiceDouble             lat;
                 SpiceDouble             lon;

                 /.
                 The variable `pmgsmr' is the opposite of the apparent
                 position of Mars with respect to MGS.
                 ./
                 SpiceDouble             pmgsmr [3];

                 /.
                 The variable `radii' is a vector of the semi-axes of Mars.
                 ./
                 SpiceDouble             radii [3];
                 SpiceDouble             radius;

                 /.
                 The variable `rotate' is a position transformation matrix
                 from the camera frame at `etrec' to the IAU_MARS frame
                 at `etemit'.
                 ./
                 SpiceDouble             rotate [3][3];
                 SpiceDouble             spoint [3];
                 SpiceDouble             srfvec [3];
                 SpiceDouble             tmp [3];

                 SpiceInt                camid;
                 SpiceInt                dim;
                 SpiceInt                n;


                 /.  ------------------ Program Setup ------------------

                 Load kernels.
                 ./
                 <a href="furnsh_c.html">furnsh_c</a> ( METAKR );

                 /.
                 Convert the time the picture was taken from a
                 UTC time string to seconds past J2000, TDB.
                 ./
                 <a href="str2et_c.html">str2et_c</a> ( &quot;2003 OCT 13 06:00:00 UTC&quot;, &amp;etrec );

                 /.
                 Assume the one-way light times from different
                 surface points on Mars to MGS within the camera's
                 FOV are equal. This means the photons that make
                 up different pixels were all emitted from Mars at
                 `etemit' and received by the MGS MOC camera at `etrec'. It
                 would be slow to process images using `<a href="sincpt_c.html">sincpt_c</a>' for every
                 pixel. Instead, we will use `<a href="sincpt_c.html">sincpt_c</a>' on the
                 boresight pixel and use `<a href="surfpt_c.html">surfpt_c</a>' for one of the FOV
                 boundary pixels. If this example program were extended
                 to include all of the camera's pixels, `<a href="surfpt_c.html">surfpt_c</a>' would
                 be used for the remaining pixels.

                 Get the MGS MOC Narrow angle camera (MGS_MOC_NA)
                 ID code. Then look up the field of view (FOV)
                 parameters by calling `<a href="getfov_c.html">getfov_c</a>'.
                 ./

                 <a href="bodn2c_c.html">bodn2c_c</a> ( camera, &amp;camid, &amp;found );
                 if ( !found  )
                 {
                   <a href="setmsg_c.html">setmsg_c</a> (&quot;Could not find ID code for instrument #.&quot; );
                   <a href="errch_c.html">errch_c</a>  (&quot;#&quot;, camera );
                   <a href="sigerr_c.html">sigerr_c</a> (&quot;SPICE(NOTRANSLATION)&quot;);
                 }

                 /.
                 `<a href="getfov_c.html">getfov_c</a>' will return the name of the camera-fixed frame
                 in the string `obsref', the camera boresight vector in
                 the array `bsight', and the FOV corner vectors in the
                 array `bounds'.
                 ./

                 <a href="getfov_c.html">getfov_c</a> ( camid,  NCORNR, SHPLEN, FRMNLN, shape,
                            obsref, bsight, &amp;n,     bounds        );

                 printf( &quot;Observation Reference Frame:  %s\n&quot;, obsref );

                 /. ----------- Boresight Surface Intercept ----------- 

                 Retrieve the time, surface intercept point, and vector
                 from MGS to the boresight surface intercept point
                 in IAU_MARS coordinates.
                 ./
                 <a href="sincpt_c.html">sincpt_c</a> ( &quot;Ellipsoid&quot;, &quot;Mars&quot;, etrec, &quot;IAU_MARS&quot;, 
                            ABCORR, &quot;MGS&quot;,   obsref, 
                            bsight,  spoint, &amp;etemit, srfvec, &amp;found );
                 if ( !found  )
                 {
                   <a href="setmsg_c.html">setmsg_c</a>(&quot;Intercept not found for the boresight vector.&quot;);
                   <a href="sigerr_c.html">sigerr_c</a>(&quot;SPICE(NOINTERCEPT)&quot;);
                 }

                 /.
                 Convert the intersection point of the boresight
                 vector and Mars from rectangular into latitudinal
                 coordinates. Convert radians to degrees.
                 ./
                 <a href="reclat_c.html">reclat_c</a> ( spoint, &amp;radius, &amp;lon, &amp;lat );

                 lon *= <a href="dpr_c.html">dpr_c</a>();
                 lat *= <a href="dpr_c.html">dpr_c</a>();

                 printf( &quot;Boresight surface intercept coordinates:\n&quot;
                         &quot;    Radius    (km) :  %f\n&quot;
                         &quot;    Latitude  (deg):  %f\n&quot;
                         &quot;    Longitude (deg):  %f\n&quot;,
                         radius, lat, lon );

                 /.---- A Boundary FOV Surface Intercept (`<a href="surfpt_c.html">surfpt_c</a>') -----

                 Now we will transform one of the FOV corner vectors into the
                 IAU_MARS frame so the surface intercept point can be
                 calculated using <a href="surfpt_c.html">surfpt_c</a>, which is faster than <a href="subpnt_c.html">subpnt_c</a>.

                 If this example program were extended to include all
                 of the pixels in the camera's FOV, a few steps, such as
                 finding the rotation matrix from the camera frame to the
                 IAU_MARS frame, looking up the radii values for Mars,
                 and finding the position of MGS with respect to Mars could
                 be done once and used for every pixel.

                 Find the rotation matrix from the ray's reference
                 frame at the time the photons were received (etrec)
                 to IAU_MARS at the time the photons were emitted
                 (etemit).
                 ./
                 <b>pxfrm2_c</b> ( obsref, &quot;IAU_MARS&quot;, etrec, etemit, rotate );

                 /.     
                 Look up the radii values for Mars.
                 ./
                 <a href="bodvrd_c.html">bodvrd_c</a> ( &quot;MARS&quot;, &quot;RADII&quot;, 3, &amp;dim, radii );

                 /.
                 Find the position of the center of Mars with respect
                 to MGS.  The position of the observer with respect
                 to Mars is required for the call to `<a href="surfpt_c.html">surfpt_c</a>'.  Note:
                 the apparent position of MGS with respect to Mars is
                 not the same as the negative of Mars with respect to MGS.
                 ./
                 <a href="vsub_c.html">vsub_c</a> ( spoint, srfvec, pmgsmr );

                 /.
                 The selected boundary FOV pixel must be rotated into the
                 IAU_MARS reference frame.
                 ./
                 <a href="mxv_c.html">mxv_c</a> ( rotate, bounds[1], bndvec );

                 /.
                 Calculate the surface point of the boundary FOV
                 vector.
                 ./
                 <a href="surfpt_c.html">surfpt_c</a> ( pmgsmr, bndvec, radii[0], radii[1], radii[2], 
                            spoint, &amp;found );

                 if ( !found  )
                 {
                   <a href="setmsg_c.html">setmsg_c</a> (&quot;Could not calculate surface point.&quot;);
                   <a href="sigerr_c.html">sigerr_c</a> (&quot;SPICE(NOTFOUND)&quot;);
                 }
                 <a href="vequ_c.html">vequ_c</a> ( spoint, tmp );

                 /.
                 Convert the intersection point of the boundary
                 FOV vector and Mars from rectangular into
                 latitudinal coordinates. Convert radians
                 to degrees.
                 ./
                 <a href="reclat_c.html">reclat_c</a> ( spoint, &amp;radius, &amp;lon, &amp;lat );

                 lon *= <a href="dpr_c.html">dpr_c</a>(); 
                 lat *= <a href="dpr_c.html">dpr_c</a>();

                 printf( &quot;Boundary vector surface intercept coordinates &quot;
                         &quot;using SURFPT:\n&quot;
                         &quot;    Radius    (km) :  %f\n&quot;
                         &quot;    Latitude  (deg):  %f\n&quot;
                         &quot;    Longitude (deg):  %f\n&quot;
                         &quot;    Emit time using boresight LT (s):  %10.8f\n&quot;,
                         radius, lat, lon, etemit);

                 /. ---- A Boundary FOV Surface Intercept Verification ----

                 For verification only, we will calculate the surface
                 intercept coordinates for the selected boundary vector using
                 `<a href="sincpt_c.html">sincpt_c</a>' and compare to the faster `<a href="surfpt_c.html">surfpt_c</a>' method.
                 ./
                 <a href="sincpt_c.html">sincpt_c</a> ( &quot;Ellipsoid&quot;,    &quot;Mars&quot;,   etrec, &quot;IAU_MARS&quot;,
                            ABCORR, &quot;MGS&quot;,  obsref,  bounds[1], 
                            spoint, &amp;etemit, srfvec, &amp;found );

                 if ( !found  )
                 {
                   <a href="setmsg_c.html">setmsg_c</a>(&quot;Intercept not found for the boresight vector.&quot;);
                   <a href="sigerr_c.html">sigerr_c</a>(&quot;SPICE(NOINTERCEPT)&quot;);
                 }

                 /.
                 Convert the intersection point of the selected boundary
                 vector and Mars from rectangular into latitudinal
                 coordinates. Convert radians to degrees.
                 ./
                 <a href="reclat_c.html">reclat_c</a> ( spoint, &amp;radius, &amp;lon, &amp;lat );

                 lon *= <a href="dpr_c.html">dpr_c</a>();
                 lat *= <a href="dpr_c.html">dpr_c</a>();

                 printf( &quot;Boundary vector surface intercept coordinates &quot;
                         &quot;using <a href="surfpt_c.html">surfpt_c</a>:\n&quot;
                         &quot;    Radius    (km) :  %f\n&quot;
                         &quot;    Latitude  (deg):  %f\n&quot;
                         &quot;    Longitude (deg):  %f\n&quot;
                         &quot;    Emit time using boundary LT (s):  %10.8f\n&quot;,
                         radius, lat, lon, etemit);

                 /.
                 We expect this to be a very small distance.
                 ./
                 dist = <a href="vdist_c.html">vdist_c</a> ( tmp, spoint );

                 printf( &quot;Distance between surface points of the selected &quot;
                         &quot;boundary vector using <a href="surfpt_c.html">surfpt_c</a> and <a href="sincpt_c.html">sincpt_c</a>:\n&quot;
                         &quot;    Distance (mm):    %f\n&quot;, dist*pow(10,6)   );

                 return(0);

            }

       When this program was executed using gcc on a PC Linux
       64 bit environment, the output was:

             Observation Reference Frame:  MGS_MOC_NA
             Boresight surface intercept coordinates:
                 Radius    (km) :  3384.940410
                 Latitude  (deg):  -48.479580
                 Longitude (deg):  -123.436454
             Boundary vector surface intercept coordinates using <a href="surfpt_c.html">surfpt_c</a>:
                 Radius    (km) :  3384.939699
                 Latitude  (deg):  -48.481636
                 Longitude (deg):  -123.398822
                 Emit time using boresight LT (s):  119296864.18105948
             Boundary vector surface intercept coordinates using <a href="surfpt_c.html">surfpt_c</a>:
                 Radius    (km) :  3384.939699
                 Latitude  (deg):  -48.481636
                 Longitude (deg):  -123.398823
                 Emit time using boundary LT (s):  119296864.18105949
             Distance between surface points of the selected boundary vector 
             using <a href="surfpt_c.html">surfpt_c</a> and <a href="sincpt_c.html">sincpt_c</a>:
                 Distance (mm):    32.642059
</PRE>
<h4><a name="Restrictions">Restrictions</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Literature_References">Literature_References</a></h4>
<PRE>
   None.
</PRE>
<h4><a name="Author_and_Institution">Author_and_Institution</a></h4>
<PRE>
   S. C. Krening  (JPL)
   W. L. Taber    (JPL)
</PRE>
<h4><a name="Version">Version</a></h4>
<PRE>
 -CSPICE Version 1.0.0  1-FEB-2012 (SCK) (WLT)
</PRE>
<h4><a name="Index_Entries">Index_Entries</a></h4>
<PRE>
   Position transformation matrix for different epochs
</PRE>
<h4>Link to routine pxfrm2_c source file <a href='../../../src/cspice/pxfrm2_c.c'>pxfrm2_c.c</a> </h4>

      </td>
    </tr>
  </tbody>
</table>

   <pre>Tue Jul 15 14:31:40 2014</pre>

</body>
</html>

